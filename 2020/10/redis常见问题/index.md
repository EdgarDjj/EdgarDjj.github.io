# Redis常见问题


# Redis常见问题

### Redis是什么？

Redis是通过C编写的一种**键值对存储数据库**，由于是**基于内存**的，因此**读写速度非常快**，多被用于做**缓存**。

### Redis过期Key是怎么清理的？

1. 惰性清理

在访问key时，如果发现key过期，将其清理

2. 定时清理

Redis配置项hz定义了serverCron任务的执行周期，默认每次清理时间为25ms，每次清理会依次遍历所有DB，从db随机取出20个key，如果过期就删除，如果其中有5个key过期，那么久继续对这个db进行清理，否则开始清理下一个db。

3. 内存不够时进行清理

当执行写command时，如果发现内存不够，则会按照配置的淘汰策略清理内存，淘汰策略一般有6种，Redis4.0又增加了两种，主要分为三类：

* 不处理，等报错（默认）
  * noeviction，发现内存不够时，不删除key，执行写入命令时直接返回错误信息。（Redis默认的配置就是noeviction）
* 从所有结果集的key中挑选，进行淘汰
  * allkeys-random 就是从所有的key中随机挑选key，进行淘汰
  * allkeys-lru 就是从所有的key中挑选最近使用时间距离现在最远的key，进行淘汰
  * allkeys-lfu 就是从所有的key中挑选使用频率最低的key，进行淘汰。（这是Redis 4.0版本后新增的策略）
* 从设置了过期时间的key中挑选，进行淘汰
  * volatile-random 从设置了过期时间的结果集中随机挑选key删除。
  * volatile-lru 从设置了过期时间的结果集中挑选上次使用时间距离现在最久的key开始删除
  * volatile-ttl 从设置了过期时间的结果集中挑选可存活时间最短的key开始删除(也就是从哪些快要过期的key中先删除)
  * volatile-lfu 从过期时间的结果集中选择使用频率最低的key开始删除（这是Redis 4.0版本后新增的策略）

### 如何解决Redis缓存穿透问题？

Redis**缓存穿透**指的事攻击者故意大量请求一些Redis缓存中不存在的key的数据，导致请求打在数据库上，导致数据库压力过大。

总结来说就是：

1. 缓存层不中
2. 存储层不命中，不将空结果写入缓存
3. 返回空结果给客户端

#### 解决方案

1. 做好参数校验，无效请求直接返回，只能避免部分
2. 如果缓存和数据库都查不到某个key的数据就写入到一个redis中去并设置过期时间，如 `SET key value EX 10086`。可以解决请求key变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致redis中缓存大量无效的key，因此这种方案不能从根本上解决问题，如果非要用这种方式，就需尽量将key的过期时间设置的短些，如1分钟。
3. 也可以使用布隆过滤器，将所有可能存在的数据通过hash值的方法存入到一个足够大的bitmap中去，处理请求时在bitmap中查找，可以将不存在的数据拦截掉。

> Bit-map就是一个bit位用来标记某个元素对应的Value，而Key是该元素。采用以Bit为单位来存储数据。
>
> Bit（Byte）

### 如何解决Redis缓存击穿问题？

Redis**缓存击穿**指的是某个key失效，导致大量请求全部转向数据库，导致数据库压力过大。

#### 解决方案

1. 对热点key设置永不过期
2. 加互斥锁，缓存中没有热点key对应的数据时，等待100ms，由获得的线程去读取数据库然后设置缓存

### 如何解决Redis缓存雪崩的问题？

**缓存雪崩**主要指短时间内大量key失效，导致请求全部转向数据库，导致数据库压力过大。

#### 解决方案

1. 给缓存设置失效时间加一个随机值，避免集体同时失效
2. 双缓存机制，缓存A的失效时间为20分钟，缓存B没有失效时间。从缓存A中读取数据，缓存A中没有时，去缓存B中读取，并且启动一个异步线程来更新缓存A

### 如何解决缓存与数据库的数据一致性问题？

多个诱因：

* 多个写请求顺序不同，导致脏数据。（丢失修改）
* 更新时正好有读请求，导致还没更新数据，进行读操作（脏读）
* 或者数据库读写分离，在主库更新完后，需要一定的时间，从库才更新

1. 先更新数据库，后更新缓存

1. 先删除缓存，在更新数据库
2. 先更新数据库，再删除缓存

#### 正确的方案

1. 写请求串行化

将写请求更新之前获取分布式锁，获得之后才能更新，这样实现请求的串行化，但是会导致效率遍变低。

2. 先更新数据库，异步删除缓存，删除失败之后再重试

先更新数据库，异步删除缓存，删除缓存失败时，继续异步重试，或者将操作放到消息队列中，再进行删除操作。（如果数据库是读写分离的，那么删除缓存时需要延迟删除，否则可能会删除缓存时，从库中还没有收到更新后的数据，其他读请求就去从库读到旧数据然后设置到缓存中。）

3. 业务项目更新数据库，其他项目订阅binlog更新

业务项目直接更新数据库，然后其他项目订略binlog，接收到更新数据库操作的消息后，更新缓存，更新缓存失败时，新建异步线程去重试或者将操作发到消息队列，然后后续进行处理。但是这种方案更新mysql后还是有一定延迟，缓冲中才是新值。

### Redis为什么采用单线程模型

Redis是基于内存进行操作，因此CPU不会成为瓶颈所在。

**采用单线程带来的好处：**

1. Redis项目代码清晰，处理逻辑简单
2. 不用考虑多格线程修改数据的情况，修改数据时也不用加锁，解锁等问题
3. 不存在多进程或多线程切换带来的性能开销

**劣势：**

无法充分发挥多核机器的优势，但可以启动多个Redis实例来利用资源

###  Redis的性能为何高

1. 完全基于内存操作，少去了I/O操作
2. 采用单线程模型，没有上下文开销
3. Redis项目中使用的数据结构都是经过专门设计的，例如SDS（Simple Dynamic String）对C语言中的字符串频繁修改，会频繁地进行内存分配，十分消耗性能，而SDS会使用预空间分配和惰性空间来释放避免出现这些问题。

> 如果修改后SDS实际长度为len
>
> 当len < 1M时，分配的空间会是2*len + 1，也就是预留len长度的未使用空间，其中1存储空字符
>
> 当len > 1M时，分配的空间会是len + 1 + 1M，会预留1M长度未使用空间，其中1存储空字符

4. 采用多路复用IO模型，可以同时检测多个流的IO事件能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态唤醒，轮询那些真正发出请求的流，并依次处理就绪的流。可以让单个线程高效的处理多个连接请求。

## Linux中IO模型有哪些

IO模型主要有 阻塞式I/O模型，非阻塞式I/O模型，I/O复用模型，信息驱动型I/O模型，异步I/O模型

**阻塞式**

![阻塞式](/Redis/ABUIABAEGAAg0MKrwAUosJqimgYwgAU4xQI.png)

用户发出一个IO请求，如果当前内核中的数据报未准备好，会让其一直占用CPU时间片，知道准备完成后，才让出，然后将数据报从内核拷贝用户空间内存，然后返回成功的信号，此时用户态才接触阻塞的状态处理数据报。

**非阻塞式**

![非阻塞式](/Redis/ABUIABAEGAAg7MKrwAUogfiO-QUwgAU48gI.png)

当线程处于等待内核的时候，当数据未准备成功的时候，用户态进程会一直轮询内核，直到内核准备好。

多路复用式

![多路复用](/Redis/ABUIABAEGAAg_sKrwAUojMPt1gIwgAU4mgM.png)

指多个IO复用一个进程。最初级的I/O复用，就是一个进程对应多个连接，每次从头至尾进行遍历，判断是否有I/O事件需要处理，有的话就进行处理，缺点是效率比较低，如果一直没有事件进来，会导致CPU空转。

升级版的I/O复用模型

当没有I/O事件时，进程处于阻塞状态，当有I/O事件时，就会有一个代理去唤醒进程，去进行轮询，来处理I/O事件。（这里的代理也就是select和poll，select只能观察1024个连接，poll可以观察无限个连接，因为poll是基于链表来实现的）

epoll是对select和poll的升级版，解决了很多问题，是线程安全的，而且可以通知进程是哪个Socket连接有I/O事件,提高了查找效率。

epoll和select/poll最大区别是

(1)epoll内部使用了mmap共享了用户和内核的部分空间，避免了数据的来回拷贝 

(2)epoll基于事件驱动，epoll_wait只返回发生的事件避免了像select和poll对事件的整个轮寻操作（时间复杂度为O（N）），epoll时间复杂度为O（1）。

**信号驱动式**

![信号驱动式](/Redis/ABUIABAEGAAglcOrwAUoqPiNiQYwgAU4lgM.png)

是非阻塞的，当需要数据等待的时候，用户态进程会给内核发送一个信号，告知自己需要数据，然后就去执行其他任务，待内核准备好数据会给用户态发送信号，用户态接收到信号后，会返回revfrom，等待数据从内核复制到用户内存空间，待完成之后的revfrom返回成功指示，用户态进程才处理数据。

**异步IO模型**

与信息驱动式I/O模型区别在于，是在数据从内核态拷贝到用户空间之后，内核才通知用户态进程来处理数据。在复制数据到用户空间这个时间段内，用户态进程也是不阻塞的。

## Redis主从同步是如何实现的



### Redis中哨兵是什么

edis中的哨兵服务器是一个运行在哨兵模式下的Redis服务器，核心功能是监测主节点和从节点的运行情况，在主节点出现故障后， 完成自动故障转移，让某个从节点升级为主节点

### 客户端是怎么接入哨兵系统的

首先Redis中的哨兵节点是一个配置提供者，而不是代理。 区别在于，**配置提供者**

前者只负责存储当前最新的主从节点信息，供客户端获取。

##### 代理客户端

所有请求都会经过哨兵节点。

所以实际开发中，通过在客户端配置哨兵节点的地址+主节点的名称(哨兵系统可能会监控多个主从节点，名称用于区分)就可以获取到主节点信息， 下面的代码在底层实现是客户端向依次向哨兵节点发送"sentinel get-master-addr-by-name"命令， 成功获得主节点信息就不向后面的哨兵节点发送命令。 同时客户端会订阅哨兵节点的+switch-master频道，一旦主节点发送故障，哨兵服务器对主节点进行自动故障转移，会将从节点升级主节点， 并且更新哨兵服务器中存储的主节点信息，会向+switch-master频道发送消息，客户端得到消息后重新从哨兵节点获取主节点信息，初始化连接池。

```shell
 String masterName = "mymaster";
 Set<String> sentinels = new HashSet<>();
 sentinels.add("192.168.92.128:26379");
 sentinels.add("192.168.92.128:26380");

 JedisSentinelPool pool = new JedisSentinelPool(masterName, sentinels); //初始化过程做了很多工作
 Jedis jedis = pool.getResource();
 jedis.set("key1", "value1");
 pool.close();
```

## 补充

### 布隆过滤器

布隆过滤器在针对大数据海量数据去重或验证数据合法性的时候非常有用。

**本质上是（bit）数组，即每一个存入布隆过滤器的数据都只占一位，相比平时我们使用的list、map、set等数据结构，占用的空间更少且效率更高，但缺点是返回的结果是概率性的，不是非常准确**。

#### 操作

当一个元素加入布隆过滤器中的时候：

1. 使用布隆过滤器中的hash（）函数对元素值进行计算，得到hash值（有几个hash函数得到几个hash值）
2. 根据得到的hash值，在位数组中把对应下标的值置为1

当我们需要判断一个元素是否存在于布隆过滤器的时候：

1. 对给定的元素再次进行相同的hash计算
2. 得到值之后判断位数组中的每个元素是否都为1，如果为1，则在这个布隆过滤器中，如果存在一个值不为1，则说明该元素不在布隆过滤器中。

**布隆过滤器说某个元素存在，小概率会误判，但说某个元素不存在，那一定不存在。**


