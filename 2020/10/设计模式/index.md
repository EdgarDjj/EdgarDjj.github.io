# 设计模式


# 设计模式

> 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。

设计模式分三种类型，共23种：

* 创建型模式：单例模式、建造者模式、工厂模式、抽象工厂模式、原型模式。
* 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
* 行为型模式：模板方法模式、命令模式、迭代器模式、观察者模式、策略模式、中介者模式、备忘录模式、解释器模式、责任链模式、访问者模式。

一些重要的设计模式：

**创建型模式：工厂模式、单例模式、抽象工厂模式**

**结构型模式：适配器模式、组合模式、外观模式、代理模式**

**行为型模式：命令模式、迭代器模式、观察者模式、策略模式**

![设计模式](./进阶/设计模式.jpg)

## 引言

设计面向对象的软件比较困难，而设计可复用的面向对象软件更加困难。必须找到相关的对象，以适当的粒度将他们定义，再定义类的接口和继承层次，建立对象之间的基本关系。因此设计的时候必须具有针对性，同时将带来的问题和需求也要有足够的通用性。

因此未来避免重复设计或尽可能的减少做重复设计。设计模式的诞生因此而来，它是由无数设计者们的经验堆叠而来，它们帮助设计者将新的设计建立在以往的工作的基础上，复用以往成功的设计方案。

## 创建模式

### Singleton（单态/单件）

保证一个类只有一个实例，并提供一个访问它的全局访问点

### Factory（工厂方法和抽象工厂）

使用工厂模式就像使用new一样频繁

### Builder（建造者模式）

汽车由车轮、方向盘、发动机很多部件组成，同时，将这些部件组装成汽车也是一件复杂的工作，Builder模式就是将这两种情况分开进行

### Prototype（原型）

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

## 结构模式

### Adapter（适配器）

使用类再生的两个方式：组合（new）和继承（extends)

### Proxy（代理）

剖析代理模式在于用户级别授权机制上的应用

### Facade（外观）

可拓展使用JDBC针对不同的数据库编程，提供了一种灵活的实现

### Composite（组合）

将类用树形结构组合成一个单位：你向别人介绍你是某单位，你是单位中的一个元素，别人和你做买卖，相当于和单位做买卖

### Decorator（装饰）

### Bridge（桥接）

本应在一起，分开它们，形成两个接口，在他们之间搭建一个桥（动态结合）

### Flyweight（共享元）

提供Java运行性能，降低小而大量的重复的类的开销

## 行为模式

### Command（命令）

将行为封装

### Observer（观察者模式）

如何使用JavaAPI提供的现成Observer

### Iterator（迭代器）

Java的Collection，在大多场合无需自己制造一个Iterator，只要将对象装入Collection中，直接使用Iterator进行对象遍历

### Template（模板方法）

### Strategy（策略模式）

不同算法各自封装，用户端可随意挑选需要的算法

### Chain of Responsesiability（责任链）

各司其职的类串成一串，类似击鼓传花，如果自己能完成就不要委托给下一个

### Mediator（中介）

Mediator像十字路口的红绿灯，每个车辆只需和红绿灯交互就可以

### State（状态）

状态是编程中常常碰到的实例，将状态对象化，设立状态变换器，便可在状态中轻松切换1

### Memento（注释状态）

在内存中保留原来数据的备份

### Interpreter（解释器）

对语言的分析，用的少

### Visitror（访问者）

访问者在进行访问的时候，完成一系列实质性操作，而且还可以拓展。

## 设计模式的六大原则

* 单一职责（一个类和方法只只做一件事）
* 里式替换（多态，子类可以拓展父类）
* 依赖倒置（细节依赖抽象，下层依赖上层）
* 接口隔离（建立单一接口）
* 迪米特原则（最少知道，降低耦合）
* 开闭原则（抽象架构，拓展实现）

**1、开闭原则（Open Close Principle）**

开闭原则就是说对**扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科

**3、依赖倒转原则（Dependence Inversion Principle）**

这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。

**4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

**5、迪米特法则（最少知道原则）（Demeter Principle）**

为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

**6、合成复用原则（Composite Reuse Principle）**

原则是尽量使用合成/聚合的方式，而不是使用继承。


