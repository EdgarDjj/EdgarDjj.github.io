# 虚拟机类加载机制


# 虚拟机类加载机制

> Java虚拟机把描述类的数据从Class问价加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用得当Java类型，这个过程称作虚拟机的类加载机制。

## 类加载的时机

类加载分为三个阶段：加载、连接、初始化

**生命周期：**

1. 加载Loading
2. 验证Verification
3. 准备Perparation
4. 解析Resolution
5. 初始化Initialization
6. 使用Using
7. 卸载Unloading

**连接Linking**：3、4、5

其中前五部的顺序是确定的，类加载的过程必须按此顺序进行。

>  关于在什么时候需要开始类加载的第一个过程“Loading”，可以由虚拟机自由把握。但是对于初始化阶段，则是严格规定了有且只有六种情况必须立刻对类进行”初始化Initialization

**何时触发初始化：**

1. **为一个类型创建一个新的对象实例时（比如new、反射、序列化）**
2. **调用一个类型的静态方法时（即在字节码中执行invokestatic指令）**
3. **调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式**
4. **调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法）**
5. **初始化一个类的派生类时（Java虚拟机规范明确要求初始化一个类时，它的超类必须提前完成初始化操作，接口例外）**
6. **JVM启动包含main方法的启动类时。** 

## 类加载的过程

即加载、连接（验证、准备、解析）、初始化

### 加载

1. 通过一个类的全限定名来获取定义类的二进制字节流
2. 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

加载完毕后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区中。

### 验证

确保奥class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息当做代码运行后不会危害虚拟机自身安全。

1. 文件格式验证
2. 元数据验证
   * 对字节码信息进行语义分析
3. 字节码验证
   * 主要目的是通过数据流分析和控制流分析，确定程序语义合法、符合逻辑的
4. 符号引用验证

### 准备

准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始化值的阶段。在JDK1.7及之前，HotSpot使用永久代来实现方法区，而在JDK8及以后，类变量则会随着Class对象一起存放在Java堆中。

> 注意例如：public static int value = 123；

value在准备阶段过后的初始值为0而不是123，因为在这时还未开始执行任何Java方法，而吧value赋值为123的putstatic命令是程序编译后，存放于类构造器 `<clinit>()`方法中，是在初始化阶段。

### 解析

解析阶段是Java虚拟机将常量池内符号引用替换为直接引用的过程。

* **符号引用（Symbolic References）：**符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量。
* **直接引用（Direct References）：**是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。

1. 类或接口解析
2. 字段解析
3. 方法解析
4. 接口方法解析

### 初始化

类的初始化阶段是类加载过程的最后一步，在之前的步骤中，除了在加载阶段用户应用程序可以通过自定义的类加载器的方式局部参与外，其余所有动作都完全有Java虚拟机来主导，直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权交给应用程序。

## 类加载器

”通过一个类的完全限定类名来获取描述该类的二进制字节流“这个动作放到JVM外外部去实现，以便让应用程序自己去获取所需要的类。”实现这个动作的代码被称为：**类加载器（Class Loader）**

### 类和类加载器

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确定在Java虚拟机中的唯一性，每一个类加载器都有一个独立的类名成空间。

即通俗讲：**比较两个类是否”相等“，只有在这两个类是由同一个类加载器的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，就不相等。**

### 双亲委派模型（Parents Delefation Model）

站在Java虚拟机的角度来看，只有两种不同的类加载器：

1. 启动类加载器（Bootstrap ClassLoader）是虚拟机自身的一部分；
2. 其它所有的类加载器，这些加载器都是由Java语言实现的，独立存在于虚拟机外部，并全部继承自抽象类java.lang.ClassLoader

站在Java开发人员角度来看，Class Loader应该被划分的更细致一点。

* 启动类加载器（Bootstrap Class Loader）：负责加载存放在 `<JAVA_HOME>\lib`目录，或者被参数所指定的目录中，而且是Java虚拟机能够识别的。
* 拓展加载类（Extension Class Loader）：负责加载 `<JAVA_HOME>\lb\ext`目录中，或被系统变量所制定的路径中的所有类库。
  * 应用程序加载类（Application Class Loader）：负载加载用户类路径 `ClassPath`中的所有类库。

**双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）关系来实现的，而是通常使用组合（Composition）来复用父类加载器代码。**

#### 工作流程

**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成该加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。**

好处是：Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。


