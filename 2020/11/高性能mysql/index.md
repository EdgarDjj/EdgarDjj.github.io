# 高性能MySQL


# 高性能MySQL

一条MySQL的更新语句的执行过程：

![MySQL更新语句执行过程](高性能MySQL/updateprocess.png)

## 并发控制

1. 共享锁（shared lock）读锁
2. 排他锁（exclusive lock）写锁

在不同的搜索引擎下，写锁和读锁有着不同的优先级，写锁的优先级一般大于读锁。

## 事务

### 事务ACID

* **原子性（Atomicity）：**一个事务要么执行完成，要么失败回滚。
* **一致性（consistency）：**数据库总是从一个一致性的状态转换到另一个一致性的状态。
* **隔离性（isolation）：**一个事务所做的修改在最终提交之前，对其他事务是不可见的。
* **持久性（durability）：**一旦事务提交，则其所做的修改就会永久保存到数据库中。

### 事务的隔离级别

* 读 未提交
* 读 已提交（不可重复读）
* 可重复读 REPEATABLE READ
* 可串行化 SERIALIZABLE

### 死锁

资源互相持有彼此的资源，并进行相互请求。

#### 死锁的四个条件

* 互斥条件（加锁就是为了得到互斥，因此解决死锁问题只能从另外三个条件中进行解决）
* 请求与保持条件
* 不可剥夺条件
* 循环等待条件

### 事务日志

存储引擎在修改表的数据的时候只需要修改内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到硬盘。事务日志持久后，内存中被修改的数据可以慢慢刷回到磁盘，称预写式日志（Write-Ahead-Logging）

## 多版本并发控制

MMVC是行级锁的一个变种，很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

MVCC的实现，是通过保存数据在某个时间点的快照来实现的，有乐观和悲观两种，只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。

## 基准测试

### 两种主要策略

* 集成式full-stack：针对整个系统的整体测试
* 单件式single-component：单独测试MySQL

### 测试指标

* 吞吐量：单位时间内的事务处理数，测试单位是每秒事务数（TPS），或每分钟事务（TPM）
* **响应时间**（通常也用来衡量一个数据库的性能）
* 并发性
* 可拓展性

### 基准测试方法

需要避免的一些常见错误：

* 使用真实数据的子集而不是全集
* 使用错误的数据分布
* 使用不真实的分布参数
* 在多用户场景中，只做单用户测试
* 在单服务器上测试分布式应用
* 与真实用户行为不匹配
* 反复执行同一个查询
* 没有检查错误
* 忽略了系统预热（warm up）的过程
* 使用默认的服务器配置
* 测试时间太短

2.应该建立将参数和结果文档化的规范，每一轮测试都必须进行详细记录
3.基准测试应该运行足够长的时间，需要在稳定状态下测试并观察
4.在执行基准测试时，需要尽可能多地收集被测试系统的信息
5.自动化基准测试可以防止测试人员偶尔遗漏某些步骤，或者误操作，另外也有助于归档整个测试过程，可以选择shell、php、perl等，要尽可能使所有测试过程都自动化，包括装载数据、系统预热、执行测试、记录结果等

## 服务器性能剖析

## Schema 与数据类型优化

1. 数据类型的选择原则

* 更小通常更好
* 简单就好
* 尽量避免NULL
  * 对于性能的开销极小，但对于索引的创建，查询等，开销巨大

2. 能用整数类型时，尽量使用整数类型，如IP地址等，因为字符串类型涉及道路字符集等，会有开销
3. varchar使用的合适情况：字符串列的最大长度比平均长度大很多；列更新很少，所以碎片不是问题；主要是删除时，会产生碎片垃圾，可以使用optimzation进行优化
4. 对于定长char类型，适合存储很短的字符串，长度一定的字符串，如一些加密MD5等了，不容易产生碎片，在存储空间上更有效率
5. timestamp和datetime，前者为4个字节，后者8字节，开销不一样，但timestamp可显示的时间只能从1970~2038年，但有着动态时域，不同的地方时间会自动进行时域的加减，而datetime显示时间则很大。

### 范式和反范式

第一范式：对属性的原子性

第二范式：对记录的唯一性，即实体的唯一性，不存在**部分依赖**

第三范式：对字段的冗余性，要求任何字段不能由其他字段派生出来，要求字段没有冗余，即不存在**传递依赖**

1.范式的优点：

> \* 范式化的更新操作通常比反范式化要快
> \* 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据
> \* 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快
> \* 很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句

2.范式化设计的缺点是通常需要关联
3.反范式的优点：避免关联，避免了随机I/O，能使用更有效的索引策略

### 缓存表和汇总表

1.有时提升性能最好的方法是同一张表中保存衍生的冗余数据，有时也需要创建一张完全独立的汇总表或缓存表

2.物化视图，MySQL并不原生支持，Flexviews

3.如果应用在表中保存计数器，则在更新计数器时可能踫到并发问题，创建一张独立的表存储计数器，可以帮助避免缓存失效

> \* 解决独立表并发问题可以建多行，根据id随机更新，然后统计时sum()
> \* 按天或小时可以单独建行，旧时间可定时任务合并到统一的一行

### 加快ALTER TABLE操作的速度

1. 两种方式

> 一是一台不提供服务的机器执行的ALTER TABLE 操作





### 创建高性能的索引

#### A. 索引基础

1. 索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列

2. ORM工具能够产生符合逻辑的、合法的查询，除非只是生成非常的查询，否则它很难生成适合索引的查询

3. 在MySQL中，索引是在存储引擎层而不是服务器层实现的，所以，并没有统一的索引标准。 不同的存储引擎的索引的工作方式不一样，并不是所有的存储引擎都支持所有类型的索引。

   


