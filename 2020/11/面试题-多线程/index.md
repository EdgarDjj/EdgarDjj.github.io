# 面试题-多线程


# 三、多线程

35. 并行和并发有什么区别？

* 并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时刻间隔发生
* 并行是在不同的实体上的多个事件，而并发是同一实体上的多个事件
* 并发是在一台处理器上“同时”处理多个任务，在多台处理器上处理多个任务。

36. 线程和进程的区别？
    进程是程序的一次执行，是程序资源分配和运行的基本单位。系统运行一个程序即是一个进程从创建运行到消亡的一次过程。例如在Java中，启动一个main函数就是启动了一个JVM进程，而main函数所处的线程就是该程序执行的一个主线程。
    而线程是一个轻量级的进程，进程可以从操作系统的角度去看，而线程则是程序的角度去看，一个进程至少有一个线程以上，每个线程都可共享当前进程所占的资源，因为线程之间共享当前进程所占有的资源，且线程是CPU调度和分配的基本单位，因此线程之间的切换调度比进程之间切换的开销小的多。

37. 守护线程是什么？
    守护线程daemon，顾名思义就是用来陪伴其它线程，即服务其它线程。

38. 创建线程有哪几种方式？
    有三种方式：
39. 继承Thread类
    通过继承Thread类，重写run（）方法，来实现线程的使用。
    创建Thread子类的实例，即创建了线程，调用线程对象的start（）方法来启动该线程。
40. 通过Runnable接口创建线程
    通过实现接口Runnable，重写run（）方法，来实现线程的创建，而这种创建方式能使得多个线程共用一个代码逻辑，而不像使用继承了Thread从而无法再继承其它类的问题。创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象是真正的线程对象。通过调用线程对象的start（）方法来启动该线程。
41. 通过Callable和Futrue创建线程
    创建实现Callable<>接口的类，并重写call（）方法，该call（）方法作为线程的执行体，并且有返回值。创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call（）方法的返回值。使用FutureTask对象作为Thread的target来创建Thread对象。通过调用FutureTask对象的get（）方法在，子线程完成后获取其返回值。

42. 说一下runnable 和 callable有什么区别？
    Runnable和Callable的主要区别在于Callable有返回值（Runnable返回的是void），且创建出来的实例需要Furture、FutureTask类来对其进行包装Callable对象，而后在作为Thread的对象来进行调用。而使用Callable接口的线程可以通过call（）方法来获取线程的返回值。

43. 线程有哪些状态
    running 运行
    blocking 阻塞
    waiting 等待
    time_waiting 超时等待（sleep（））
    new 准备
    terminated 结束
    超时等待（sleep（）方法）

* 创建：生成线程对象，但未调用start（）方法
* 就绪：调用start（）方法
* 运行：开始执行run函数中的代码
* 阻塞：线程正在运行，被暂停sleep、wait等方法
* 死亡：run方法执行结束或者调用stop方法

41. sleep（）和wait（）有什么区别？
    sleep（）是Thread类的静态本地方法，它的作用是使得当前线程进行休眠进入阻塞状态，当相应的时间过去，当前线程会被唤醒，并与其他线程一同开始对CPU资源进行竞争。而如果sleep出现的区域位于被synchronized修饰的代码块中，该线程不会释放掉自己的资源。

wait（）方法是Object类的方法，当当前线程使用wait（）方法的时候，会使得当前线程进入等待对象池，同时释放该对象的锁，使得其他线程能够获取到该线程所占有的资源，通过notify（）和notifyAll（）来进行唤醒。

42. notify（）和notifyAll（）有什么区别？
    执行了wait（）方法的线程会进入到该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
    notify（）方法会随机激活一个处于等待池中的wait线程，而notifyAll（）则会激活所有wait线程，被唤醒的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象的锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll（）会将该对象等待池内存所有线程移动到锁池中，等待锁竞争。
    优先级高的线程竞争到对象锁的概率大，假若某线程没竞争到该对象的锁，它还会留在锁池中，唯有线程下次调用wait（）方法，它才会重新回到等待池中，而竞争到对象锁的线程则会继续往下执行，直到执行完了synchronized代码块，则会释放掉该对象锁，这时锁池中的线程会继续竞争该对象的锁。

43. 线程的run（）和start（）有什么区别？
    每个线程都是通过特定Thread对象所对应的方法run（）来完成其操作的，方法run（）称为线程体。通过调用Thread类的start（）方法启动一个线程。
    start（）方法启动一个线程，真正实现了多线程运行。这是无需等待run（）方法执行完毕，可以直接继续执行下面的代码。这时此线程是处于就绪状态，并没有运行。此Thread类调用方法run（）来完成其运行状态，这里的方法run（）称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程终止。然后CPU调用其它线程。
    run（）方法是在本线程里，只是线程里的一个函数，而不是多线程。如果直接调用run（），其实就相当于调用了一个普通函数而已，直接待用run（）方法必须等待run（）方法执行完毕才能执行下面的代码，所以执行路径还有只有一条，根本就没有线程的特征，所以多线程执行时要使用start（）方法而不是run（）方法。

44. 创建线程池的几种方式？

* newFiexedThreadPool 
  * 创建定长线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，线程数量将不会变化，当一个线程出现问题的时候，线程池会补充一个新的线程
* newCachedThreadPool
  * 创建可缓存的线程池，如果线程池的容量超过任务数，自动回收空闲线程，任务增加时可以自动添加新线程，线程池的容量不限制
* newScheduledThreadPool
  * 创建一个固定长度的线程池，可以进行延迟和定时的方式来执行线程
* newSingleThreadPool
  * 创建一个单线程的线程池，如果这个线程异常结束，会创建新的线程来代替它，其特点可以保持串行化的执行

45. 线程池都有哪些状态？
    线程池有5种状态：Running、Shutdown、Stop、Tidying、Terminated
    ￼![截屏2020-11-18 下午3.38.58](面试题-多线程/截屏2020-11-18 下午3.38.58.png)

46. 线程池中的submit（）和execute（）方法有什么区别？

* 接收的参数不一样
* submit有返回值，而execute没有
* submit方便Exception处理

47. 在Java程序中怎么保证多线程的运行安全？
    主要体现在三个方面：

* 原子性Atomic：提供互斥访问，同一时刻，只能有一个线程对临界资源访问
* 可见性：对内存修改的可见性原则
* 有序性：happe-before原则

48. 多线程锁的升级原理是什么？
    锁共有四个状态：无状态锁、偏向锁、轻量级锁和重锁级锁状态
    这几个状态随着竞争升级，锁可以升级但不能降级。
    ￼![截屏2020-11-18 下午3.38.21](面试题-多线程/截屏2020-11-18 下午3.38.21.png)

49. 什么是死锁？
    死锁指两个或两个以上的进程在执行过程中，由于竞争资源或由于彼此通信而造成的一种阻塞现象。


50. 怎么防止死锁的产生？
    产生死锁的四个条件：

* 互斥条件
* 请求和持有条件
* 不可剥夺条件
* 循环等待条件
  由于死锁的产生建立在这四个条件之上，所以破坏死锁就是破坏以上四个条件。
  由于我们使用锁就是为了让他们互斥（临界资源需要互斥访问），所以无法破坏。
  破坏请求和持有条件：一次性申请所有资源
  破坏不可剥夺条件：占用部分资源的线程进一步申请其它资源的时候，如果申请不到，可以主动释放它所占有的资源。
  破坏循环等待条件，按某一顺序申请资源，释放资源则反序释放

51. ThreadLocal 是什么？有哪些使用场景？
    ThreadLocal是线程的局部变量，属于线程自身拥有的，不在线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种线程安全的实现方式。
    我们创建的变量是可以被任何一个线程访问并修改的，而ThreadLocal使得每个线程拥有自己的变量从而避免了线程之间的争抢。
    ThreadLocal底层维护这一个类似Map的数据结构，key为当前对象的Thread对象，值为Object对象，由于value为ThreadLocal强引用，而key为弱引用，在垃圾回收的时候key被回收了，而value永远不会被gc回收掉，因此若不在使用完处理（赋null等）则会容易造成内存泄漏。

52. 说一下synchronized底层实现原理？
    synchronized 关键字加到 static 静态⽅法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例⽅法上是给对象实例上锁。尽量不要使⽤ synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！
    synchronized的字节码指令为 monitorenter 和 monitorexit，其中monitorenter 指令指向同步代码块的开始，monitorexit指向同步代码块的结束位置。当线程试图获取锁也就是获取monitor（monitor对象存在于每个对象的头中，synchronized便是通过这种方式获取锁，即为什么Java中任意对象都可以作为锁的原因）的持有权。当计数器为0时，表示锁被释放，如果获取对象锁失败，那么当前线程就要阻塞等待，直到锁被另一个线程释放为止。

53. synchronized 和 volatile 的区别是什么？
    从使用方式来说：
    synchronized 可以修饰 代码块、实例、类，而volatile只能修饰变量
    volatile可以看做是一种轻量型的synchronized，用于解决内存可见性问题，同时可以防止指令的重排列。
    volatile的本质是告诉JVM当前变量在工作内存（寄存器）中的值不确定，需要从主存中读取，当一个线程对volatile变量进行修改的时候，会造成其余线程中该缓存的值失效。而synchronized则是锁定当期变量，只有当前线程可以访问该变量，其它被线程阻塞。
    volatile能实现内存的可见性问题，但不能保证原子性，而synchronized则可以保证变量的修改可见性和原子性。volatile不会造成线程阻塞，synchronized可能会造成线程阻塞。volatile能保证指令不会被重排序即插入内存屏障Memory Barrier（编译器对于指令会进行优化对指令的执行顺序会进行重排序，但保证as-if-serial语义）

54. synchronized 和 Lock的区别？
    synchronized是JVM自带的一种同步方式，而Lock是一种API接口，在JDK5的时候提出，提供了锁的更多更方便的功能。主要可以对锁进行显示的指定和移除，而synchronized只支持隐式指定，还有一些对锁的中断、锁的定时等synchronized不具备的功能。

* synchronized是Java内置关键字，而Lock是个类
* synchronized会自动释放锁，而Lock需要显式的对锁进行释放，否则容易造成线程死锁。
* 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
* synchronized 可重入、非公平、不可中断；Lock 可重入、可决定公平、可中断
* Lock适合大量同步代码问题，synchronized适合少量的同步问题

55. synchronized 和 ReentrantLock区别是什么？
    synchronized是一个关键字，ReentrantLock是一个类，这是一个本质的区别，因为ReentrantLock是一个类实现了Lock接口，可以实现更多的功能。
    ReentrantLock可以对获取锁的等待时间进行设置，避免了死锁（循环等待条件）
    ReentrantLock可以获取锁的信息，可以灵活的实现多路通知。
    其锁的机制也不同，synchronized靠判断对象头中mark work来判断。而ReentrantLock底层调用的是Unsafe的park方法加锁。

56. 说一下Atomic的原理？
    Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。
    Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。
