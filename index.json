[{"categories":["Linux"],"content":"Linux基本指令 yum yum repolist all 列出所有仓库 yum list all 列出仓库所有软件包 yum clean all 清除所有仓库缓存 yum gourplist systemctl初始化进程 管理服务的启动、重启、停止、重载、查看状态 start\\ restart\\ stop\\ reload status 设置服务的开机启动、不启动、查看各级别下服务启动状态等 enable\\ disable\\ is-enable\\ list-unitfiles –type=service shell LVM (Logical Volume Manager)逻辑卷管理工具 图形化 shell充当人与内核之间的翻译 许多主流Linux系统默认的终端是Bash（Bourne-Again Shell）解释器 查看帮助man 常用指令 echo 终端上输入字符串或变量提取后的值 date 显示系统时间 按照”年-月-日 时：分：秒“的格式查看 [root@VM-0-15-centos ~]# date “+%Y-%m-%d %H:%M:%S” 2020-11-23 19:02:48 date “+%j” 查看今天是当年的第几天 reboot用于重启系统 poweroff用于关机 wget 用于终端中下载网络文件 -r 递归下载 -p 指定目录 ps 查看系统中进程状态 ps -aux -a 显示所有进程 -u 用户及其他详细信息 -x 显示没有控制的终端进程 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 进程所有者 进程id号 虚拟内存占用（KB） 占用的固定内存量（KB） 所在终端 进程状态 被启动的时间 实际使用CPU的时间 命令名称与参数 Linux的五种常见进程状态 R（运行） S（中断）进程处于休眠中，若某个条件形成后或者接收到信号时，则脱离该状态 D（不可中断）进程不响应系统异步信号，即便使用kill命令也无法将其中断 Z（僵死）进程已经终止，但进程描述符依然存在，直到父进程调用wait4（）系统函数将进程释放 T（停止）进程收到停止信号后停止运行 top 用于动态监视进程活动与系统负载信息等 第一行：系统时间、运行时间、登录终端数、系统负载（1分钟、5分钟、15分钟的平均值，越小说明负载越低） 第二行：进程总数、。。。 第三行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源白百分比等 第四行：物理内存总量、空闲内存量、内存使用量、作为内核缓存的内存量 第五行：虚拟内存总量、虚拟内存空闲量、虚拟内存使用量、已被提前加载的内存量 pidof 用于查询某个指定服务进程的PID值，pidof [参数] [服务名称] kill 终止指定PID服务 kill [参数] [服务名称] killall 终止某个指定名称的服务对应的全部进程 killall [参数] [服务名称] 系统状态检测 ifconfig 获取网卡配置与网络状态信息 uname 用于查看系统内核与系统版本信息 uname [-a] 系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型、以及操作系统名称等信息 uptime 查看系统的负载信息，uptime 它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息 free 查看系统当前内存的使用信息 free -h 更人性化显示（显示单位） who 查看当前登入主机的用户终端信息 last 查看系统所有的登录信息，以日志文件保存（无法判断黑客是否进入） 查看本机的登录记录。 history 用于显示历史执行过的命令（可以显示1000条，可在/etc/profile文件HISTSIZE变量中修改） -c 清空所有命令历史记录 历史命令会保存在.bash_history文件中 sosreport 用于收集系统配置及架构信息并输出诊断文档，格式为sosreport 系统出现故障的时候一般第一时间进行诊断收集的命令 红线部分为收集好的资料压缩以及校验码 工作目录切换命令 pwd 用于显示用户当前所处的工作目录 cd 切换工作路径 ls 显示目录中的文件信息 -a 显示全部（包括隐藏） -l 查看文件属性、大小等详细信息 文本文件编辑命令 cat 查看纯文本内容（内容少） -h 查看文本顺便显示行号 more 查看纯文本文件（内容多） 空格/回车向下翻页 head 查看纯文本的前N行 前20行 tail 与head相反从后往前，后N行(最厉害的地方在于可持续刷新一个文件的内容，可以实时查看最新的日志文件） 若想看到最新的日志文件，tail -f tr 替换文本中的字符 tr [原始字符] [目标字符] 进行文本的大量替换可以进行使用 使用cat 读取待处理的文本，通过管道符把这些文本内容传递给tr命令进行替换 例如替换某个文件的大小写 cat xxx.txt | tr [a-z] [A-Z] wc 用于统计文本的行数、字数、字节数 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 stat 用于查看文件的具体存储信息和时间等信息 cut 用于按”列“提取文本字符 例如尝试提取出passwd文件中用户名信息 -f 设置需要看的列数 -d 设置间隔符号 diff 用于比较多个文本之间的差异 —breif 用于确认两个文件是否不同 -c 描述文件具体的不同 文件目录管理命令 touch 用于创建空白文件或设置文件的时间 -a 仅修改“读取时间”（atime） -m 仅修改“修改时间”（mtime） -d 同时进行修改 黑客可用来将修改过的时间修改回去 mkdir 创建一个空白目录 -p 创建一个层次目录 mkdir -p a/b/c cp 复制文件或目录 -p 保留原始文件属性 -d 若对象为“链接文件”，则保留该文件属性 -r 递归复制（用于目录） -i 若目标文件存在询问是否覆盖 -a 相当于-pdr结合 mv 用于剪贴文件或文件重命名 若同一目录中对一文件进行mv操作，其实也就是进行重命名 rm 删除文件或目录 rm -rf -r 递归 -f 强制 dd 按照指定的大小和个数的数据块来复制文件或转换文件 if 输入的文件名称 of 输出的文件名称 bs 设置每个“块”的大小 count 设置要复制的“块”的个数 dd可以压制出光盘文件，将它变成一个可立即使用的iso镜像 file 查看文件类型，因为目录、文本、设备等等统称文件，但无法凭后缀就知道其文件类型 打包压缩与搜索 tar c创建压缩文件 x解开压缩文件 t查看压缩包有哪些文件 z使用Gzip格式压缩或解压 j使用bzip2格式压缩或解压 v显示压缩或解压过程 f目标文件名 p保留原始文件的权限与属性 P使用绝对路径 C指定解压到的目录 常用 -czvf打包压缩（f很重要尽量放在最后一位，代表要压缩或解压的软件包名称） -xzvf解压(.tar.gz文件） grep 用于文本中执行关键词搜索 -b 将可执行文件（binary）当做文本文件（text）来搜索 -c 仅显示要找的行数 -i 忽略大小写 -n 显示行号 -v 反选 /etc/passwd文件保存着所有用户的信息，而一旦用户的登录终端被设置成/sbin/nologin则不再被允许的登录 find 按照指定条件查找文件 -exec 这个参数把find搜索到结果紧随其后的命令做进一步处理 ","date":"2020-11-26 18:22:27","objectID":"/2020/11/linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/:0:0","tags":["Linux"],"title":"Linux基本指令","uri":"/2020/11/linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"},{"categories":["面试"],"content":"面试题-JavaWeb和网络 ","date":"2020-11-20 20:50:52","objectID":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-javaweb%E5%92%8C%E7%BD%91%E7%BB%9C/:0:0","tags":["面试"],"title":"面试题-JavaWeb和网络","uri":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-javaweb%E5%92%8C%E7%BD%91%E7%BB%9C/"},{"categories":["面试"],"content":"Java Web Jsp 和 Servlet 有什么区别？ JSP的本质是Servlet，JVM只能识别Java类，不能识别jsp的代码，Web容器将jsp代码编译成JVM能够识别的类。 Jsp更擅长 页面表现，而Servlet更擅长逻辑控制。 Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HTTPServletResponse对象以及HttpServlet对象得到。 Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何嵌入到一个类中，由Jsp容器完成，而Servlet则是个完成的Java类，这个类的Service方法用于生成对客户端的响应。 Jsp 有哪些内置对象？作用分别是什么？ JSP有9个内置对象： response：封装服务端对客户端的响应 request：封装客户端的请求 pageContext：通过该对象可以获取其它对象 session：封装用户会话对象 application：封装服务器运行环境的对象 out：输出服务器响应的输出流独享 config：web应用的配置对象 page：JSP页面本身 exception：封装页面抛出异常的对象 说一下Jsp的4种作用域？ JSP中的四种作用域包括page、request、session和application，具体来说： page代表与一个页面相关的对象和属性。 request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。 session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。 application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。 session 和 cookie的区别？ 由于http是无状态协议，所以需要一种机制来对用户的身份状态进行保存。 session 和 cookie 都是用来跟踪浏览器用户身份的会话方式。 session 存在于服务端，而cookie存在于客户端。 cookie一般用于保存用户信息，例如在某些登录的时候，浏览器自动将你的账号进行填写，相当于给了用户一点甜头，这也是cookie的名称由来。同时是在进行会话的时候，若是使用Token进行安全的验证时候，Token存在于cookie中，访问网站的某一个资源的时候，只需要根据Token值来查找用户即可。登录一次网站后访问网站其它页面的时候就无需进行登录了。 session的主要作用是通过服务端记录用户的状态，同时进行用户的认证和权限访问。 说一下session的工作原理？ session在服务端的存储结构类似于key-value键值对，里面存储的事sessionId ，用户向服务发送请求的时候会带上这个sessionId，这是服务端拿着客户端发送过来的sessionId进行校对，实现安全认证。由于sessionId存储于cookie中，所以客户端在使用sessionId用于认证的时候会出现CSRF（Cross-site request forgery）的危险。 如果客户端禁用了cookie能实现session吗？ 失去了cookie相当于失去了sessionId，服务端无法进行身份的校验 但可以通过以下几种方式来使用session 将sessionId通过url，隐藏表单传递sessionId 用文件、数据库、缓存等显示保存sessionId，在跨页过程中手动调用 SpringMVC 和 Struts的区别？ 拦截机制的不同 Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。 SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。 Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。 底层框架的不同 Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。 性能方面 Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。 配置方面　spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。 如何避免sql注入？ 使用PreparedStatement 使用正则表达式过滤传入的参数 字符串过滤 服务层进行判断 orm层注意#{}和${}的使用区别 什么是XSS攻击，如何避免？ XSS攻击又称CSS,全称Cross Site Script （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。 XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。 什么是 CSRF 攻击，如何避免？ CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫跨站请求伪造。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。 如何避免： 验证HTTP Refer字段 HTTP Refer字段记录了该HTTP请求的来源地址。 使用验证码 在请求地址中添加token验证 在HTTP头中自定义属性并验证 将TOKEN以参数的形式置于HTTP请求中。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 ","date":"2020-11-20 20:50:52","objectID":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-javaweb%E5%92%8C%E7%BD%91%E7%BB%9C/:1:0","tags":["面试"],"title":"面试题-JavaWeb和网络","uri":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-javaweb%E5%92%8C%E7%BD%91%E7%BB%9C/"},{"categories":["面试"],"content":"网络 http 响应码 301 和 302 代表的是什么？有什么区别？ 301 redirect：代表永久性重定向（Permanently Moved） 302 redirect：代表暂时性转移（Temporaily Moved） forward 和 redirect 区别？ 直接转发（forward）： 客户端和浏览器只发出一次请求，Servlet、HTML、JSP等其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源时共享的。 重定向（redirect）： 实际是两次HTTP请求，服务器在响应第一次的时候，让浏览器再向另一个URL发出请求，从而达到转发的目的。 简述TCP和UDP TCP是面向连接的（即发送数据前，需要先建立连接，数据传输结束后需要释放连接），TCP是无连接的（无需建立连接即可发送数据） TCP是字节流传输，UDP是以数据报文段方式 TCP头部有20-60字节，UDP头部为8字节 TCP提供可靠的服务，UDP尽最大努力进行交付 TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制 UDP每个数据包都是独立的，没有固定顺序 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。 TCP为什么要三次握手，两次不行吗，为什么？ 通过三次握手，TCP能确定双方互相的发送数据能力、接收数据能力正常，两次无法保证能进行全部确定。 为了实现数据的可靠传输，TCP协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包，哪些是被对方收到的，三次握手的过程即使通信双方相互告知序列的起始值，并确认对象已经收到序列号起始值的必经步骤。 如果只是两次握手，至多只有连接发起方的起始序列号能喂确认，另一方得不到确认。 说一下TCP粘包是怎么产生的？ OSI的七层模型 应用层：网路服务与用户的最终一个借口 表示层：数据的表示、安全、压缩 会话层：建立、管理、终止会话 传输层：定义传输数据的协议端口号，以及流量控制和差错校验 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择 数据链路层：建立逻辑连接，进行硬件地址寻址、差错校验等功能 物理层：建立、维护、断开物理连接 GET和 POST请求 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 如何实现跨域 方式一：图片ping或script标签跨域 图片ping常用于跟踪用户点击页面或动态广告曝光次数。 script标签可以得到从其他来源数据，这也是JSONP依赖的根据。 方式二：JSONP跨域 JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有，通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。 方式三：CORS Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种： Access-Control-Allow-Origin: * Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400 跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数： “Access-Control-Allow-Credentials”: true // Ajax设置 “withCredentials”: true 方式四：window.name+iframe window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。 iframe标签的跨域能力； window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。 每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。 方式五：window.postMessage() HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。 方式六：修改document.domain跨子域 前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域 在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” 但不能设置为 “xxx.org” 或者”com”。 现在存在两个域名aaa.xxx.com和bbb.xxx.com。在aaa下嵌入bbb的页面，由于其document.name不一致，无法在aaa下操作bbb的js。可以在aaa和bbb下通过js将document.name = ‘xxx.com’;设置一致，来达到互相访问的作用。 方式七：WebSocket WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。相关文章，请查看：WebSocket、WebSocket-SockJS 需要注意：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。 方式八：代理 同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题 DomainA客户端（浏览器） ==\u003e DomainA服务器 ==\u003e DomainB服务器 ==\u003e DomainA客户端（浏览器） 87. 说一下JSONP实现原理？ jsonp 即 json + padding，动态创建script标签，利用script标签的src可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返回json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 ","date":"2020-11-20 20:50:52","objectID":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-javaweb%E5%92%8C%E7%BD%91%E7%BB%9C/:2:0","tags":["面试"],"title":"面试题-JavaWeb和网络","uri":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-javaweb%E5%92%8C%E7%BD%91%E7%BB%9C/"},{"categories":["面试"],"content":"面试题-对象拷贝和异常 ","date":"2020-11-20 20:48:59","objectID":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%BC%82%E5%B8%B8/:0:0","tags":["面试"],"title":"面试题-对象拷贝和异常","uri":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["面试"],"content":"对象拷贝 为什么要使用克隆？ 想对一个对象进行处理，又想保留原有数据进行接下来操作，Java中克隆针对的是类的实例。 如何实现对象克隆？ 两种方式： 实现Cloneable接口并重写Object类中的clone方法 实现Serializable接口，通过对象的序列化和反序列化实现克隆 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。 深拷贝和浅拷贝的区别是什么？ 浅拷贝：对基本数据类型进行值传递，对引用数据进行引用传递拷贝。 深拷贝：对基本数据类型进行值传递，对引用类型创建一个新的对象，并将引用变量指向该对象的内存区域。 ","date":"2020-11-20 20:48:59","objectID":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%BC%82%E5%B8%B8/:1:0","tags":["面试"],"title":"面试题-对象拷贝和异常","uri":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["面试"],"content":"异常 throw 和 throws的区别？ throws 是用来声明一个方法可能抛出的所有异常信息，是将异常声明但不处理，而是将异常向上传递，谁能调用给谁处理。而throw 则是抛出一个具体的异常类型，可以自己创建。 final、finally、finalize 有什么区别？ final 可以修饰类（表示该类不可被继承）、变量（声明该类为一个常量）、方法（声明该方法不可被重写） finally 一般作用于try-catch代码块中，处理异常的时候，finally的代码块一定会被执行。 finalize 是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由gc收集器进行调用，当我们调用System.gc()方法的时候，由垃圾回收器调用finalize()，回收垃圾 try-catch-finally 中哪个部分可以省略? catch可以 try-catch-finally中，如果catch中return了，finally还会执行吗？ 会，会在retrun之前执行 常见的异常类有哪些？ NullPointException IndexOutOfArrayException ArithmeticException ClassCastException IllegalArgumentException IOException NoSuchMethod RuntimeException NumberFormatException ","date":"2020-11-20 20:48:59","objectID":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%BC%82%E5%B8%B8/:2:0","tags":["面试"],"title":"面试题-对象拷贝和异常","uri":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["面试"],"content":"反射 什么是反射？ 反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力 Java反射： 在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法 Java反射机制主要提供了以下功能 在运行时判断任意一个对象所属的类 在运行时判断任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法 什么是java序列化？什么情况下需要序列化？ 就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态在读出来。核心作用就是对象状态的保存与重建。 什么情况下需要序列化： a）当你想把内存中的对象状态保存到一个文件中或者数据库中的时候 b）当你想用套接字在网络中传输对象的时候 c）当你想通过RMI（Java Remote Method Invocation）传输对象的时候，即利用对象序列化运行远程主机上的服务，就像在本地机上运行对象一样。 动态代理是什么？有哪些应用？ 动态代理： 当想要实现某个接口类的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，顾名思义就创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，拓展性强。 动态代理的应用： Spring 的 AOP 加事务 加权限 加日志 怎么实现动态代理 首先必须定义一个接口，还要有一个InvocationHandler（将实现接口的类的对象传递给它）处理类。再有一个工具类Proxy（习惯称为代理类，调用它的newInstance（）可以产生代理对象，其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象最后返回。 ","date":"2020-11-20 09:28:28","objectID":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%8D%E5%B0%84/:0:0","tags":["面试"],"title":"面试题-反射","uri":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%8F%8D%E5%B0%84/"},{"categories":["面试"],"content":"JVM 说一下JVM的主要组成部分？及其作用？ 类加载器（ClassLoader） 运行时数据区（Runtime Data Area） 执行引擎（Execution Engine） 本地库接口（Native Interface） 类加载器将.java文件转化成字节码.class文件，运行时数据区将字节码加载到内存中，由于.class文件只是JVM的一套指令集，无法被CPU执行，因此需要执行引擎去将其翻译成CPU可执行的二进制文件，而这个过程需要调用其它语言的本地接口（Native Interface）实现。 说一下JVM运行时数据区 java应用程序在运行的时候，JVM会将内存区域进行划分，每个区域有着各自的用途和自己的创建时间。 分为了 方法区 虚拟机栈 堆 程序计数器 本地方法栈 有的区域随着虚拟机的进程启动而存在，有的区域依赖用户进程的启动和结束而创建和销毁。 方法区： JDK8之前为永久代的存放区，方法区这个称呼是对虚拟机规范而言，而永久代则是对JVM（Hotspot）而言方法区的一种实现，在JDK8之后为元空间。用于存放已被虚拟机加载的类信息、常量、静态常量，即使编译器编译后的代码等数据。永久带到元空间的升级，原本永久代有个JVM本身设置的固定内存大小上线，无法调整，而现在元空间没有了这些限制，可以动态的进行调整，由系统的实际空间进行控制，这样加载的类就更多了。 程序计数器： 是一个块小的内存空间，JVM线程独有的，用于标记字节码指令的行号，方便在线程切换的时候可以找到原来工作状态的位置，因此每个线程内都独有一个程序计数器，同时也保证程序的顺序读取，用于代码的流程控制。 JVM栈： 是JVM线程独有的一块区域，生命周期与线程相同，描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。 本地方法栈： 虚拟机栈为虚拟机执行Java方法（即字节码）服务，而本地方法栈则为虚拟机使用的到Native方法服务器。 堆： Java中几乎所有对象都在对堆中分配，但是，随着JIT编译期的发展和逃逸分析的技术成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变的不那么绝对，从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。 说一下堆栈的区别？ 几乎所有对象都在堆中分配，而栈一般为JVM栈，或是JVM栈中的局部变量表的部分，一般存储着一些局部量。 栈内存存储的是局部变量而堆内存存储的是实体 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体由gc机制不定时的回收。 队列和栈是什么？有什么区别？ 队列和栈都是用来存储数据的。 队列的结构特点是FIFO，先进先出，但也有特例Deque接口，运行从两端检索元素。 但栈为先进后出。 什么是双亲委派模型？ 对于任何一个类，都需要由它的类加载器和这个类本身一同确立在JVM中的唯一性，每一个类加载器，都有一个独立的类空间。类加载器就是根据全限定名称将class文件加载到JVM内存，然后再转换为class对象。 类加载器分类： 启动器类加载器（BootStrap ClassLoader）是虚拟机自身的一部分，用来加载Java_HOME/lib目录中的，或者是被-Xbootclasspath参数所指定的路径中并且被虚拟机识别的类库 拓展类加载器（Extension ClassLoader） 应用程序类加载器（Application ClassLoader）负责加载用户类路径classpath上的指定类库，我们可以直接使用这个类加载器。（默认） 双亲委派模型就是，一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。 说一下类加载的过程 加载：根据查找路径找到全限定类名的class文件导入 检查：检查加载的class文件的正确性 准备：正式为类中的变量（静态变量static）分配内存空间，并设置类变量初始值 解析：JVM将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个表示，而在直接引用直接指向内存地址 初始化：对静态变量和静态代码块执行初始化工作 怎么判断对象是否可以回收 两种方式： 引用计数器： 为每个对象创建一个计数器，当该对象被引用的时候+1，被释放的时候-1，当计数器为0的时候可以被进行回收，但出现循环引用的问题，到时无法进行回收。 可达性分析：从GC roots开始扫描，搜索走过的路径称为引用链。当一个对象到GC roots开始向下搜索，搜索走过的路径称为引用链，而对象到GC roots没有任何引用链相连的，将对其进行回收 Java中都有哪些引用类型？ 强引用：Object obj = new Object（）强引用是最普遍的，一个对象如果具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机会抛出OOME错误是程序终止也不会随意对其进行回收，G1gc垃圾收集器可能会进行标记整理 剩下三个引用都继承自Reference 软引用：SoftReferences 在内存不够的时候会对其进行回收 弱引用：弱引用对象生命周期很短，当GC扫描所在的区域一旦发现了只具有弱引用的对象，不管当前内存空间是否足够都会对其进行回收。 虚引用：Java中最弱的引用，它是如此脆弱以至于我们通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收。 说一下JVM有哪些垃圾回收算法 标记-复制 标记-清理 标记-整理 分代收集理论 说一下JVM有哪些垃圾回收器 Serial：最早的单线程串行垃圾回收器 Serial Old：Serial 的老版本，可作为CMS（Concurrent Mark Swap降低停顿时间）的备选 ParNew：Serial的多线程版本 Parallel 和 ParNew 收集器是多线程的，但Parallel是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。 Parallel Old：是Parallel老生代版本，Parallel使用的是标记-复制的内存回收算法，Parallel Old使用的是标记-整理的算法 CMS（Concurrent Mark Swap）：一种以获得最短停顿时间为目标的收集器，非常适合B/S系统 G1：一种兼顾吞吐量和停顿时间的GC实现，是JDK9以后的默认GC选项 详细介绍一下CMS垃圾回收器 CMS（Concurrent Mark Swap），是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM的参数上：-XX:+UseConcMarkSweepGC 来指定使用CMS垃圾回收器。 CMS使用的事标记-清理的算法实现的，所以在GC的时候会产生大量的内存碎片，当剩余内存不能满足程序运行的时候，系统会出现Concurrent Mode Failure，临时CMS会采用Serial Old回收器进行标记-整理对内存进行整理，但是停顿的时间就会更长了。 新生代垃圾回收器和老生代回收器都有哪些？有什么区别？ 新生代：Serial、ParNew、Parallel Scavenge 老生代：Serial Old、ParNew Old、CMS 整堆回收器：G1 新生代垃圾回收器一般采用的是标记-复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般是标记-整理。 简述垃圾分代回收器是怎么工作的？ 分代回收区有两个：老年代、新生代 新生代默认占总空间的1/3，老年代占2/3。 新生代中分eden、survivor区，两者占新生代空间的80%和10%，其中survivor中有from survivior 和 to survivor两个，用于进行标记-复制算法的清理。 执行步骤： 把Eden+from survivor存活的对象放入到to survivor中 清空Eden 和 From survivor分区 From Survivor 和 To Survivor 分区交换， From Survivor -\u003e \u003c-To Survivor 每次在From Survivor 到 To Survivor中移动存活对象的时候，年龄就+1，当达到15的时候（默认配置）会被升为老生代。大对象直接进入老生代。 老生代当空间占用达到某个值后就会触发全局垃圾回收，一般使用标记-整理算法。 说一下JVM调优工具？ JDK自带了很多监控工具，都位于JDK的bin目录下 jvisualvm：全能分析工具 jconsole：用于对JVM中的内存、线程和类进行监控 常用的JVM调优参数有哪些？ -Xms2g：初始堆大小为2g -Xmx2g：初始堆的最大大小为2g -XX：NewRatio=4：设置年轻和老年代的内存比例为1：4 -XX：SurvivorRatio=8：设置新生代Eden：Survivor的比例为8：2 -XX：+UseParNewGC：指定使用ParNew+Serial Old垃圾收集器 -XX：+UserParallelOldGC：指定使用Parallel Scavege+Parallel Old垃圾收集","date":"2020-11-18 15:42:09","objectID":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-jvm/:0:0","tags":["面试"],"title":"面试题-JVM","uri":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-jvm/"},{"categories":["面试"],"content":"三、多线程 并行和并发有什么区别？ 并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时刻间隔发生 并行是在不同的实体上的多个事件，而并发是同一实体上的多个事件 并发是在一台处理器上“同时”处理多个任务，在多台处理器上处理多个任务。 线程和进程的区别？ 进程是程序的一次执行，是程序资源分配和运行的基本单位。系统运行一个程序即是一个进程从创建运行到消亡的一次过程。例如在Java中，启动一个main函数就是启动了一个JVM进程，而main函数所处的线程就是该程序执行的一个主线程。 而线程是一个轻量级的进程，进程可以从操作系统的角度去看，而线程则是程序的角度去看，一个进程至少有一个线程以上，每个线程都可共享当前进程所占的资源，因为线程之间共享当前进程所占有的资源，且线程是CPU调度和分配的基本单位，因此线程之间的切换调度比进程之间切换的开销小的多。 守护线程是什么？ 守护线程daemon，顾名思义就是用来陪伴其它线程，即服务其它线程。 创建线程有哪几种方式？ 有三种方式： 继承Thread类 通过继承Thread类，重写run（）方法，来实现线程的使用。 创建Thread子类的实例，即创建了线程，调用线程对象的start（）方法来启动该线程。 通过Runnable接口创建线程 通过实现接口Runnable，重写run（）方法，来实现线程的创建，而这种创建方式能使得多个线程共用一个代码逻辑，而不像使用继承了Thread从而无法再继承其它类的问题。创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象是真正的线程对象。通过调用线程对象的start（）方法来启动该线程。 通过Callable和Futrue创建线程 创建实现Callable\u003c\u003e接口的类，并重写call（）方法，该call（）方法作为线程的执行体，并且有返回值。创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call（）方法的返回值。使用FutureTask对象作为Thread的target来创建Thread对象。通过调用FutureTask对象的get（）方法在，子线程完成后获取其返回值。 说一下runnable 和 callable有什么区别？ Runnable和Callable的主要区别在于Callable有返回值（Runnable返回的是void），且创建出来的实例需要Furture、FutureTask类来对其进行包装Callable对象，而后在作为Thread的对象来进行调用。而使用Callable接口的线程可以通过call（）方法来获取线程的返回值。 线程有哪些状态 running 运行 blocking 阻塞 waiting 等待 time_waiting 超时等待（sleep（）） new 准备 terminated 结束 超时等待（sleep（）方法） 创建：生成线程对象，但未调用start（）方法 就绪：调用start（）方法 运行：开始执行run函数中的代码 阻塞：线程正在运行，被暂停sleep、wait等方法 死亡：run方法执行结束或者调用stop方法 sleep（）和wait（）有什么区别？ sleep（）是Thread类的静态本地方法，它的作用是使得当前线程进行休眠进入阻塞状态，当相应的时间过去，当前线程会被唤醒，并与其他线程一同开始对CPU资源进行竞争。而如果sleep出现的区域位于被synchronized修饰的代码块中，该线程不会释放掉自己的资源。 wait（）方法是Object类的方法，当当前线程使用wait（）方法的时候，会使得当前线程进入等待对象池，同时释放该对象的锁，使得其他线程能够获取到该线程所占有的资源，通过notify（）和notifyAll（）来进行唤醒。 notify（）和notifyAll（）有什么区别？ 执行了wait（）方法的线程会进入到该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 notify（）方法会随机激活一个处于等待池中的wait线程，而notifyAll（）则会激活所有wait线程，被唤醒的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象的锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll（）会将该对象等待池内存所有线程移动到锁池中，等待锁竞争。 优先级高的线程竞争到对象锁的概率大，假若某线程没竞争到该对象的锁，它还会留在锁池中，唯有线程下次调用wait（）方法，它才会重新回到等待池中，而竞争到对象锁的线程则会继续往下执行，直到执行完了synchronized代码块，则会释放掉该对象锁，这时锁池中的线程会继续竞争该对象的锁。 线程的run（）和start（）有什么区别？ 每个线程都是通过特定Thread对象所对应的方法run（）来完成其操作的，方法run（）称为线程体。通过调用Thread类的start（）方法启动一个线程。 start（）方法启动一个线程，真正实现了多线程运行。这是无需等待run（）方法执行完毕，可以直接继续执行下面的代码。这时此线程是处于就绪状态，并没有运行。此Thread类调用方法run（）来完成其运行状态，这里的方法run（）称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程终止。然后CPU调用其它线程。 run（）方法是在本线程里，只是线程里的一个函数，而不是多线程。如果直接调用run（），其实就相当于调用了一个普通函数而已，直接待用run（）方法必须等待run（）方法执行完毕才能执行下面的代码，所以执行路径还有只有一条，根本就没有线程的特征，所以多线程执行时要使用start（）方法而不是run（）方法。 创建线程池的几种方式？ newFiexedThreadPool 创建定长线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，线程数量将不会变化，当一个线程出现问题的时候，线程池会补充一个新的线程 newCachedThreadPool 创建可缓存的线程池，如果线程池的容量超过任务数，自动回收空闲线程，任务增加时可以自动添加新线程，线程池的容量不限制 newScheduledThreadPool 创建一个固定长度的线程池，可以进行延迟和定时的方式来执行线程 newSingleThreadPool 创建一个单线程的线程池，如果这个线程异常结束，会创建新的线程来代替它，其特点可以保持串行化的执行 线程池都有哪些状态？ 线程池有5种状态：Running、Shutdown、Stop、Tidying、Terminated ￼![截屏2020-11-18 下午3.38.58](面试题-多线程/截屏2020-11-18 下午3.38.58.png) 线程池中的submit（）和execute（）方法有什么区别？ 接收的参数不一样 submit有返回值，而execute没有 submit方便Exception处理 在Java程序中怎么保证多线程的运行安全？ 主要体现在三个方面： 原子性Atomic：提供互斥访问，同一时刻，只能有一个线程对临界资源访问 可见性：对内存修改的可见性原则 有序性：happe-before原则 多线程锁的升级原理是什么？ 锁共有四个状态：无状态锁、偏向锁、轻量级锁和重锁级锁状态 这几个状态随着竞争升级，锁可以升级但不能降级。 ￼![截屏2020-11-18 下午3.38.21](面试题-多线程/截屏2020-11-18 下午3.38.21.png) 什么是死锁？ 死锁指两个或两个以上的进程在执行过程中，由于竞争资源或由于彼此通信而造成的一种阻塞现象。 怎么防止死锁的产生？ 产生死锁的四个条件： 互斥条件 请求和持有条件 不可剥夺条件 循环等待条件 由于死锁的产生建立在这四个条件之上，所以破坏死锁就是破坏以上四个条件。 由于我们使用锁就是为了让他们互斥（临界资源需要互斥访问），所以无法破坏。 破坏请求和持有条件：一次性申请所有资源 破坏不可剥夺条件：占用部分资源的线程进一步申请其它资源的时候，如果申请不到，可以主动释放它所占有的资源。 破坏循环等待条件，按某一顺序申请资源，释放资源则反序释放 ThreadLocal 是什么？有哪些使用场景？ ThreadLocal是线程的局部变量，属于线程自身拥有的，不在线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种线程安全的实现方式。 我们创建的变量是可以被任何一个线程访问并修改的，而ThreadLocal使得每个线程拥有自己的变量从而避免了线程之间的争抢。 ThreadLocal底层维护这一个类似Map的数据结构，key为当前对象的Thread对象，值为Object对象，由于value为ThreadLocal强引用，而key为弱引用，在垃圾回收的时候key被回收了，而value永远不会被gc回收掉，因此若不在使用完处理（赋null等）则会容易造成内存泄漏。 说一下synchronized底层实现原理？ synchronized 关键字加到 static 静态⽅法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例⽅法上是给对象实例上锁。尽量不要使⽤ synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！ synchronized的字节码指令为 monitorenter 和 ","date":"2020-11-18 15:36:44","objectID":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:0","tags":["面试"],"title":"面试题-多线程","uri":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["面试"],"content":"二、容器 Java的容器都有哪些？ Map：HashMap-\u003eLinkHashSet、ConcurrentMap-\u003eConcurrentHashMap、TreeMap Set：HashSet-\u003eLinkHashSet、TreeSet List：ArrayList、LinkedList、Vector-\u003eStack Queue：Priority Queue，LinkedList Collection 和 Collections 有什么区别？ java.util.Collection 是一个集合接口（集合类是一个顶级接口）。他提供了集合对象进行基本操作的通用接口方法。Collection接口在Java类中有很多的具体的实现。Collection的意义是为了给各种集合统一的操作方式，其直接继承接口有List与Set。 Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。 List、Set、Map之间的区别是什么？ List：存储一个组不唯一（可以由多个元素引用相同的对象），有序的对象。 Set：不允许重复的集合。不会有多个元素引用相同的对象。 Map：使用键值对存储。Map会维护Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，也可以是任何类型。 HashMap 和 HashTable 有什么区别？ HashMap去掉了HashTable的contains方法，但加上了containsValue（）方法和containsKey（）方法 HashTable是同步的，所有的方法都是经过synchronized修饰的，是线程安全的 HashMap允许空键值，而HashTable不允许 如何决定使用HashMap还是TreeMap？ 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。 然而如果需要对一个key集合进行遍历排序，TreeMap是更好地选择。基于你的Collection的大小，也许向HashMap中添加元素会更快，将map换成TreeMap会遍历更快 说一下HashMap的实现原理？ HashMap是基于hash表的Map接口非同步实现。 JDK7之前是使用数组+链表实现的，结合在一起就是链表散列。JDK8之后在解决哈希冲突时有了较大的变化，HashMap在链表长度大于8（默认为8）的时候会自动转换为红黑树，提升搜索效率。 说一下HashSet的实现原理？ HashSet底层就是使用HashMap实现的，HashSet的值存在HashMap的键上，值为PRESENT（就是一个Object对象） ArrayList 和 LinkedList 的区别 相同点： 都是非线程安全的，不保证同步。 ArrayList： 底层为Object[]数组，继承了RandomAccess接口，该接口什么都没有但表示ArrayList是一个支持随机访问的集合。在空间占用方面，Object[]有扩容的机制（每次扩大为当前容量的1.5倍）来保证有足够的空间进行插入，因此会空间浪费在这多余的空间上面。在元素添加和去除的上面（add和remove），ArrayList的采用的是System.arraycopy()和Arrays.copyOf()（实际上就是调用System.arraycopy())，来进行扩容，因此在需要大量元素操作的时候，对时间和空间效率的影响较大。 LinkedList： 底层使用的是双向链表（JDK7之前为循环双向链表，JDK7取消了循环），由于是链表，没有大小的限制，也无需进行扩容操作等，但不支持随机访问操作，需要遍历到需要的位置进行操作，但对于末尾和头部的插入时间复杂度不受影响，但对于指定位置ArrayList为O（n-i）而LinkedLIst为O（n），在空间的占用上，主要浪费在头尾节点指针上。 如何实现数组和List之间的转换？ a. 使用循环，将List中的元素添加到数组中去 List-\u003e数组：调用ArrayList中的toArray（）方法，但需要使用子类进行初始化，不可使用List接口进行初始化。 数组-\u003eList：调用Arrays的asList方法。 ArrayList和Vector的区别？ 从线程安全角度：Vector是线程安全的而ArrayList不是，Vector的每个方法都有synchronized进行修饰。 Vector由于有锁的修饰，因此在效率方面不如ArrayList，在不考虑线程安全的情况下应该避免使用Vector。 数组 和 ArrayList 有何区别？ 数组在进行时候的时候必须指定其大小，且没有ArrayList所自带的方法（add，remove，indexOf等等等），ArrayList的大小是动态的，数组可以容纳基本类型和对象，但ArrayList只能接受对象。 在Queue 中 poll（）和remove（）有什么区别？ Queue是一个接口，LinkedList继承了它，remove（）在元素为空进行使用会抛出异常，而poll（）则会返回空，这就是二者的区别。 哪些集合类是线程安全的？ Vector、ConcurrentHashMap、HashTable、Stack（在jdk6的时候推出Deque-\u003eDequestack = new ArrayDeque\u003c\u003e())、enum（static类型的属性会在类加载之后被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的） Iterator 是什么？ 迭代器是一种设计模式，是一个对象，可以轻松遍历并选择序列中的对象，而开发者无需了解该序列的底层数据结构。 Iterator如何使用？有什么特点？ Java中的Collection实现了Iterable接口，里面有个Iterator方法，在我们需要使用的时候，调用该集合的Iterator方法，即可初始化一个迭代器可以对集合进行迭代。 1、使用iterator（）返回一个iterator 2、使用next（）获取序列下一个元素 3、使用hashNext（）判断下一个元素是否存在 4、使用remove（）将迭代器新返回的元素删除 Iterator 和 ListIterator有什么区别？ Iterator可以用来遍历Set和List集合，但是ListIterator只能用来遍历List Iterator对集合只可前向遍历，而ListIterator即可前也可后向 ListIterator实现了Iterator接口，并拓展了其它功能 ","date":"2020-11-18 15:36:03","objectID":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AE%B9%E5%99%A8/:0:0","tags":["面试"],"title":"面试题-容器","uri":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AE%B9%E5%99%A8/"},{"categories":["面试"],"content":"一、Java基础 JDK和JRE有什么区别？ JDK是Java Development Kit，包含了Java的运行环境还有运行java程序的指令等例如javac，javadoc等，是可以进行运行和开发的。提供了开发和运行环境。 而JRE是Java Runtime Environment，包含了Java的运行环境，仅仅只能运行Java的程序而无法进行开发等需求 \u0011 == 和 equals 的区别 都是用来对数据进行判断的，但在基本数据类型和引用数据类型上有所不同。 ==： 在判断引用类型时，判断的是两边的引用类型的内存地址是否为同一个内存地址。而在判断基本数据类型时，判断的是值是否相同（注意自动拆箱和自动装箱时，使用缓存池对象的情况） equals： 本质上与==相同，但对进行了重写，用于判断两个引用对象是否相等。有两种使用方式：一种是类覆盖率equals方法，一种是没有覆盖equals方法。 若没有类覆盖equals方法那么它与==的作用没有区别，但若进行类的重写，一般就判断是两个对象的内容是否相等。 两个对象的hashcode（）相同，则equals（）也一定为true吗？ 不对，两个对象的hashcode相等，equals也不一定相等。因为在散列表中，hashcode（）相等即两个键值对的hash值相等，并不能得出键值对相等。 hashcode（）的默认行为是对堆上的对象产生独特值，如果没有重写hashcode（）则该class的两个对象无论如何也不相等（即使这两个对象指向相同的数据），因此不仅进行重写，equals相等，那hashcode也不相等。 hashcode（）作用是获取hash码，hash码的作用是确定该对象在hash表中的索引位置。hashcode（）定义在JDK的Object.java中，因此每一个Java类都包含该方法。散列表中指的是：Java集合中本质的是散列表的类，如HashMap、Hashtable、HashSet。即hashCode（）在散列表中有用，其它情况无用。 final 在 Java中的作用 final是一个Java中的关键字，可以修饰在方法、类、字段上 方法：该方法不可被子类进行重写 类：该类不可被继承 字段：该字段被初始化后就不可被修改 Java中的Math.round(-1.5)等于多少？ 等于-1，round（）返回一个最接近参数值的整数，并舍入往无穷大方向 String属于基本数据类型吗？ 不属于，String是一个对象。基本的数据类型有byte、short、int、long、char、float、double、boolean Java中的操作字符串有哪些类？它们之间有什么区别？ 有String、StringBuffer、StringBuilder String的底层在JDK9以下是final char[] object，而JDK9开始是final char[] byte，而由于用了final进行修饰，因此在使用String操作字符串的时候，例如String a = a+ “1”会创建新的一个String常量，并将引用指针指向新的常量地址。 而StringBuffer和StringBuilder之间的区别在于线程安全的问题，StringBuffer的每个方法都经过了synchronized的修饰，是线程安全的，除此之外没有其余的差别。StringBuffer和StringBuilder都继承AbstractStringBuilder抽象类，而AbstractStringBuilder抽象类继承了Appendable的接口。在对字符串进行操作的时候都是在当前字符串上进行操作，而不是像String一样在堆内存中重新创建一个。因此如果需要进行大量的字符串操作的时候，应避免使用String类型。 String str = “i” 与 String str = new String(“i”)一样么？ 不一样，内存分配方式不一样。String str = “i”会将“i”分配到常量池中，而String str = new String（“i”）会将“i”分配到堆内存中。 如何将字符串反转 使用StringBuilder和StirngBuffer的reverse（）方法，它们该方法存在于AbstractStringBuidler类中。 将字符串转换成char数组，利用双指针进行数组反转。 10、String类的常用方法有哪些？ indexOf()：返回指定字符的索引。 charAt()：返回指定索引处的字符。 replace()：字符串替换。 trim()：去除字符串两端空白。 split()：分割字符串，返回一个分割后的字符串数组。 getBytes()：返回字符串的 byte 类型数组。 length()：返回字符串长度。 toLowerCase()：将字符串转成小写字母。 toUpperCase()：将字符串转成大写字符。 substring()：截取字符串。 equals()：字符串比较。 抽象类必须要有抽象方法吗？ 抽象类不一定要有抽象方法。 普通类和抽象类之间有什么区别？ 普通类不包含抽象方法，抽象类包含抽象方法 抽象类无法进行实例化操作 抽象类能使用final修饰吗？ 不能，抽象类本身的用途就是用来被继承的，如果使用会被编译器报错。 接口和抽象类有哪些区别？ 接口用implements进行实现，而抽象类用extends进行实现。 一个类可以有多个接口，但只能单继承 抽象类可以有构造函数，而接口不可以 接口中的方法默认使用public修饰，而抽象类中的方法可以使用任意访问修饰符 抽象类可以有main方法 Java 中的IO流分几种？ 按功能分：输入和输出 按类型分：字节流和字符流 字节流和字符流的区别，字节流是以8位bit为字节单位输入输出数据，字符流按字（看计算机一个字可以为多个字节）为单位输入输出。 BIO、NIO、AIO有什么区别？ BIO 阻塞型IO NIO 非阻塞型IO AIO 驱动型IO Files的常用方法都有哪些？ Files.exists()：检测文件路径是否存在 Files.createFiles()：创建文件夹 Files.delete()：删除一个文件或者目录 Files.copy()：复制文件 Files.move()：移动文件 Files.size()：查看文件个数 Files.read()：读取文件 Files.write()：写入文件 ","date":"2020-11-18 15:34:14","objectID":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-java%E5%9F%BA%E7%A1%80/:0:0","tags":["面试"],"title":"面试题-Java基础","uri":"/2020/11/%E9%9D%A2%E8%AF%95%E9%A2%98-java%E5%9F%BA%E7%A1%80/"},{"categories":["JUC"],"content":"Java并发编程三 ","date":"2020-11-18 13:58:14","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/:0:0","tags":["JUC"],"title":"Java并发编程三","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/"},{"categories":["JUC"],"content":"线程池的创建 ","date":"2020-11-18 13:58:14","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/:1:0","tags":["JUC"],"title":"Java并发编程三","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/"},{"categories":["JUC"],"content":"一、newFixedThreadPool 创建定长线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程数量不再变化，当线程发生错误结束时，线程池会补充一个新的线程。 package Advance.concurrent_programming.thread_pool; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * Description: * * @author:edgarding * @date:2020/11/18 **/ public class TestNewFixedThreadPool { public static void main(String[] args) throws InterruptedException { // 创建一个线程数目为3的newFixedThreadPool ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 0; i \u003c 6; i++) { final int index = i; fixedThreadPool.execute(() -\u003e{ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \" index : \" + index); }); } Thread.sleep(2000); System.out.println(\"after 2 seconds\"); // 关闭线程池后，已提交的任务仍然会执行完 fixedThreadPool.shutdown(); } } 执行结果： pool-1-thread-2 index : 1 pool-1-thread-1 index : 0 pool-1-thread-3 index : 2 after 2 seconds pool-1-thread-1 index : 4 pool-1-thread-3 index : 5 pool-1-thread-2 index : 3 ","date":"2020-11-18 13:58:14","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/:1:1","tags":["JUC"],"title":"Java并发编程三","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/"},{"categories":["JUC"],"content":"二、newCachedThreadPool 创建可缓存的线程池，如果线程池的容量超过了任务数，自动回收空闲线程，任务增加时可以自动添加新的线程，线程池的容量不限制。 package Advance.concurrent_programming.thread_pool; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * Description: * * @author:edgarding * @date:2020/11/18 **/ public class TestNewCachedThreadPool { public static void main(String[] args) throws InterruptedException { //创建可缓存的线程池，如果线程池的容量超过了任务数， //自动回收空闲线程，任务增加时可以自动添加新线程，线程池的容量不限制 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i \u003c 6; i++) { final int index = i; cachedThreadPool.execute(() -\u003e { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \" index : \" + index); }); } Thread.sleep(2000); System.out.println(\"after 2 seconds\"); cachedThreadPool.shutdown(); } } 运行结果： pool-1-thread-1 index : 0 pool-1-thread-3 index : 2 pool-1-thread-5 index : 4 pool-1-thread-2 index : 1 pool-1-thread-4 index : 3 pool-1-thread-6 index : 5 after 2 seconds 可以发现创建的线程数目与任务数目相同。 ","date":"2020-11-18 13:58:14","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/:1:2","tags":["JUC"],"title":"Java并发编程三","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/"},{"categories":["JUC"],"content":"三、newScheduledThreadPool 创建定长线程池，可执行周期性的任务 package Advance.concurrent_programming.thread_pool; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; /** * Description: * * @author:edgarding * @date:2020/11/18 **/ public class TestNewScheduledThreadPool { public static void main(String[] args) throws InterruptedException { // 创建定长线程池，可执行周期性的任务 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(3); for (int i = 0; i \u003c 3; i++) { final int index = i; //scheduleWithFixedDelay 固定的延迟时间执行任务； // scheduleAtFixedRate 固定的频率执行任务 scheduledExecutorService.scheduleWithFixedDelay(() -\u003e { System.out.println(Thread.currentThread().getName() + \" index: \" + index); }, 0, 3, TimeUnit.SECONDS); } Thread.sleep(4000); System.out.println(\"after 4 second\"); scheduledExecutorService.shutdown(); } } 运行结果： pool-1-thread-1 index: 0 pool-1-thread-3 index: 2 pool-1-thread-2 index: 1 pool-1-thread-1 index: 0 pool-1-thread-3 index: 2 pool-1-thread-2 index: 1 after 4 second ","date":"2020-11-18 13:58:14","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/:1:3","tags":["JUC"],"title":"Java并发编程三","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/"},{"categories":["JUC"],"content":"四、newSingleThreadExecutor 创建单线程的线程池，线程异常结束，会创建一个新的线程，能确保任务按提交顺序执行。能确保任务在队列按照串行来执行。 package Advance.concurrent_programming.thread_pool; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * Description: * 测试单线程的线程池 * @author:edgarding * @date:2020/11/18 **/ public class TestNewSingleThreadExecutor { public static void main(String[] args) { //单线程的线程池，线程异常结束，会创建一个新的线程，能确保任务按提交顺序执行 ExecutorService singleThreadPool = Executors.newSingleThreadExecutor(); //提交 3 个任务 for (int i = 0; i \u003c3; i++) { final int index = i; singleThreadPool.execute(() -\u003e { //执行第二个任务时，报错，测试线程池会创建新的线程执行任务三 if (index == 1) { throw new RuntimeException(\"线程执行出现异常\"); } try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \" index:\" + index); }); } try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"4秒后...\"); singleThreadPool.shutdown(); } } 运行结果： pool-1-thread-1 index:0 Exception in thread \"pool-1-thread-1\" java.lang.RuntimeException: 线程执行出现异常 at Advance.concurrent_programming.thread_pool.TestNewSingleThreadExecutor.lambda$main$0(TestNewSingleThreadExecutor.java:25) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) 4秒后... pool-1-thread-2 index:2 ","date":"2020-11-18 13:58:14","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/:1:4","tags":["JUC"],"title":"Java并发编程三","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89/"},{"categories":["基础"],"content":"Effective Java ","date":"2020-11-17 23:16:03","objectID":"/2020/11/effectivejava/:0:0","tags":["Effective Java"],"title":"EffectiveJava","uri":"/2020/11/effectivejava/"},{"categories":["基础"],"content":"对于所有对象都通用的方法 ","date":"2020-11-17 23:16:03","objectID":"/2020/11/effectivejava/:1:0","tags":["Effective Java"],"title":"EffectiveJava","uri":"/2020/11/effectivejava/"},{"categories":["基础"],"content":"覆盖equals时遵循的约定 满足条件： 类的每个实例本质上都是相同的 类没有必要提供逻辑相等的测试功能：例java.util.regx.Pattern 父类覆盖了equals方法，父类的行为对子类也是合适的 覆盖equals的约定 自发性（reflexive） 对称性（symmetric） 传递性（transitive） 一致性（consistent） 对于 x.equals(null) 必须返回false ","date":"2020-11-17 23:16:03","objectID":"/2020/11/effectivejava/:1:1","tags":["Effective Java"],"title":"EffectiveJava","uri":"/2020/11/effectivejava/"},{"categories":["Spring"],"content":"SpringCloud ","date":"2020-11-17 19:46:44","objectID":"/2020/11/springcloud/:0:0","tags":["SpringCloud"],"title":"SpringCloud","uri":"/2020/11/springcloud/"},{"categories":["Spring"],"content":"简述 Spring Cloud 是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统的基础设施开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。 ","date":"2020-11-17 19:46:44","objectID":"/2020/11/springcloud/:1:0","tags":["SpringCloud"],"title":"SpringCloud","uri":"/2020/11/springcloud/"},{"categories":["Spring"],"content":"Spring Cloud Netflix 这可是个大boss，地位仅次于老大，老大各项服务依赖与它，与各种Netflix OSS组件集成，组成微服务的核心，它的小弟主要有Eureka, Hystrix, Zuul, Archaius… 太多了 Netflix Eureka 服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。这个可是springcloud最牛鼻的小弟，服务中心，任何小弟需要其它小弟支持什么都需要从这里来拿，同样的你有什么独门武功的都赶紧过报道，方便以后其它小弟来调用；它的好处是你不需要直接找各种什么小弟支持，只需要到服务中心来领取，也不需要知道提供支持的其它小弟在哪里，还是几个小弟来支持的，反正拿来用就行，服务中心来保证稳定性和质量。 Netflix Hystrix 熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。比如突然某个小弟生病了，但是你还需要它的支持，然后调用之后它半天没有响应，你却不知道，一直在等等这个响应；有可能别的小弟也正在调用你的武功绝技，那么当请求多之后，就会发生严重的阻塞影响老大的整体计划。这个时候Hystrix就派上用场了，当Hystrix发现某个小弟不在状态不稳定立马马上让它下线，让其它小弟来顶上来，或者给你说不用等了这个小弟今天肯定不行，该干嘛赶紧干嘛去别在这排队了。 Netflix Zuul Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。当其它门派来找大哥办事的时候一定要先经过zuul,看下有没有带刀子什么的给拦截回去，或者是需要找那个小弟的直接给带过去。 Netflix Archaius 配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。可以实现动态获取配置， 原理是每隔60s（默认，可配置）从配置源读取一次内容，这样修改了配置文件后不需要重启服务就可以使修改后的内容生效，前提使用archaius的API来读取。 ","date":"2020-11-17 19:46:44","objectID":"/2020/11/springcloud/:1:1","tags":["SpringCloud"],"title":"SpringCloud","uri":"/2020/11/springcloud/"},{"categories":["Spring"],"content":"Spring Cloud Config 俗称的配置中心，配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。就是以后大家武器、枪火什么的东西都集中放到一起，别随便自己带，方便以后统一管理、升级装备。 ","date":"2020-11-17 19:46:44","objectID":"/2020/11/springcloud/:1:2","tags":["SpringCloud"],"title":"SpringCloud","uri":"/2020/11/springcloud/"},{"categories":["Spring"],"content":"Spring Cloud Bus 事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。相当于水浒传中日行八百里的神行太保戴宗，确保各个小弟之间消息保持畅通。 ","date":"2020-11-17 19:46:44","objectID":"/2020/11/springcloud/:1:3","tags":["SpringCloud"],"title":"SpringCloud","uri":"/2020/11/springcloud/"},{"categories":["Spring"],"content":"Spring Cloud for Cloud Foundry Cloud Foundry是VMware推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题 其实就是与CloudFoundry进行集成的一套解决方案，抱了Cloud Foundry的大腿。 ","date":"2020-11-17 19:46:44","objectID":"/2020/11/springcloud/:1:4","tags":["SpringCloud"],"title":"SpringCloud","uri":"/2020/11/springcloud/"},{"categories":["Spring"],"content":"Spring Cloud Cluster Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现。 如果把不同的帮派组织成统一的整体，Spring Cloud Cluster已经帮你提供了很多方便组织成统一的工具。 ","date":"2020-11-17 19:46:44","objectID":"/2020/11/springcloud/:1:5","tags":["SpringCloud"],"title":"SpringCloud","uri":"/2020/11/springcloud/"},{"categories":["Spring"],"content":"Spring Cloud Consul Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对. Spring Cloud Consul 封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。 ","date":"2020-11-17 19:46:44","objectID":"/2020/11/springcloud/:1:6","tags":["SpringCloud"],"title":"SpringCloud","uri":"/2020/11/springcloud/"},{"categories":["Spring"],"content":"微服务思考 单体易用，但越来越大的时候，越出现越来越多的问题，这时候，微服务的出现就是为了解决如此，通过将应用程序分解成独立可开发和部署的小规模，微型应用的一种方式。微服务能让事情变得更简单。但微服务架构是一种分布式架构，有着网络延迟、过多的远程调用等缺点会降低应用速度。 ","date":"2020-11-17 19:46:44","objectID":"/2020/11/springcloud/:2:0","tags":["SpringCloud"],"title":"SpringCloud","uri":"/2020/11/springcloud/"},{"categories":["Spring"],"content":"SpringCloud的创建 ","date":"2020-11-17 19:46:44","objectID":"/2020/11/springcloud/:3:0","tags":["SpringCloud"],"title":"SpringCloud","uri":"/2020/11/springcloud/"},{"categories":["JUC"],"content":"Java并发容器和框架 ","date":"2020-11-16 21:09:45","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/:0:0","tags":["JUC"],"title":"Java并发容器和框架","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"},{"categories":["JUC"],"content":"ConcurrentHashMap 的实现原理与使用 ConcurrentHashMap是线程安全且高效的HashMap。 在并发编程中使用HashMap可能操作程序死循环，而使用线程安全的HashTable效率又十分低下，因此ConcurrentHashMap诞生。 HashMap在并发情况下，执行put操作会引起死循环，是因为多线程会导致HashMap的Empty链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永不为空，就会产生死循环，无法获取节点。 HashTable由于每个方法都是用了synchronized进行同步，因此在线程竞争激烈的情况下，会导致其它线程也访问HashTable的同步方法时会被阻塞或轮询状态，从而也无法自己使用get或put操作，造成效率低下。 ConcurrentHashMap的分段锁技术 HashTable在容器竞争激烈的并发情况下表现的效率低，是因为多个线程竞争一把锁，假如容器内有多把锁，每一个把锁中有一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而有效提升并发效率，这就是分段锁。、 ","date":"2020-11-16 21:09:45","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/:1:0","tags":["JUC"],"title":"Java并发容器和框架","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"},{"categories":["JUC"],"content":"ConcurrentHashMap的结构 JDK7： ConcurrentHashMap是由segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁（ReentrantLock）在ConcurrentHashMap扮演锁的角色。HashEntry则用于存储键值对数据。 一个ConcurrentHashMap里包含一个Segment[]数组，Segment的结构与HashMap结构类似，是一种链表加数组的散列表，一个Segment里包含一个HashEntry[]数组，每个HashEntry是一个种链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，每个想对HashEntry[]数组进行修改的时候，都要获取当前HashEntry所在Segment的锁。 JDK8： ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全，数据结构和HashMap1.8的结构类似，数组+链表/红黑树。Java8在链表超过一定阈值（8）的时候，将链表（寻址时间复杂度O（n））转换为红黑树（O（log（n）） synchronized只锁定当前链表或红黑树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升了许多。 ","date":"2020-11-16 21:09:45","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/:1:1","tags":["JUC"],"title":"Java并发容器和框架","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"},{"categories":["JUC"],"content":"ConcurrentHashMap如何保证线程安全 关于node节点的状态，有以下四种: static final int MOVED = -1; // hash for forwarding nodes static final int TREEBIN = -2; // hash for roots of trees static final int RESERVED = -3; // hash for transient reservations static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); //计算当前key的hash值 int hash = spread(key.hashCode()); int binCount = 0; //如果这次没有put成功，会重试 for (Node\u003cK,V\u003e[] tab = table;;) { Node\u003cK,V\u003e f; int n, i, fh; //ConcurrentHashMap的初次put会做init操作 if (tab == null || (n = tab.length) == 0) tab = initTable(); //如果对应的node为空，以cas的方式put元素，如果成功，直接退出循环 else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) { if (casTabAt(tab, i, null, new Node\u003cK,V\u003e(hash, key, value, null))) break; // no lock when adding to empty bin } //如果tab[i]的hash值为MOVED，表明该链表正在进行transfer操作,当前线程先帮助进行扩容操作,然后put else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; //锁住node节点，对节点下的链表/红黑树进行同步操作 synchronized (f) { if (tabAt(tab, i) == f) { if (fh \u003e= 0) { //大于0说明当前node是一个可用的链表节点 binCount = 1; for (Node\u003cK,V\u003e e = f;; ++binCount) { K ek; //如果当前key已经存在，判断是否新值替换旧值(根据传入的onlyIfAbsen决定),然后退出 if (e.hash == hash \u0026\u0026 ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } //如果下一个节点为空，直接put进去，然后退出 Node\u003cK,V\u003e pred = e; if ((e = e.next) == null) { pred.next = new Node\u003cK,V\u003e(hash, key, value, null); break; } //继续遍历 } } //如果当前节点是一个树状结构，向树中插入一个元素 else if (f instanceof TreeBin) { Node\u003cK,V\u003e p; binCount = 2; if ((p = ((TreeBin\u003cK,V\u003e)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } //binCount是用来统计链表长度的 if (binCount != 0) { //如果长度达到阈值，转化为红黑树 if (binCount \u003e= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } //统计长度，检查时候需要扩容 addCount(1L, binCount); return null; } ","date":"2020-11-16 21:09:45","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/:1:2","tags":["JUC"],"title":"Java并发容器和框架","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"},{"categories":["JUC"],"content":"关于Hash算法和哈希冲突 Hash算法:就是根据设定的Hash函数H(key)和处理冲突方法，将一组关键字映射到一个有限的地址区间上的算法。所以Hash算法也被称为散列算法、杂凑算法。 Hash表:通过Hash算法后得到的有限地址区间上的集合。数据存放的位置和key之前存在一定的关系(H(key)=stored_value_hash(数据存放位置)),可以实现快速查询。与之相对的，如果数据存放位置和key之间不存在任何关联关系的集合，称之为非Hash表。 Hash冲突:由于用于计算的数据是无限的H(key),key属于(-∞,+∞),而映射到区间是有限的，所以肯定会存在两个key:key1,key2，H(key1)=H(key2)，这就是hash冲突。一般的解决Hash冲突方法有:开放定址法、再哈希法、链地址法（拉链法）、建立公共溢出区。 开放地址法 开放定址法也称为再散列法，基本思想就是，如果p=H(key)出现冲突时，则以p为基础，再次hash，p1=H(p),如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址pi。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以只能在删除的节点上做标记，而不能真正删除节点。 缺点:容易产生堆积问题;不适合大规模的数据存储;插入时会发生多次冲突的情况;删除时要考虑与要删除元素互相冲突的另一个元素，比较复杂。 再哈希法(双重散列，多重散列) 提供多个不同的hash函数，当R1=H1(key1)发生冲突时，再计算R2=H2(key1)，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。 链地址法(拉链法) 链地址法:将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。HashMap采用的就是链地址法来解决hash冲突。(链表长度大于等于8时转为红黑树) 建立公共溢出区 将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。 HashMap中的处理冲突 下面是HashMap的put方法: final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //如果hash数组为空，初始化一下 n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026 hash]) == null) //计算落在hash桶的位置，如果当前桶为空，直接新增节点 tab[i] = newNode(hash, key, value, null); else { //当前桶存在元素 Node\u003cK,V\u003e e; K k; if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) //如果key已经存在，替换元素 e = p; else if (p instanceof TreeNode) //如果当前是树结构了(不是链表了),向树上添加元素 e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); else { //当前结构依然时链表，遍历链表，直到末尾或者找到key相同的元素替换 for (int binCount = 0; ; ++binCount) { //到达末尾，新增元素，如果链表长度达到8，转为红黑树 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //遍历链表的过程中，发现了有key相同的元素，直接替换，然后break if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } } if (e != null) { //如果是已经存在的元素，判断是否替换(onlyIfAbsent) V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; //如果容量超过阈值，扩容 if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } ","date":"2020-11-16 21:09:45","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/:2:0","tags":["JUC"],"title":"Java并发容器和框架","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"},{"categories":["JUC"],"content":"Java并发编程二 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:0:0","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"Java并发编程的艺术 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:1:0","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"上下文切换 CPU通过给每个线程分配CPU时间片来实现在单核CPU中执行多线程。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停切换线程执行，让我们感觉多个线程同时执行（并发）。 CPU通过时间片分配算法来循环执行任务，当一个任务的时间片用完，会保留当前任务的所处状态，执行下一个任务的时间片，而执行完下一个时间片后会切回这个任务，在加载这个任务的状态。所以任务从保存到再加载就是一次上下文的切换。 多线程就一定快吗？ 不一定，因为线程的创建有上下文的切换。 如何减少上下文切换？ 无锁并发编程。多线程竞争锁的时候，会引起上下文的切换，所以多线程编程的时候可以尝试无锁并发，让每个线程处理不同的数据段数据。 CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要锁。 CAS（Compare And Swap）一种无锁算法。 涉及三个操作数：预期值、读写的内存位置、需要写入的新值 会产生三个问题：ABA问题（变量前添加版本号），循环时间开销大（需要不断自旋来读取最新的内存值），只能保证一个共享变量的原子操作。 使用最少的线程，避免使用无效线程。 协程：在单线程离实现多任务调度，并在单线程离维持多个任务的切换 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:1:1","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"Java内存模型 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:2:0","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"前言 并发编程模型的两个关键问题： 线程之间如何通信 线程之间如何同步 通信指的是线程之间以何种机制来交换信息。在命令式编程过程中，线程之间的通信机制有两种： 共享内存 消息传递 同步指程序中用于控制不同线程间操作发生的相对顺序的机制。 Java的并发采用的事共享内存模型，Java线程之间的通信总是隐式进行的 。 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:3:0","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"Java内存模型的抽象概念 在Java中，所有实例域、静态域、数组元素等都存储在堆内存中，堆内存在线程之间共享（共享变量） 线程之间通信的两个步骤： 线程A把本地内存A中更新过的共享变量刷新到共享内存中去 线程B到主内存中读取线程A更新过的共享变量 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:4:0","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"指令序列的重排列 重排列分三种类型，同时也是Java源代码会经历的： 编译器优化的重排列（会出现内存可见性问题） 指令级并行的重排列 内存系统的重排列 JMM属于语言级别的内存模型，确保在不同的编译器和不同的处理器平台上，通过禁止特定类型的编译器重排列和处理器重排列，提供一直的内存可见性保证。 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:4:1","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"happens-before 是JMM的核心。 会改变程序执行结果的重排列：禁止 不会改变程序执行结果的重排列：不做要求 JMM对编译器和处理器的要求：即不改变程序执行结果，编译器和处理器如何优化都可以。 happens-before规则 程序顺序规则 监视器规则 volatile规则：单例双重锁检测问题volatile的作用 传递性 start（）规则：如果线程A执行ThreadB.start()启动，那么线程A的TreadB.start()操作 happens-before 于线程B中任意操作 join（）规则：如果线程A执行ThreadB.join()并成功返回，那么线程B的任意操作happens-before于线程A从TreadB.join()操作成功返回 双重检查锁定与延迟初始化 双重检查锁 public class SingletonLanHan03 { private static volatile SingletonLanHan03 instance; private SingletonLanHan03() {} public static SingletonLanHan03 getInstance() { // 判断对象是否实例化过，没有才进入，如果已经实例化过，则无需进行初始化，减少开销 if(instance == null) { // 没有实例化，对其类对象进行加锁 synchronized (SingletonLanHan03.class) { if (instance == null) { // 进行实例化，但注意这里是非原子性操作 instance = new SingletonLanHan03(); } } } return instance; } } 将Instance使用volatile修饰的原因： 当线程执行到第一次检查的时候，instance不为null，只是可能未完成初始化操作。 创建一个对象的三个步骤： 为该对象分配空间 初始化该对象 设置该对象的引用指针指向内存分配的地址 但JVM可能会进行指令重排序（JIT）从而更改了2、3的顺序，可能该对象已经创建了，但还未来的及进行初始化，便又有线程进行实例的调用了。而volatile防止了指令重排列。 基于类初始化的解决方案 public class SingletonInClass { private SingletonInClass() {} private static class SingletonHolder { private static SingletonInClass instance = new SingletonInClass(); } public static SingletonInClass getInstance() { return SingletonHolder.instance; } } JVM在类的初始化阶段（即Class被加载后，且被线程使用之前）会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁会同步多个线程对该类的初始化过程。 即使发生在指令重排序，但其他线程看不到。 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:4:2","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"线程状态 new 初始化 runnable 运行状态 blocked 阻塞状态 waiting 等待状态 time_waiting 超时等待 （不同于waiting，在指定时间后自动返回sleep（）） terminated 终止 notify（）、notifyAll（）、wait（） 使用这三个方法都需要先对调用对象加锁 调用wait（）方法后，线程状态从runnable转换为waiting，并将当前对象放入到该对象的等待池中 notify（）和notifyAll（）后，等待线程会需要等待调用方法的线程释放当前对象后与其他对象竞争 notify（）会随机将等待池（等待队列）中的线程移动一个到锁池（同步队列）中去，而notifyAll（）会将等待池中全部线程移动到锁池去，被移动的线程状态从waiting-\u003eblocked 从wait（）方法返回的前提是获取到了该对象的锁 Thread.join（）的使用 当线程A等待thread线程终止之后才从thread.join()返回。 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:4:3","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"ThreadLocal的使用 ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的结构。即一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。 package Advance.concurrent_programming.thread_create; /** * Description: * * @author:edgarding * @date:2020/10/20 **/ public class ThreadLocalTest { static ThreadLocal\u003cString\u003e localVariable = new ThreadLocal\u003cString\u003e(); static void print(String str) { // 打印当前localVariable变量的值 System.out.println(str + \":\" + localVariable.get()); // 清除当前本地内存中localVariable变量 // localVariable.remove(); } public static void main(String[] args) { // 创建线程one Thread threadOne = new Thread(new Runnable() { @Override public void run() { // 设置线程one中本地变量localVariable的值 localVariable.set(\"threadOne local variable\"); // 调用打印函数 print(\"threadOne\"); // 打印本地变量值 System.out.println(\"threadOne remove after\" + \":\" + localVariable.get()); } }); // 创建线程two Thread threadTwo = new Thread(new Runnable() { @Override public void run() { localVariable.set(\"threadTwo local variable\"); print(\"threadTwo\"); System.out.println(\"threadTwo remove after\" + \":\" + localVariable.get()); } }); threadOne.start(); threadTwo.start(); } } ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:4:4","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"线程池 线程池解决了大量从客户端传入执行时间短，需要服务端快速处理并返回结果，线程上下文切换带来的开销。 线程池先预先创建若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。 Java中的线程池类就是一个种生产者和消费者模式的实现方式，生产者把任务丢给线程池，线程池创建线程并处理任务（消费） package Advance.concurrent_programming.thread_create; /** * Description: * * @author:edgarding * @date:2020/11/16 **/ public interface ThreadPool\u003cJob extends Runnable\u003e { // 执行一个job void execute(Job job); // 关闭线程池 void shutdown(); // 添加工作线程 void addWorkers(int num); // 关闭工作线程 void removeWorkers(int num); // 获取正在等待执行的线程数量 int getJobSize(); } 线程池的具体实现 package Advance.concurrent_programming.thread_pool; import sun.tools.jconsole.Worker; import java.util.ArrayList; import java.util.Collections; import java.util.LinkedList; import java.util.List; import java.util.concurrent.atomic.AtomicLong; /** * Description: * * @author:edgarding * @date:2020/11/16 **/ public class DefaultThreadPool\u003cJob extends Runnable\u003e implements ThreadPool\u003cJob\u003e { // 线程池的最大限制数目 private static final int MAX_WORKER_NUMBERS = 10; //线程池的默认连接数目 private static final int DEFAULT_WORKER_NUMBERS = 5; // 线程池的最小数量 private static final int MIN_WORKER_NUMBERS = 1; // 工作列表 private final LinkedList\u003cJob\u003e jobs = new LinkedList\u003c\u003e(); // 工作者列表 private final List\u003cWorker\u003e workers = Collections.synchronizedList(new ArrayList\u003c\u003e()); // 工作者线程数目 private int workerNum = DEFAULT_WORKER_NUMBERS; // 线程编号生成 private AtomicLong threadNum = new AtomicLong(); public DefaultThreadPool() { } public DefaultThreadPool(int workerNum) { this.workerNum = workerNum \u003e MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : Math.max(workerNum, MIN_WORKER_NUMBERS); initializeWorkers(workerNum); } // 初始化线程工作 private void initializeWorkers(int workerNum) { for (int i = 0; i \u003c workerNum; i++) { Worker worker = new Worker(); worker.add(worker); Thread thread = new Thread(worker, \"ThreadPool-Worker-\" + threadNum.incrementAndGet()); thread.start(); } } @Override public void execute(Job job) { if (job != null) { // 添加一个工作，然后进行通知 synchronized (job) { jobs.addLast(job); job.notify(); } } } @Override public void shutdown() { for (Worker worker : workers) { worker.stopWorker(); } } @Override public void addWorkers(int num) { } @Override public void removeWorkers(int num) { } @Override public int getJobSize() { return 0; } } // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package sun.tools.jconsole; import java.util.ArrayList; public class Worker extends Thread { ArrayList\u003cRunnable\u003e jobs = new ArrayList(); private boolean stopped = false; public Worker(String var1) { super(\"Worker-\" + var1); this.setPriority(4); } public void run() { while(!this.isStopped()) { synchronized(this.jobs){} while(true) { boolean var7 = false; Runnable var1; try { var7 = true; if (!this.isStopped() \u0026\u0026 this.jobs.size() == 0) { try { this.jobs.wait(); } catch (InterruptedException var8) { } continue; } if (this.isStopped()) { var7 = false; return; } var1 = (Runnable)this.jobs.remove(0); var7 = false; } finally { if (var7) { ; } } var1.run(); break; } } } private synchronized boolean isStopped() { return this.stopped; } public synchronized void stopWorker() { this.stopped = true; synchronized(this.jobs) { this.jobs.notify(); } } public void add(Runnable var1) { synchronized(this.jobs) { this.jobs.add(var1); this.jobs.notify(); } } public boolean queueFull() { synchronized(this.jobs) { return this.jobs.size() \u003e 0; } } } ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:4:5","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"Java中的锁 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:5:0","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"Lock接口 锁用来控制多个线程访问共享资源的方式。在Lock接口出现之前，Java依靠synchronized来实现锁功能，JDK5之后并发包中新增了Lock接口，提供了与synchronized相似的功能，只是在使用是需要显示地获取和释放锁，但却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字不具备的同步特性。 使用方式： Lock lock = new ReentrantLock(); lock.lock(); try { }finally { lock.unlock(); } synchonized所不具备的特性： 尝试非阻塞地获取锁 能被中断地获取锁 超时获取锁 Lock的API void lock（）获取锁 void lockInterruptibly() 可中断地获取锁 boolean tryLock（） boolean tryLock（…） void unlock（）释放锁 Condition newCondition（）等待通知组件 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:5:1","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["JUC"],"content":"重入锁ReentrantLock 就是支持重进入的锁，表示该锁能够支持一个线程对资源的重复加锁，除此之外，该锁的还支持获取锁的公平和非公平性选择。 实现重进入 公平与非公平的区别 如果一个锁是公平的那么锁的获取顺序为FIFO 公平锁保证了锁的获取顺序为FIFO，但代价是大量的线程切换，非公平锁可能造成“饥饿”，但极少的线程切换，保证了更大的吞吐量。 读写锁ReentrantReadWriteLock Mutex和ReentrantLock都是排它锁，这些锁在同一时刻只允许一个线程进行访问。这些锁在同一时刻只允许一个线程进行访问，而读写锁同一时刻允许多个线程进行访问。 API 仅有两个方法 readLock（） writeLock（） static final int SHARED_SHIFT = 16; static final int SHARED_UNIT = (1 \u003c\u003c SHARED_SHIFT); static final int MAX_COUNT = (1 \u003c\u003c SHARED_SHIFT) - 1; static final int EXCLUSIVE_MASK = (1 \u003c\u003c SHARED_SHIFT) - 1; 读写锁的设计，在一个整形变量上使用按位切割，例如32位的int型，高位的16位为读状态，低位的16位为写状态。 通过S\u00260000FFFF将高位的16位抹去来获取写状态。得出一个结论： S不等于0的时候，当写状态（S\u00260000FFFF）等于0，则读状态（S»16)大于0，即读锁已被获取。 ","date":"2020-11-16 11:52:52","objectID":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/:5:2","tags":["JUC"],"title":"Java并发编程二","uri":"/2020/11/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BA%8C/"},{"categories":["设计模式"],"content":"设计模式-re ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:0:0","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"创建者模式 该模式提供创建对象的机制，能够提升已有代码的灵活性和复用性 创建型模式包括： 工厂方法 Factory Method 抽象工厂 Abstract Factory 建造者 Builder 原型 Prototype 单例 SingleTon ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:1:0","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"工厂方法模式 工厂方法主要是在父类中提供一个创建对象的方法，由子类决定实例化对象的类型。主要意图是定义一个创建对象的接口，由子类去自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:1:1","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"抽象工厂模式 抽象工厂是一个中心工厂，创建其它的工厂模式。 总的来说，抽象工厂模式所要解决的问题就是在一个产品族，存在多个不同类型的产品（Redis集群、操作系统）情况下，接口选择的问题。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:1:2","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"建造者模式 建造者模式所完成的内容就是通过将多个简单对象通过一步步的组装建造出一个复杂的对象的过程。 将一个复杂的构建与其相分离，使得同样的构建过程可以创建不同的表示。 案例 java.lang.StringBuilder Appendable 接口定义了多个append方法（抽象方法），即Appendable为抽象建造者，定义了抽象方法，AbstractStringBuilder已经是建造者，只是不能实例化，StringBuilder即充当了指挥者角色，同时充当了具体点的建造者，建造方法的实现是由AbstractStringBuilder完成，而StringBuilder继承了AbstractStringBuilder ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:1:3","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"原型模式 主要解决的问题就是创建重复对象，而这部分对象内容比较复杂，生成过程可能从库或者RPC接口中获取数据的耗时较长，因此采用克隆的方式节省时间。 原型模式的优点在于便于通过克隆方式创建复杂对象，也可以避免重复做初始化操作，不需要与类中所属的其它类耦合等，但也有一些缺点，如果对象中包括了循环引用的克隆，以及深度使用对象的克隆，都会使此对象变的异常复杂。 案例 例如考试出卷，有两种类型题：问答题和选择题 想要让问题进行随机，如果不使用原型，很难完成拓展和随机的使用。 而使用原型模式的最重要的手段就是克隆，在需要用到的类都需要实现 implements Cloneable 接口。 Spring bean.xml 中的配置 scope：prototype 与单例不同的是，实例出来的对象不是同一个对象了，Bean工厂默认配置是单例。、 深拷贝和浅拷贝 **浅拷贝：**对于基本数据类型的成员变量，浅拷贝会直接进行值传递，即将该属性值复制一份给新的对象。对于引用数据类型，浅拷贝会进行引用传递，将该成员变量的引用值（内存地址）复制一份给新的对象。浅拷贝是使用默认的clone（）方法来实现的 **深拷贝：**复制对象的所有基本数据类型的成员变量。为所有引用数据类型的成员变量申请存储空间，直到该对象可达所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝。重写clone方法来实现深拷贝，通过对象序列化实现深拷贝。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:1:4","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"单例模式 保证一个类只有一个实例哪怕再多线程访问也要提供一个全局访问此实例的点。单例模式主要解决的是，一个全局使用的类频繁的创建和消费，从而提升整体代码的性能。 保证了系统中只存在一个对象，节省了系统资源。 想要实例化一个单例类的时候，必须记住使用相应获取对象的方法而不是new。 8个实现方法： 饿汉模式-2 懒汉模式-3 静态内部类 双重锁检测 枚举 案例 数据库的连接池不会反复创建 spring中一个单例模式bean的生成和使用 在我们平常的代码中需要设置全局的一些属性保存 Runtime源码中，使用了饿汉模式。 工具类、Session工厂的等等 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:1:5","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"结构型模式 该模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效 结构型模式包括： 适配器模式 Adapter 桥接 Bridge 组合 Composite 装饰器 Decorator 外观 Facade 享元 Flyweight 代理 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:2:0","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"适配器模式 一个简答的例子：3.5mm耳机接口无法在iphone8以上的手机类型上使用，因此需要3.5mm耳机口转接lighting口。而适配器模式的主要作用也是如此，把原本不兼容的接口，通过适配器修改做到统一。 适配器模式解决的主要问题就是多种差异化类型的接口做统一输出。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:2:1","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"桥接模式 为什么你的代码那么多ifelse 桥接模式的主要作用就是通过抽象部分与实现部分分离，把多种可匹配的使用进行组合。说白了核心实现就是在A类中含有B类接口，通过构造函数传递B类实现，这个B类就是设计的桥 像JDBC多种驱动程序的实现、同品牌类型的台式机和笔记本平板、业务实现中的多类接⼝同组过滤服务等。这些场景都⽐较适合使⽤桥接模式进⾏实现，因为在⼀些组合中如果有如果每⼀个类都实现不同的 服务可能会出现笛卡尔积，⽽使⽤桥接模式就可以⾮常简单。 桥接模式的关键是选择桥接拆分点，是否可以找到这样类似的相互组合。 案例 例如：支付app与支付方式的桥接 我们需要判断 微信支付 人脸支付 指纹支付 密码支付 支付宝支付 人脸支付 指纹支付 密码支付 因此产生了重复方式的判断。 System.out.println(\"\\r\\n模拟测试场景；微信支付、人脸方式。\"); Pay wxPay = new WxPay(new PayFaceMode()); wxPay.transfer(\"weixin_1092033111\", \"100000109893\", new BigDecimal(100)); System.out.println(\"\\r\\n模拟测试场景；支付宝支付、指纹方式。\"); Pay zfbPay = new ZfbPay(new PayFingerprintMode()); zfbPay.transfer(\"jlu19dlxo111\",\"100000109894\",new BigDecimal(100)); ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:2:2","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"组合模式 通过吧相似的对象组合成一组可被调用的结构树对象的设计思路。 这种设计⽅式可以让你的服务组节点进⾏⾃由组合对外提供服务，例如你有三个原⼦校验功能( A：身份 证 、 B：银⾏卡 、 C：⼿机号 )服务并对外提供调⽤使⽤。有些调⽤⽅需要使⽤AB组合，有些调⽤⽅需要 使⽤到CBA组合，还有⼀些可能只使⽤三者中的⼀个。那么这个时候你就可以使⽤组合模式进⾏构建服 务，对于不同类型的调⽤⽅配置不同的组织关系树，⽽这个树结构你可以配置到数据库中也可以不断的 通过图形界⾯来控制树结构。 案例 一些决策树问题，例如优惠券的分发，如果购物不多，则对其会经常增加促销力度，增加用户粘性。和ifelse的作用，但方便以后的拓展和修改。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:2:3","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"装饰器模式 装饰器的核心就是不再修改原有类的基础上给新类新增功能，不改变原有类。例如继承、AOP切面都可以实现，但装饰器模式能避免继承子类过多的情况，避免AOP带来的复杂性。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:2:4","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"外观模式 主要解决的是降低调用方的使用接口的复杂逻辑组合。这样调用方与实际的接口提供方提供了一个中间件层，对服务中的通用性复杂逻辑进行中间件包装，让使用方只关心业务开发。 这样的模式十分常见，例如以前注册一个网站的时候需要补全很多信息，但现在一步就可以注册，需要的信息在要使用到的时候再让用户进行补充。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:2:5","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"享元模式 享元模式主要在于共享通用对象，减少内存的使用，提升系统的访问资源效率。而这部分共享对象通常比较占用内存或需要大量的接口或者使用数据库资源，因此统一抽离作为共享对象使用。 在享元模式下，需要享元工厂来进行管理这部分独立的对象和共享的对象，避免出现线程安全的问题。 案例 例如数据库连接池的使用、线程池的使用等等 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:2:6","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"代理模式 代理模式类似于分销商，主要解决某些资源的访问、对象的类的易用操作上提供方便使用的代理服务。。⽽这种设计思想的模式经常会出现在我们的系统中，或者你⽤到过 的组件中，它们都提供给你⼀种⾮常简单易⽤的⽅式控制原本你需要编写很多代码的进⾏使⽤的服务类。 类似这样的场景可以想到； 你的数据库访问层⾯经常会提供⼀个较为基础的应⽤，以此来减少应⽤服务扩容时不⾄于数据库连 接数暴增。 使⽤过的⼀些中间件例如；RPC框架，在拿到jar包对接⼝的描述后，中间件会在服务启动的时候⽣ 成对应的代理类，当调⽤接⼝的时候，实际是通过代理类发出的socket信息进⾏通过。 另外像我们常⽤的 MyBatis ，基本是定义接⼝但是不需要写实现类，就可以对 xml 或者⾃定义注 解⾥的 sql 语句进⾏增删改查操作。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:2:7","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"行为型模式 该模式负责对象间的高效沟通和职责委派 行为型模式包括： 责任链 Chain of Responsesiability 命令 Command 迭代器 Iterator 中介者 Mediator 备忘录 Memento 观察者 Observer 状态 State 策略 Strategy 模板 Template 访问者 Visitor ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:3:0","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"责任链模式 责任链模式的核心就是解决一组服务中的先后执行处理关系，例如学校请假，普通的请假班长审批辅导员审批，长假就需要班长辅导员院长审批。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:3:1","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"命令模式 命令模式相对于互联网开发来说相对教授，但日常中很常见，就是cmd+c和cmd+v，这就是把逻辑实现与操作请求进行分离，降低耦合方面方便拓展。 命令方式以数据驱动的方式命令对象，可以使用构造函数的方式传递给调用者。调用者再提供相应的实现命令执行提供操作方法。 抽象命令类：声明执行命令的接口和方法 具体的命令实现类：接口类的具体实现，可以是一组相似的行为逻辑 实现者：也就是为命令做实现的具体实现类 调用者：处理命令，实现的具体操作者，负责对外提供命令服务 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:3:2","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"迭代器模式 迭代器模式，常见的就是日常使用的iterator遍历。虽然在实际业务开发中不常见，但每天都要使用JDK提供的list集合遍历。 注意：增强for循环不是迭代器模式，迭代器模式的特点是实现Iterable接口，通过next方式获取集合，同时具备删除等操作。而增强for循环可以做到。 这种设计模式的优点就是让我以相同的方式可以去遍历不同的数据结构元素。 迭代器模式的遍历组织结构 Collection，集合方法部分对于自定义的数据结构添加通用方法：add、remove、Iterator等核心方法 Iterable，提供获取迭代器，这个接口类会被Collection继承 Iterator，提供两个方法定义：hasNext、next会在具体的数据结构中写实现方法 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:3:3","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"中介者模式 中介者模式要解决的就是复杂功能之间的重复调用，在这中间添加一层中介者包装服务，对外提供简单、通用、易拓展的服务能力。 例如ORM框架——MyBatis等 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:3:4","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"备忘录模式 备忘录模式是以可以恢复或者说回滚、配置、版本、悔棋为核心功能的设计模式。在功能上是以不破坏原对象为基础增加备忘录操作类，记录原对象的行为从而实现备忘录模式。 如果cmd+z，返回上一个操作，游戏回档等。 备忘录的设计模式实现⽅式，重点在于不更改原有类的基础上，增加备忘录类存放记录。可能平时虽然 不⼀定⾮得按照这个设计模式的代码结构来实现⾃⼰的需求，但是对于功能上可能也完成过类似的功 能，记录系统的信息。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:3:5","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"观察者模式 简单来说，就是当一个行为发生时传递消息给另外一个用户接收做出相应的处理，两者之间没有直接的耦合关联。例如经常使用的MQ服务，虽然MQ服务是有个一个通知中心并不是每个类进行服务，但整体上也算是观察者模式的设计思路。 即一个对象发生改变的时候自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:3:6","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"状态模式 状态模式描述的是⼀个⾏为下的多种状态变更，⽐如我们最常⻅见的⼀个⽹站的⻚页⾯，在你登录与不登录 下展示的内容是略有差异的( 不登录不能展示个⼈信息 )，⽽这种 登录 与 不登录 就是我们通过改变状态， ⽽让整个⾏为发⽣了变化。 一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:3:7","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"策略模式 策略模式是⼀种⾏为模式，也是替代⼤量ifelse的利器。它所能帮你解决的是场景，⼀般是具有同类可替代的⾏为逻辑算法场景。⽐如；不同类型的交易⽅式(信⽤卡、⽀付宝、微信)、⽣成唯⼀ID策略 (UUID、DB⾃增、DB+Redis、雪花算法、Leaf算法)等，都可以使⽤策略模式进⾏⾏为包装，供给外部 使⽤。定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化。 完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。 在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:3:8","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"模板模式 模板模式的核⼼设计思路是通过在，抽象类中定义抽象⽅法的执⾏顺序，并将抽象⽅法设定为只有⼦类 实现，但不设计 独⽴访问 的⽅法。简单说也就是把你安排的明明⽩⽩的。 就像⻄西游记的99⼋⼗⼀难，基本每⼀关都是；师傅被掳⾛、打妖怪、妖怪被收⾛，具体什么妖怪你⾃⼰ 定义，怎么打你想办法，最后收⾛还是弄死看你本事，我只定义执⾏顺序和基本策略，具体的每⼀难由 观⾳来安排。 即你的人生从出生起就被安排好了如何过完，出生-》死亡，但你的经历随便你。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:3:9","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["设计模式"],"content":"访问者模式 访问者要解决的核⼼事项是，在⼀个稳定的数据结构下，例如⽤户信息、雇员信息等，增加易变的业务 访问逻辑。为了增强扩展性，将这两部分的业务解耦的⼀种设计模式。 说⽩了访问者模式的核⼼在于同⼀个事物不同视⻆角下的访问信息不同。 ","date":"2020-11-14 13:12:33","objectID":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/:3:10","tags":["设计模式"],"title":"设计模式(re)","uri":"/2020/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-re/"},{"categories":["Java基础"],"content":"Java反射机制 ","date":"2020-11-12 15:59:05","objectID":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:0:0","tags":["Java基础"],"title":"Java反射机制","uri":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["Java基础"],"content":"Class类 RTTI（Run-Time Type Identification）运行时类型识别，其作用是运行时识别一个对象的类型和类的信息。 运编译器已知道所有类型（在没有反射机制创建和使用类对象时，一般都是编译期已确定其类型） 反射机制，允许我们在运行时发现和使用类型的信息 在Java中用来表示运行时类型信息对应的类就是Class类，Class类也是一个实际存在的类。 实际上在Java中每个类都有一个Class对象，每当我们编写并且编译一个新创建的类就会产生一个对应Class对象并且这个Class对象会被保存在同名.class文件里(编译后的字节码文件保存的就是Class对象)，那为什么需要这样一个Class对象呢？是这样的，当我们new一个新对象或者引用静态成员变量时，Java虚拟机(JVM)中的类加载器子系统会将对应Class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象创建我们需要实例对象或者提供静态变量的引用值。 ","date":"2020-11-12 15:59:05","objectID":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:1:0","tags":["Java基础"],"title":"Java反射机制","uri":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["Java基础"],"content":"Class对象 Class类也是类的一种，与class关键字是不一样的。 手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)，比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，并保存在Shapes.class字节码文件中。 每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。 Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载 Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。 ","date":"2020-11-12 15:59:05","objectID":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:1:1","tags":["Java基础"],"title":"Java反射机制","uri":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["Java基础"],"content":"Class对象的加载 Class对象是由JVM加载的，所有类都是在对其第一次使用动态加载到JVM中的，当程序创建第一个对类的静态成员引用时，就会加载这个被使用的类（实际上加载的就是这个类的字节码文件） 注意：使用new创建类的新实例的对象也会被当做类的成员引用（构造函数也是类的静态方法），由此看来Java程序在他们运行之前也并非一次性全部加载到内存，各个部分是按需加载，所以在使用该类的时，Class Loader会先根据类名查找.class文件，在进行检查完全没有问题后会被动态加载到内存中，此时Class对象也就被加载如内存了。 ","date":"2020-11-12 15:59:05","objectID":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:1:2","tags":["Java基础"],"title":"Java反射机制","uri":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["Java基础"],"content":"Class.forName()方法 会返回一个类的Class对象。 ","date":"2020-11-12 15:59:05","objectID":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:1:3","tags":["Java基础"],"title":"Java反射机制","uri":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["Java基础"],"content":"反射 ","date":"2020-11-12 15:59:05","objectID":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:2:0","tags":["Java基础"],"title":"Java反射机制","uri":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["Java基础"],"content":"反射API Field 类：提供有关类的属性信息，以及对它的动态访问权限。它是一个封装反射类的属性的类。 Constructor 类：提供有关类的构造方法的信息，以及对它的动态访问权限。它是一个封装反射类的构造方法的类。 Method 类：提供关于类的方法的信息，包括抽象方法。它是用来封装反射类方法的一个类。 Class 类：表示正在运行的 Java 应用程序中的类的实例。 Object 类：Object 是所有 Java 类的父类。所有对象都默认实现了 Object 类的方法。 ","date":"2020-11-12 15:59:05","objectID":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:2:1","tags":["Java基础"],"title":"Java反射机制","uri":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["Java基础"],"content":"获取Class对象的三种方式 获取 Class 对象有三种方式： package Advance.reflection; /** * Description: * * @author:edgarding * @date:2020/11/12 **/ public class Main { public static void main(String[] args) { try { // 通过字符串加载 Class test = Class.forName(\"Advance.reflection.A\"); // 通过class属性 Class test1 = A.class; // 通过类的getClass（）方法 A a = new A(); Class test2 = a.getClass(); System.out.println(test + \"\\n\" + test1 + \"\\n\" + test2); System.out.println(\"test == test ? \" + (test == test1)); System.out.println(\"test 1 == test 2 ? \" + (test1 == test2)); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 第一种方法是通过类的全路径字符串获取 Class 对象，这也是我们平时最常用的反射获取 Class 对象的方法； 第二种方法有限制条件：需要导入类的包； 第三种方法已经有了 Student 对象，不再需要反射。 通过这三种方式获取到的 Class 对象是同一个，也就是说 Java 运行时，每一个类只会生成一个 Class 对象。 运行程序，输出如下： class Advance.reflection.A class Advance.reflection.A class Advance.reflection.A test == test ? true test 1 == test 2 ? true ","date":"2020-11-12 15:59:05","objectID":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:2:2","tags":["Java基础"],"title":"Java反射机制","uri":"/2020/11/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":["Java基础"],"content":"Java注解 ","date":"2020-11-12 15:25:16","objectID":"/2020/11/java%E6%B3%A8%E8%A7%A3/:0:0","tags":["Java基础"],"title":"Java注解","uri":"/2020/11/java%E6%B3%A8%E8%A7%A3/"},{"categories":["Java基础"],"content":"前言 实际上Java注解与普通修饰符(public、static、void等)的使用方式并没有多大区别，下面的例子是常见的注解： public class AnnotationDemo { //@Test注解修饰方法A @Test public static void A(){ System.out.println(\"Test.....\"); } //一个方法上可以拥有多个不同的注解 @Deprecated @SuppressWarnings(\"uncheck\") public static void B(){ } } 通过在方法上使用@Test注解后，在运行该方法时，测试框架会自动识别该方法并单独调用，@Test实际上是一种标记注解，起标记作用，运行时告诉测试框架该方法为测试方法。而对于@Deprecated和@SuppressWarnings(“uncheck”)，则是Java本身内置的注解，在代码中，可以经常看见它们，但这并不是一件好事，毕竟当方法或是类上面有@Deprecated注解时，说明该方法或是类都已经过期不建议再用，@SuppressWarnings 则表示忽略指定警告，比如@SuppressWarnings(“uncheck”)，这就是注解的最简单的使用方式，那么下面我们就来看看注解定义的基本语法 想象代码具有生命，注解就是对于代码中某些鲜活的个体贴上去的一张标签。 ","date":"2020-11-12 15:25:16","objectID":"/2020/11/java%E6%B3%A8%E8%A7%A3/:1:0","tags":["Java基础"],"title":"Java注解","uri":"/2020/11/java%E6%B3%A8%E8%A7%A3/"},{"categories":["Java基础"],"content":"基本语法 ","date":"2020-11-12 15:25:16","objectID":"/2020/11/java%E6%B3%A8%E8%A7%A3/:2:0","tags":["Java基础"],"title":"Java注解","uri":"/2020/11/java%E6%B3%A8%E8%A7%A3/"},{"categories":["Java基础"],"content":"声明注解和元注解 注解的定义 注解通过 @interface 来进行定义 public @interface Test { } 我们先来看看前面的Test注解是如何声明的： //声明Test注解 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Test { } 我们使用了@interface声明了Test注解，并使用@Target注解传入ElementType.METHOD参数来标明@Test只能用于方法上，@Retention(RetentionPolicy.RUNTIME)则用来表示该注解生存期是运行时，从代码上看注解的定义很像接口的定义，确实如此，毕竟在编译后也会生成Test.class文件。对于@Target和@Retention是由Java提供的元注解，所谓元注解就是标记其他注解的注解 @Target 用来约束注解可以应用的地方（如方法、类或字段），其中ElementType是枚举类型，其定义如下，也代表可能的取值范围 public enum ElementType { /**标明该注解可以用于类、接口（包括注解类型）或enum声明*/ TYPE, /** 标明该注解可以用于字段(域)声明，包括enum实例 */ FIELD, /** 标明该注解可以用于方法声明 */ METHOD, /** 标明该注解可以用于参数声明 */ PARAMETER, /** 标明注解可以用于构造函数声明 */ CONSTRUCTOR, /** 标明注解可以用于局部变量声明 */ LOCAL_VARIABLE, /** 标明注解可以用于注解声明(应用于另一个注解上)*/ ANNOTATION_TYPE, /** 标明注解可以用于包声明 */ PACKAGE, /** * 标明注解可以用于类型参数声明（1.8新加入） * @since 1.8 */ TYPE_PARAMETER, /** * 类型使用声明（1.8新加入) * @since 1.8 */ TYPE_USE 请注意，当注解未指定Target值时，则此注解可以用于任何元素之上，多个值使用{}包含并用逗号隔开，如下： @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE} @Retention用来约束注解的生命周期，分别有三个值，源码级别（source），类文件级别（class）或者运行时级别（runtime），其含有如下： SOURCE：注解将被编译器丢弃（该类型的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class文件里） CLASS：注解在class文件中可用，但会被VM丢弃（该类型的注解信息会保留在源码里和class文件里，在执行的时候，不会加载到虚拟机中），请注意，当注解未定义Retention值时，默认值是CLASS，如Java内置注解，@Override、@Deprecated、@SuppressWarnning等 RUNTIME：注解信息将在运行期(JVM)也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息），如SpringMvc中的@Controller、@Autowired、@RequestMapping等。 而这个两个注解@Rentention和@Target都是元注解，是注解在注解上的注解。 元注解有5个： @Retention：用来约束注解的生命周期 @Target：标注注解所能运用的地方 @Documented：能将注解中的元素包含到Javadoc中去 @Inherited：继承的意思，就是说如果一个父类被@Inherited注解过的注解进行注解的话，那么他的子类没有任何注解应用的话，那么这个子类就是继承了父类的注解 @Repeatable：是Java8加入进来，即注解的值可以取多个，例如一个人可以是程序员，画家，数学家等等 ","date":"2020-11-12 15:25:16","objectID":"/2020/11/java%E6%B3%A8%E8%A7%A3/:2:1","tags":["Java基础"],"title":"Java注解","uri":"/2020/11/java%E6%B3%A8%E8%A7%A3/"},{"categories":["Java基础"],"content":"注解元素及其数据结构类型 注解支持的元素数据类型除了基本的数据类型，还包含如下： String Class enum Anootation 除此以外，使用其他数据类型编译器会报错。 编译器对默认值的限制 元素不能有不确定的值，就是说，元素要么具有默认值，要么在声明的时候定义默认值，无论如何都不能以null作为值 ","date":"2020-11-12 15:25:16","objectID":"/2020/11/java%E6%B3%A8%E8%A7%A3/:2:2","tags":["Java基础"],"title":"Java注解","uri":"/2020/11/java%E6%B3%A8%E8%A7%A3/"},{"categories":["Java基础"],"content":"Java内置注解与其他元注解 @Override：用于标明此方法覆盖了父类的方法，源码如下 @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } @Deprecated：用于标明已经过时的方法或类，源码如下 @Documented @Retention(RetentionPolicy.RUNTIME) @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}) public @interface Deprecated { } @SuppressWarnnings：用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告，其实现源码如下： @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) @Retention(RetentionPolicy.SOURCE) public @interface SuppressWarnings { String[] value(); } 其内部有一个String数组，主要接收值如下： deprecation：使用了不赞成使用的类或方法时的警告； unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告; path：在类路径、源文件路径等中有不存在的路径时的警告; serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告; finally：任何 finally 子句不能正常完成时的警告; all：关于以上所有情况的警告。 ","date":"2020-11-12 15:25:16","objectID":"/2020/11/java%E6%B3%A8%E8%A7%A3/:2:3","tags":["Java基础"],"title":"Java注解","uri":"/2020/11/java%E6%B3%A8%E8%A7%A3/"},{"categories":["Spring"],"content":"Spring 关于《Spring实战》的一些学习 ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:0:0","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["Spring"],"content":"前言 任何实际的应用程序都是很多组件组成的，每个组件负责整个应用功能的一部分，这些组件需要与其他的应用元素进行协调以完成自己的任务。当程序需要运行的时候，需要以某种方式创建引入这些组件。 **Spring的核心就是提供一个容器（container），通常称为Spring应用上下文（Spring Application Context），它们会创建和管理应用组件。**而这些组件也称为 Bean ，会在Spring Application Context中装配到一起，从而形成一个完整的应用程序。 将 Bean 装配到一起的行为称为 依赖注入（Dependency Injection）的模式 实现的。此时，组件不会创建它所依赖的组件并管理他们生命周期，使用 DI模式 的应用依赖于单独实体（Container）去创建和维护所有组件，并将其注入相应的Bean中。 配置Spring的方式： 使用一个或多个XML文件（描述各个组件以及其他组件之间的关系） 使用Java配置 相比使用XML方式，基于Java配置有更好的类型安全性和重构能力。 @Configuration 会告知Spring这是一个配置类，会为Spring Application Context提供bean @Bean 表示这些方法所返回的对象会以bean的形式添加到Spring Application Context中（默认情况下，这些bean所对应的bean ID与定义它们的方法名相同） 在Spring中，自动配置依赖于 自动装配（autowiring）和组件扫描（component scanning）。借助component scanning Spring能自动发现该应用类路径下的组件，并创建到Spring Applicaiton Context的bean中。 \u003c!-- 自动扫描所有的注解 --\u003e \u003ccontext:component-scan base-package=\"com.xxxx\"/\u003e 而Spring Boot极大地改善了Spring中显式配置，提供了更多增强生产效率的方法。 ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:1:0","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["Spring"],"content":"Spring核心框架 Spring：是Spring领域中的一切基础，提供核心容器和DI框架 SpringMVC：Spring中的web框架 Spring Data：基本数据的持久化支持 将应用程序的数据respository定义为简单的Java接口，在定义驱动存储和检索数据的方法时使用一种命名约定即可 此外Spring Data能处理多种不同类型的数据库，包含关系型JPA、文档型Mongo、图数据库Neo4j Spring Security 解决应用程序通用的安全性需求，认证（Authentication）和授权（Authorization） Spring Ingration 和 Spring Batch Spring Ingration 解决了实时集成问题 Spring Batch 解决了批处理集成的问题 Spring Boot Spring Cloud ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:2:0","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["Spring"],"content":"开始 ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:3:0","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["Spring"],"content":"Spring项目结构 注意 mvnw和mvnw.cmd 这是Maven包装器（wrapper）脚本。 借助该脚本，即使主机上没有安装maven也可构建项目。 maven中 \u003cpackaging\u003ejar\u003c/packaging\u003e默认为jar类型 传统的Java Web应用都是打包成war文件，但jar是所有云平台都能运行可执行jar文件。 根目录com.example 数据类实体类domain jpa项目：com.example.domain mybatis项目：com.example.entity 数据额接口访问层service com.example.service 数据服务接口实现层 com.example.service.impl 前端控制层controller com.example.controller 工具类库utils com.example.utils 配置类config com.example.config 数据传输对象dto（Data Transfer Object）用于封装多个实体类和domain之间的关系，不会破坏原有的实体类结构 com.example.dto 视图包装对象vo（View Object）用与封装客户端请求的数据，防止部分数据泄露：如管理员ID，保证数据安全，不会破坏原有实体类结构 com.example.vo 常量类constant com.example.constant 根目录resources 项目配置文件：resources.application.yml 静态资源目录：resources.static 用于存放html、css、js、图片等资源 视图模版目录：resources.templates 用于存放jsp、thymeleaf等模版文件 mybatis映射文件：resources.mappers mybatis配置文件：resources.spring-mybatis.xml ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:3:1","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["Spring"],"content":"Web使用 略 ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:4:0","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["Spring"],"content":"使用数据 使用JDBC或JPA ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:5:0","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["Spring"],"content":"最基本的JDBC连接数据库 import java.sql.*; /** * Description: * * @date: 2020/3/20 * @author: Edgar_Ding */ public class DBUtil { private static final String DRIVER = \"com.mysql.jdbc.Driver\"; private static final String URL = \"jdbc:mysql://localhost:3306/jdbc201910\"; private static final String USER = \"root\"; private static final String PASSWORD = \"dingjunjie\"; /** * 获取数据库连接 * @return * @throws SQLException * @throws ClassNotFoundException */ public Connection getConnection() throws SQLException, ClassNotFoundException { //1.加载驱动程序 Class.forName(DRIVER); //2. 获得数据库连接 return DriverManager.getConnection(URL, USER, PASSWORD); } //关闭资源 增删改 public static void closeIDU(Connection connection, Statement statement) throws SQLException { if(statement != null) { statement.close(); } if(connection != null) { connection.close(); } } //关闭资源 查询 public static void closeR(ResultSet resultSet, Connection connection, Statement statement) throws SQLException { if(resultSet != null) { resultSet.close(); } if(connection != null) { connection.close(); } if(statement != null) { statement.close(); } } //关闭资源 无论是增删改还是查询都行 public static void close(AutoCloseable... autoCloseables) { for (AutoCloseable autoCloseable : autoCloseables) { try { if (autoCloseable != null) { // System.out.println(autoCloseable.getClass().getName()); autoCloseable.close(); } } catch (Exception e) { e.printStackTrace(); } } } } /** * 根据id删除用户 * @param id */ public void deleteUserById(int id) throws SQLException, ClassNotFoundException { //1、注册驱动 //2、建立连接 PreparedStatement preparedStatement = null; Connection connection = null; try { connection = new DBUtil().getConnection(); //3、定义sql String sql = \"delete from user where id = ?\"; //4、创建preparedStatement preparedStatement = connection.prepareStatement(sql); //5、设置参数 preparedStatement.setInt(1, id); //6、执行sql （一定不能传入参数，不报错，但不返回值） int affectRows = preparedStatement.executeUpdate(); System.out.println(\"affectRows : \" + affectRows); } finally { //7、关闭资源 DBUtil.close(preparedStatement, connection); } } ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:5:1","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["Spring"],"content":"保护Spring ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:6:0","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["Spring"],"content":"Spring Security 详情查SpringSecurity ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:6:1","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["Spring"],"content":"创建REST服务 详情查RESTfulAPI简明 ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:7:0","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["Spring"],"content":"启用超媒体 超媒体作为应用状态引擎（Hypermedia as the Engine of Application State，HATEOAS） 创建一种自描述API的方式，API返回的资源中会包含相关资源的连接，客户端只需要最少的API URL信息就能导航整个API。 ","date":"2020-11-12 14:36:45","objectID":"/2020/11/spring/:7:1","tags":["Spring"],"title":"Spring","uri":"/2020/11/spring/"},{"categories":["工具"],"content":"Alfred 默认情况下，alfred 至少能胜任 15 项工作： 应用搜索 文件或目录搜索 文本内容搜索 标记搜索 快捷网页搜索 书签搜索 计算器 词典搜索 通讯录搜索 剪切板搜索 代码片段搜索 iTunes管理 1Password搜索 系统常用命令快捷操作 直接唤起指定终端并执行命令 ","date":"2020-11-12 09:14:10","objectID":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["Alfred"],"title":"Alfred的使用","uri":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"应用搜索 直接输入APP名，列出本地安装的所有相关应用，可以快速唤起。 ","date":"2020-11-12 09:14:10","objectID":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/:0:1","tags":["Alfred"],"title":"Alfred的使用","uri":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"文件或目录搜索 输入 find 和 open 命令，可以快速查找相当于一个聚焦搜索。 ","date":"2020-11-12 09:14:10","objectID":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/:0:2","tags":["Alfred"],"title":"Alfred的使用","uri":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"文本内容搜索 输入 in 列出磁盘中有关此文本的相关文件。 ","date":"2020-11-12 09:14:10","objectID":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/:0:3","tags":["Alfred"],"title":"Alfred的使用","uri":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"标记搜索 输入 tags 寻找标记的文件或文件夹，但需今夕设置。 ","date":"2020-11-12 09:14:10","objectID":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/:0:4","tags":["Alfred"],"title":"Alfred的使用","uri":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"快捷网页搜索 perferences 中 features 中的web栏，键入keyword，使用相关的浏览器进行搜索。 例如 google alfred // 使用goole搜索alfred gmail // 打开gmail ","date":"2020-11-12 09:14:10","objectID":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/:0:5","tags":["Alfred"],"title":"Alfred的使用","uri":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"计算器 ","date":"2020-11-12 09:14:10","objectID":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/:0:6","tags":["Alfred"],"title":"Alfred的使用","uri":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"词典搜索 ","date":"2020-11-12 09:14:10","objectID":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/:0:7","tags":["Alfred"],"title":"Alfred的使用","uri":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"通讯录搜索 ","date":"2020-11-12 09:14:10","objectID":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/:0:8","tags":["Alfred"],"title":"Alfred的使用","uri":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"剪贴板搜索 ","date":"2020-11-12 09:14:10","objectID":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/:0:9","tags":["Alfred"],"title":"Alfred的使用","uri":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"系统操作指令 ![系统操作指令](/Alfred/截屏2020-11-12 上午9.49.36.png) ","date":"2020-11-12 09:14:10","objectID":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/:0:10","tags":["Alfred"],"title":"Alfred的使用","uri":"/2020/11/alfred%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["框架","MyBatis"],"content":"Mybatis ","date":"2020-11-11 17:41:51","objectID":"/2020/11/mybatis/:0:0","tags":["MyBatis"],"title":"MyBatis","uri":"/2020/11/mybatis/"},{"categories":["框架","MyBatis"],"content":"Mybatis中#{}和${}的区别 其最大的差别就是 #{} 可以防止sql注入，后 ${} 不可以。 SQL注入 一般前台有两个输入框，一个用户名一个密码，传入到后台后会拼接两个参数 select USER from table where username=userinput and password=userinput 来查询用户和校对，但是用户可以故意输入一个让后台解析失败的字符串，这就是SQL注入 select USER from table where username=userinput and password='' or 1=1 就无需使用密码了，为了防止SQL注入的问题，首先要对单引号进行过滤，在添加逻辑 关于# #{} 表示一个占位符号，相当于JDBC中的 ？ #{} 实现的是向prepareStatement中预处理语句中设置参数值，sql语句中#{}表示一个占位符即? #{}将传入的数据都当成一个字符串，会自动传入的数据加一个双引号。 如果sql语句中只有一个参数时，参数名可以随意定义，若是一个实体或者map集合等，则需写『实体属性名』或者『map集合关键字』 关于$ 将传入的数据直接显示 ${}中参数名称不能随意更改 简单来说JDBC不支持使用占位符的地方可以使用${} Mybatis中的#{}和${}的区别 #{}能防止sql注入 在JDBC能使用占位符的地方最好优先使用#{} 在JDBC不支持使用占位符的地方就只能使用${}动态参数 例如使用 order by、like动态参数的时候。 例如模糊查询 select * from user where user_name link '%${param}%' ","date":"2020-11-11 17:41:51","objectID":"/2020/11/mybatis/:0:1","tags":["MyBatis"],"title":"MyBatis","uri":"/2020/11/mybatis/"},{"categories":["框架","MyBatis"],"content":"MyBatis Generator 配置 ","date":"2020-11-11 17:41:51","objectID":"/2020/11/mybatis/:1:0","tags":["MyBatis"],"title":"MyBatis","uri":"/2020/11/mybatis/"},{"categories":["框架","MyBatis"],"content":"引入插件 Mybatis-Generator的运行方式有很多种： 基于mybatis-generator-core-x.x.x.jar和其XML配置文件，通过命令行运行。 通过Ant的Task结合其XML配置文件运行。 通过Maven插件运行。 通过Java代码和其XML配置文件运行。 通过Java代码和编程式配置运行。 通过Eclipse Feature运行。 ","date":"2020-11-11 17:41:51","objectID":"/2020/11/mybatis/:1:1","tags":["MyBatis"],"title":"MyBatis","uri":"/2020/11/mybatis/"},{"categories":["框架","MyBatis"],"content":"通过编码和配置文件运行 \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.generator\u003c/groupId\u003e \u003cartifactId\u003emybatis-generator-core\u003c/artifactId\u003e \u003cversion\u003e1.4.0\u003c/version\u003e \u003c/dependency\u003e ","date":"2020-11-11 17:41:51","objectID":"/2020/11/mybatis/:1:2","tags":["MyBatis"],"title":"MyBatis","uri":"/2020/11/mybatis/"},{"categories":["框架","MyBatis"],"content":"配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!--mybatis的代码生成器相关配置--\u003e \u003c!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"\u003e \u003cgeneratorConfiguration\u003e \u003c!-- 引入配置文件 --\u003e \u003cproperties resource=\"application-dev.properties\"/\u003e \u003c!-- 一个数据库一个context,context的子元素必须按照它给出的顺序 property*,plugin*,commentGenerator?,jdbcConnection,javaTypeResolver?, javaModelGenerator,sqlMapGenerator?,javaClientGenerator?,table+ --\u003e \u003ccontext id=\"myContext\" targetRuntime=\"MyBatis3\" defaultModelType=\"flat\"\u003e \u003c!-- 这个插件给生成的Java模型对象增加了equals和hashCode方法 --\u003e \u003c!--\u003cplugin type=\"org.mybatis.generator.plugins.EqualsHashCodePlugin\"/\u003e--\u003e \u003c!-- 注释 --\u003e \u003ccommentGenerator\u003e \u003c!-- 是否不生成注释 --\u003e \u003cproperty name=\"suppressAllComments\" value=\"true\"/\u003e \u003c!-- 不希望生成的注释中包含时间戳 --\u003e \u003c!--\u003cproperty name=\"suppressDate\" value=\"true\"/\u003e--\u003e \u003c!-- 添加 db 表中字段的注释，只有suppressAllComments为false时才生效--\u003e \u003c!--\u003cproperty name=\"addRemarkComments\" value=\"true\"/\u003e--\u003e \u003c/commentGenerator\u003e \u003c!-- jdbc连接 --\u003e \u003cjdbcConnection driverClass=\"${spring.datasource.driverClassName}\" connectionURL=\"${spring.datasource.url}\" userId=\"${spring.datasource.username}\" password=\"${spring.datasource.password}\"\u003e \u003c!--高版本的 mysql-connector-java 需要设置 nullCatalogMeansCurrent=true--\u003e \u003cproperty name=\"nullCatalogMeansCurrent\" value=\"true\"/\u003e \u003c/jdbcConnection\u003e \u003c!-- 类型转换 --\u003e \u003cjavaTypeResolver\u003e \u003c!--是否使用bigDecimal，默认false。 false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer true，把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal--\u003e \u003cproperty name=\"forceBigDecimals\" value=\"true\"/\u003e \u003c!--默认false false，将所有 JDBC 的时间类型解析为 java.util.Date true，将 JDBC 的时间类型按如下规则解析 DATE -\u003e java.time.LocalDate TIME -\u003e java.time.LocalTime TIMESTAMP -\u003e java.time.LocalDateTime TIME_WITH_TIMEZONE -\u003e java.time.OffsetTime TIMESTAMP_WITH_TIMEZONE -\u003e java.time.OffsetDateTime --\u003e \u003c!--\u003cproperty name=\"useJSR310Types\" value=\"false\"/\u003e--\u003e \u003c/javaTypeResolver\u003e \u003c!-- 生成实体类地址 --\u003e \u003cjavaModelGenerator targetPackage=\"com.wqlm.boot.user.po\" targetProject=\"src/main/java\"\u003e \u003c!-- 是否让 schema 作为包的后缀，默认为false --\u003e \u003c!--\u003cproperty name=\"enableSubPackages\" value=\"false\"/\u003e--\u003e \u003c!-- 是否针对string类型的字段在set方法中进行修剪，默认false --\u003e \u003cproperty name=\"trimStrings\" value=\"true\"/\u003e \u003c/javaModelGenerator\u003e \u003c!-- 生成Mapper.xml文件 --\u003e \u003csqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources\"\u003e \u003c!--\u003cproperty name=\"enableSubPackages\" value=\"false\"/\u003e--\u003e \u003c/sqlMapGenerator\u003e \u003c!-- 生成 XxxMapper.java 接口--\u003e \u003cjavaClientGenerator targetPackage=\"com.wqlm.boot.user.dao\" targetProject=\"src/main/java\" type=\"XMLMAPPER\"\u003e \u003c!--\u003cproperty name=\"enableSubPackages\" value=\"false\"/\u003e--\u003e \u003c/javaClientGenerator\u003e \u003c!-- schema为数据库名，oracle需要配置，mysql不需要配置。 tableName为对应的数据库表名 domainObjectName 是要生成的实体类名(可以不指定，默认按帕斯卡命名法将表名转换成类名) enableXXXByExample 默认为 true， 为 true 会生成一个对应Example帮助类，帮助你进行条件查询，不想要可以设为false --\u003e \u003ctable schema=\"\" tableName=\"user\" domainObjectName=\"User\" enableCountByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" enableUpdateByExample=\"false\" selectByExampleQueryId=\"false\"\u003e \u003c!--是否使用实际列名,默认为false--\u003e \u003c!--\u003cproperty name=\"useActualColumnNames\" value=\"false\" /\u003e--\u003e \u003c/table\u003e \u003c/context\u003e \u003c/generatorConfiguration\u003e ","date":"2020-11-11 17:41:51","objectID":"/2020/11/mybatis/:1:3","tags":["MyBatis"],"title":"MyBatis","uri":"/2020/11/mybatis/"},{"categories":["框架","MyBatis"],"content":"MyBatis Generator 使用 ","date":"2020-11-11 17:41:51","objectID":"/2020/11/mybatis/:2:0","tags":["MyBatis"],"title":"MyBatis","uri":"/2020/11/mybatis/"},{"categories":["框架","MyBatis"],"content":"什么是example类 Mybatis-Generator会为每个字段产生Criterion，为底层mapper.xml创建动态sql。如果表的字段比较多，产生的example类会非常庞大。理论上通过example类可以构造你想到的任何筛选条件。在Mybatis-Generator中加以配置，配置数据表的生成操作就可以自动生成example。 ","date":"2020-11-11 17:41:51","objectID":"/2020/11/mybatis/:2:1","tags":["MyBatis"],"title":"MyBatis","uri":"/2020/11/mybatis/"},{"categories":["框架","MyBatis"],"content":"了解example成员变量 //作用：升序还是降序 //参数格式：字段+空格+asc(desc) protected String orderByClause; //作用：去除重复 //true是选择不重复记录，false，反之 protected boolean distinct; //自定义查询条件 //Criteria的集合，集合中对象是由or连接 protected List\u003cCriteria\u003e oredCriteria; //内部类Criteria包含一个Cretiron的集合， //每一个Criteria对象内包含的Cretiron之间是由 AND连接的 public static class Criteria extends GeneratedCriteria { protected Criteria() {super();} } //是mybatis中逆向工程中的代码模型 protected abstract static class GeneratedCriteria {......} //是最基本,最底层的Where条件，用于字段级的筛选 public static class Criterion {......} ","date":"2020-11-11 17:41:51","objectID":"/2020/11/mybatis/:2:2","tags":["MyBatis"],"title":"MyBatis","uri":"/2020/11/mybatis/"},{"categories":["框架","MyBatis"],"content":"Mapper接口中的方法解析 mapper接口中的函数及方法 方法 功能说明 int countByExample(UserExample example) thorws SQLException 按条件计数 int deleteByPrimaryKey(Integer id) thorws SQLException 按主键删除 int deleteByExample(UserExample example) thorws SQLException 按条件查询 String/Integer insert(User record) thorws SQLException 插入数据（返回值为ID） User selectByPrimaryKey(Integer id) thorws SQLException 按主键查询 ListselectByExample(UserExample example) thorws SQLException 按条件查询 ListselectByExampleWithBLOGs(UserExample example) thorws SQLException 按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生。 int updateByPrimaryKey(User record) thorws SQLException 按主键更新 int updateByPrimaryKeySelective(User record) thorws SQLException 按主键更新值不为null的字段 int updateByExample(User record, UserExample example) thorws SQLException 按条件更新 int updateByExampleSelective(User record, UserExample example) thorws SQLException 按条件更新值不为null的字段 ","date":"2020-11-11 17:41:51","objectID":"/2020/11/mybatis/:2:3","tags":["MyBatis"],"title":"MyBatis","uri":"/2020/11/mybatis/"},{"categories":["框架","MyBatis"],"content":"example实例解析 mybatis的逆向工程中会生成实例及实例对应的example，example用于添加条件，相当where后面的部分 xxxExample example = new xxxExample(); Criteria criteria = new Example().createCriteria(); 方法 说明 example.setOrderByClause(“字段名 ASC”); 添加升序排列条件，DESC为降序 example.setDistinct(false) 去除重复，boolean型，true为选择不重复的记录。 criteria.andXxxIsNull 添加字段xxx为null的条件 criteria.andXxxIsNotNull 添加字段xxx不为null的条件 criteria.andXxxEqualTo(value) 添加xxx字段等于value条件 criteria.andXxxNotEqualTo(value) 添加xxx字段不等于value条件 criteria.andXxxGreaterThan(value) 添加xxx字段大于value条件 criteria.andXxxGreaterThanOrEqualTo(value) 添加xxx字段大于等于value条件 criteria.andXxxLessThan(value) 添加xxx字段小于value条件 criteria.andXxxLessThanOrEqualTo(value) 添加xxx字段小于等于value条件 criteria.andXxxIn(List\u003c？\u003e) 添加xxx字段值在List\u003c？\u003e条件 criteria.andXxxNotIn(List\u003c？\u003e) 添加xxx字段值不在List\u003c？\u003e条件 criteria.andXxxLike(“%”+value+”%”) 添加xxx字段值为value的模糊查询条件 criteria.andXxxNotLike(“%”+value+”%”) 添加xxx字段值不为value的模糊查询条件 criteria.andXxxBetween(value1,value2) 添加xxx字段值在value1和value2之间条件 criteria.andXxxNotBetween(value1,value2) 添加xxx字段值不在value1和value2之间条件 ","date":"2020-11-11 17:41:51","objectID":"/2020/11/mybatis/:2:4","tags":["MyBatis"],"title":"MyBatis","uri":"/2020/11/mybatis/"},{"categories":["插件"],"content":"PageHelper 在实际项目开发中，常常需要使用到分页，分页的方式分为两种： 前端分页 后端分页 前端分页： 一次 ajax 请求数据的所有记录，然后在前端缓存并且计算 count 和分页逻辑，一般前端组件会提供分页动作。 特点：简单，很适合小规模的web平台；当数据量大的时候会产生性能问题，在查询和网络传输的时间会很长。 后端分页： 在 ajax 请求中指定页码 pageNum 和每页的大小 pageSize ，后端查询出当页的数据返回，前端只负责渲染。 特点：复杂一点；性能瓶颈来自于对数据库的压力。 ","date":"2020-11-11 16:32:38","objectID":"/2020/11/pagehelper%E7%9A%84%E4%BD%BF%E7%94%A8/:0:0","tags":["PageHelper"],"title":"PageHelper的使用","uri":"/2020/11/pagehelper%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["插件"],"content":"不使用分页插件的分页操作 查询 count 的 select 语句，然后再写一个真正分页查询语句，MySQL中有对分页的支持，是通过limit子句 limit关键字的用法是：LIMIT [offset], rows offset是相对首行的偏移量（首行是0），rows是返回条数 例如 // 查询的是前5条记录 select * from tableA limit 0, 5; // 查询的是第6条到第10条的记录 select * from tableA limit 5, 5 ","date":"2020-11-11 16:32:38","objectID":"/2020/11/pagehelper%E7%9A%84%E4%BD%BF%E7%94%A8/:0:1","tags":["PageHelper"],"title":"PageHelper的使用","uri":"/2020/11/pagehelper%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["插件"],"content":"MyBatis分页插件PageHelper使用 可在yml中配置： dialect：默认情况会使用PageHelper方式进行分页，如果想要实现自己的分页逻辑，可以实现 Dialect(com.github.pagehelper.Dialect) 接口，然后配置该属性为实现类的全限定名称。 pagehelper: auto-dialect: false 将自动配置关闭即可 使用自定义dialect实现时，下面参数没有任何作用： helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你也可以实现 AbstractHelperDialect，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。 offsetAsPageNum：默认值为 false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。 rowBoundsWithCount：默认值为false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true时，使用 RowBounds 分页会进行 count 查询。 pageSizeZero：默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。 reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum\u003c=0 时会查询第一页， pageNum\u003epages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。 params：为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。 supportMethodsArguments：支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest。 autoRuntimeDialect：默认值为 false。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择sqlserver2012，只能使用sqlserver），用法和注意事项参考下面的场景五。 closeConn：默认值为 true。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认true关闭，设置为 false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。 aggregateFunctions(5.1.5+)：默认为所有常见数据库的聚合函数，允许手动添加聚合函数（影响行数），所有以聚合函数开头的函数，在进行 count 转换时，会套一层。其他函数和列会被替换为 count(0)，其中count列可以自己配置。 重要提示： 当 offsetAsPageNum=false 的时候，由于 PageNum 问题，RowBounds查询的时候 reasonable 会强制为 false。使用 PageHelper.startPage 方法不受影响。 ","date":"2020-11-11 16:32:38","objectID":"/2020/11/pagehelper%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","tags":["PageHelper"],"title":"PageHelper的使用","uri":"/2020/11/pagehelper%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["插件"],"content":"PageHelper.startPage 静态方法调用 除了 PageHelper.startPage 方法外，还提供了类似用法的 PageHelper.offsetPage 方法。 在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 //获取第1页，10条内容，默认查询总数 count PageHelper.startPage(1, 10); //紧跟着的第一个select方法会被分页 Listlist = countryMapper.selectIf(1); assertEquals(2, list.get(0).getId()); assertEquals(10, list.size()); //分页时，实际返回的结果list类型是Page，如果想取出分页信息，需要强制转换为PageassertEquals(182, ((Page) list).getTotal()); ","date":"2020-11-11 16:32:38","objectID":"/2020/11/pagehelper%E7%9A%84%E4%BD%BF%E7%94%A8/:1:1","tags":["PageHelper"],"title":"PageHelper的使用","uri":"/2020/11/pagehelper%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["web"],"content":"什么是JWT 本质上它是一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。同时由于它是 JSON 格式的因此它的体积也很小。如果你想了解有关它的正式定义，可以在 RFC 7519 中找到。 ","date":"2020-11-10 16:52:25","objectID":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/:0:0","tags":["JWT"],"title":"什么是JWT","uri":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/"},{"categories":["web"],"content":"Session、Cookie、Token Cookie和Session的一个本质的区别就是，Session存在于服务端，而Cookie存在于客户端。Session的主要作用就是通过服务端记录用户的状态，Cookie数据保存在客户端（浏览器端）。 cookie是一个非常具体的东西，指的就是浏览器中能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。 cookie由服务器生成，发送给浏览器，浏览器吧cookie以key-value形式保留。 ","date":"2020-11-10 16:52:25","objectID":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/:1:0","tags":["JWT"],"title":"什么是JWT","uri":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/"},{"categories":["web"],"content":"Session 和 Cookie 的使用过程 每当用户登陆的时候，服务器验证通过后，会创建一个Session并将Session信息存储起来，同时服务器会向用户返回一个SessionId并写入用户Cookie，当用户登陆的时候，Cookie将与每个后续请求一起被发送出去，服务端可以将存储在Cookie上的SessionId与存储在内存或者数据库中的Session信息进行校对，以验证用户身份，返回给用户客户端响应信息的时候回附带用户当前对的状态。 但由于Cookie无法防止CSRF（Cross Site Request Forgery）攻击，因为访问的信息存储在Cookie中，可以被窃取，被窃取的SessionId可以被用来登录，因此产生危险。 ","date":"2020-11-10 16:52:25","objectID":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/:1:1","tags":["JWT"],"title":"什么是JWT","uri":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/"},{"categories":["web"],"content":"Token 同时为了避免用户数极大的情况下，数据库需要存储大量的SessionId进行校对，效率低下同时影响性能。Token诞生，所有数据都存在于客户端，每次用户请求服务的时候都带上JWT到服务端，服务端用同样的算法进行解密与请求的Token中的签名进行比较来进行认证。用token替换sessionid用CPU计算时间来换取存取sessionid的代价。 ","date":"2020-11-10 16:52:25","objectID":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/:1:2","tags":["JWT"],"title":"什么是JWT","uri":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/"},{"categories":["web"],"content":"JWT ","date":"2020-11-10 16:52:25","objectID":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/:2:0","tags":["JWT"],"title":"什么是JWT","uri":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/"},{"categories":["web"],"content":"实现思路 用户登录校验，校验成功返回token 客户端接收数据保存到客户端 客户端每次访问API是携带Token到服务端的 服务端采用filter过滤器校验，校验成功返回请求数据，校验失败返回错误码 ","date":"2020-11-10 16:52:25","objectID":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/:2:1","tags":["JWT"],"title":"什么是JWT","uri":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/"},{"categories":["web"],"content":"JWT数据结构 JWT token 的格式：xxxx.yyyy.zzzz 头信息（header） 负载（payload） 签名（signature） header中用于存放签名的生成算法 { \"alg\": \"HS512\", \"typ\": \"JWT\" } 上面代码中，alg属性表示签名的算法（algorithm））；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 payload中用于存放用户名、token的生成时间和过期时间 { \"sub\":\"admin\", \"created\":1489079981393, \"exp\":1489684781 } Registered claims iss（Issuer）：JWT签发者 created：（Create Time）：JWT创建时间 exp（Expiration Time）：JWT的过期时间（必须大于签发时间） sub（Subject）：JWT所面向的用户 aud（Audience）：接收JWT的一方 jti（JWT id）：JWT的身份标识，每个JWT的id都应该是不重复的，避免重复发放 Public claims Private claims signature为以header和payload生成的签名，一旦header和payload被篡改，验证将失败。三部分组成 base64UrlEncode（header） base64UrlEncode（payload） secret（服务器秘密字串） //secret为加密算法的密钥 String signature = HMACSHA512(base64UrlEncode(header) + \".\" +base64UrlEncode(payload),secret) ","date":"2020-11-10 16:52:25","objectID":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/:2:2","tags":["JWT"],"title":"什么是JWT","uri":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/"},{"categories":["web"],"content":"JWT实现认证和授权的原理 基于Token的身份验证是无状态的，不将用户信息存储在服务器中或者Session中。 用户调用登录接口，登录成功后获取到token 之后用户每次调用接口都在http的header中添加一个叫Authorization的头，值为JWT的token 后台程序通过对Authorization头中信息的解码及数字签名校验来获取其中用户信息，从而实现认证和授权 ","date":"2020-11-10 16:52:25","objectID":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/:2:3","tags":["JWT"],"title":"什么是JWT","uri":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/"},{"categories":["web"],"content":"实现 mall-security ├── component | ├── JwtAuthenticationTokenFilter -- JWT登录授权过滤器 | ├── RestAuthenticationEntryPoint -- 自定义返回结果：未登录或登录过期 | └── RestfulAccessDeniedHandler -- 自定义返回结果：没有权限访问时 ├── config | ├── IgnoreUrlsConfig -- 用于配置不需要安全保护的资源路径 | └── SecurityConfig -- SpringSecurity通用配置 └── util └── JwtTokenUtil -- JWT的token处理工具类 ","date":"2020-11-10 16:52:25","objectID":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/:2:4","tags":["JWT"],"title":"什么是JWT","uri":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/"},{"categories":["web"],"content":"JWT的几个特点 （1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 （2）JWT 不加密的情况下，不能将秘密数据写入 JWT。 （3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 （4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 （5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 （6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 ","date":"2020-11-10 16:52:25","objectID":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/:2:5","tags":["JWT"],"title":"什么是JWT","uri":"/2020/11/%E4%BB%80%E4%B9%88%E6%98%AFjwt/"},{"categories":["JVM"],"content":"虚拟机字节码执行引擎 ","date":"2020-11-06 11:14:41","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/:0:0","tags":["JVM"],"title":"虚拟机字节码执行引擎","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"},{"categories":["JVM"],"content":"简述时栈帧结构 栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行后背后的数据结构。 存储了方法的 局部变量表 操作数栈 动态连接 方法返回地址 一些额外的附加信息 ","date":"2020-11-06 11:14:41","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/:1:0","tags":["JVM"],"title":"虚拟机字节码执行引擎","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"},{"categories":["JVM"],"content":"局部变量表（Local Variables Table） 一组变量值的存储空间，存放方法的局部变量和方法参数。 局部变量的容量以变量槽（Variable Slot）为最小单位，一个变量槽可以存储一个32位以内的数据类型（随着计算机的处理、操作系统变化也可为64位）。Java中仅有long和double为8字节。 ","date":"2020-11-06 11:14:41","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/:1:1","tags":["JVM"],"title":"虚拟机字节码执行引擎","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"},{"categories":["JVM"],"content":"操作数栈（Operand Stack） 操作栈如同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须要严格保证这一点，在类校验阶段的数据流分析还要再次验证这一点。 Java虚拟机的解释执行引擎，里面的栈就是操作数栈。 ","date":"2020-11-06 11:14:41","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/:1:2","tags":["JVM"],"title":"虚拟机字节码执行引擎","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"},{"categories":["JVM"],"content":"动态连接 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用视为了支持方法调用过程中的动态连接（Dynamic Linking） ","date":"2020-11-06 11:14:41","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/:1:3","tags":["JVM"],"title":"虚拟机字节码执行引擎","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"},{"categories":["JVM"],"content":"方法返回地址 两种方式退出当前方法 执行引擎遇到任意一个方法返回的字节码指令 遇到异常 ","date":"2020-11-06 11:14:41","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/:1:4","tags":["JVM"],"title":"虚拟机字节码执行引擎","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"},{"categories":["JVM"],"content":"方法调用 方法调用不等同于方法中的代码被执行，方法调用的唯一阶段就是确定哪个方法被调用，暂时还未涉及方法内部的运行过程。 解析（resolve） 在类加载的解析阶段，会将其中的一部分符号引用转换为直接引用，这种解析能够成立的前提是：方法在程序真正执行之前就有一个确定的调用版本，并且该方法的调用版本在运行期是不可修改的。这类方法的调用称为 解析。 分派（Dispatch） 静态分配 静态分配和重载（Overload） package test; /** * Description: * 方法静态分配演示 * @author:edgarding * @date:2020/11/6 **/ public class StaticDispatch { static class Human { } static class Woman extends Human { } static class Man extends Human { } public void sayHello(Human guy) { System.out.println(\"this is human say\"); } public void sayHello(Woman guy) { System.out.println(\"this is woman say\"); } public void sayHello(Man guy) { System.out.println(\"this is man say\"); } public static void main(String[] args) { Human man = new Man(); Human woman = new Woman(); StaticDispatch staticDispatch = new StaticDispatch(); staticDispatch.sayHello(man); staticDispatch.sayHello(woman); } } 输出结果： this is human say this is human say 上面的“Human”称为变量的”静态类型“（Static Type）或者叫”外观类型“（Apparent Type），而后面的”man“或者”woman“称为变量的实际类型（Actual Type）或运行时类型（Runtime Type）。 静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅是在使用时发生的，变量本身的静态类型不会发生改变，并且最终的静态类型是在编译期可知的；而实际类型只有在运行期才可以确定，编译器在编译时并不知道一个对象的实际类型是什么。 如上述代码，在main（）方法中的两次sayHello（）方法的调用，在方法接收者已经确定是对象”staticDispatch“的前提下，使用哪个版本就完全取决于传入参数的数量和数据类型。 代码中故意定义了两个静态类型相同、实际类型不同的两个参数，但虚拟机（编译器）在重载的时候是通过参数的静态类型作为判断标准，而不是实际类型。 所有依赖静态类型来决定方法执行版本的分派动作都称为静态分配。静态分配的嘴典型应用表现就是方法重载。静态分配的动作实际上不是由JVM来决定而是编译器决定的，因此将静态分派的动作在一些资料中将其划入”解析“而不是”分派“的原因。 重载方法的优先级 Javac编译器虽然能确定出重载的版本，但在有些时候重载的版本不是唯一的，只能确定一个”相对合适的版本“。 package JVM; import java.io.Serializable; /** * Description: * * @author:edgarding * @date:2020/11/7 **/ public class OverLoad { public static void say(Character character) { System.out.println(\"Hello character\"); } public static void say(char arg) { System.out.println(\"Hello char\"); } public static void say(int arg) { System.out.println(\"Hello int arg\"); } public static void say(long arg) { System.out.println(\"Hello long arg\"); } public static void say(char... arg) { System.out.println(\"Hello char...\"); } public static void say(Serializable serializable) { System.out.println(\"Hello serializable\"); } public static void main(String[] args) { say('a'); } } 输出结果： Hello ch 由于’a’是一个char类型，所以自动会寻找参数为char的重载方法 如果注释掉say(char ch)，那么输出就变为 Hello int，这时发生了一次自动类型转换，将’a’转换为了97，因此自动寻参找int参数的方法。 如果在将 say(int arg)注释，那么会发生两次自动类型转换，97将转换成97L，会输出 Hello long。 如果 依次将其注释，其转换顺序为 char - int - long - float - double 进行匹配，但不会匹配到byte 和 short类型重载，因为char到byte或short是不安全的。 如果将基本类型的参数全部注释，后面的参数类型转换结果为 Hello Character Hello serializable 出现serializable的原因是java.lang.Serializable是java.lang.Character类的一个实现接口。 由此可知，重载的转换从子类向父类依次往上搜寻，这也是Java实现方法重载的本质。 动态分派 动态分配的一个重要体现——“重写（override） 运行期根据实际类型确定方法执行版本的过程称为动态分派。 通过字节码中发现invokevirtual是确定最终执行的目标方法。 它的执行步骤 找到操作数栈顶的第一个元素所执行的对象的 实际类型 ，记住C 如果在C中找到与常量中描述符合简单名称都相同你的方法，则进行访问校验，通过则返回方法的直接引用，否则抛出异常。 否则按照继承关系从下往上一次进行搜索 如果始终没有找到合适的方法则抛出 java.lang.AbstractMethodError 异常。 多态性的根源在于虚方法调用 invokevirtual 指令，但只对方法有效，对字段无效。 package JVM; /** * Description: * 字段无多态性 * @author:edgarding * @date:2020/11/7 **/ public class FieldHasNoPolymorphic { static class Father { public int money = 1; public Father() { money = 2; } public void showMoney() { System.out.println(\"Father's money:\" + money); } } static class Son extends Father{ public int money = 3; public Son() { money = 4; } @Override public void showMoney() { System.out.println(\"Son's money:\" + money); } } public static void main(String[] args) { Father guy = new Son(); System.out.println(\"this guy's money:\" + guy.money ); } } 输出结果： Son's money:0 Son's money:4 this guy's money:2 在进行 Father guy = new Son()时，首先会隐式调用了Father的构造函数，而Father构造函数中对showMoney()的调用是一次虚方法调用，实际执行的是Son::showMoney()方法，所以输出的是”Son’s money：0“，虽然这时候父类的money=2，但子类中money还没被进行初始化，只有要用到子类的构造函数执行时，才会被进行初始化。因此第一句 Son's money:0的由来就是如此。 第二句的 Son's money:4进行了子类的构造函数。 第三句，有main（）函数访问的是通过静态类型访问到了父类中money，输出了2。 虚函数：在运行的时候，系统根据对象的实际类型决定。即不使用final修饰的就是虚方法。 Java是一门静态多分派、动态单分派的语言。 单分派、多分派： 方法的接受者与方法的参数统称为方法的宗量。根据分派基于多少种宗量分为单分派和多分派。 动态类型语言 关键特征：类型检查的主体过程是在运行期而不是编译期运行的，如python、JavaScript、Ruby等","date":"2020-11-06 11:14:41","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/:2:0","tags":["JVM"],"title":"虚拟机字节码执行引擎","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"},{"categories":["学习路线"],"content":"学习路线-后 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:0:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"网络 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Internet work 怎么运作 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"HTTP 是什么 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Browsers 怎么运作 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"DNS 如何运作 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:4","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Domain Name 是什么 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:5","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"hosting 是什么 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:1:6","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"基本前端知识 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"HTML ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"CSS ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"JavaScript ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:2:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"操作系统 和 常识 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"终端的使用 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"操作系统如何运作的 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"程序管理 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"线程和并发 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:4","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"基本终端指令 grep、awk、sed、lsof、curl、wget、tail、head、less、find、ssh、kill ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:5","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"内存管理 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:6","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"进程之间的通信 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:7","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"I/O ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:8","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"POSIX Basics stdin、stdout、stderr、pipes ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:9","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"基本网络概念 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:3:10","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"一面语言 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"学习它的特性、核心细节、如何运行（并发、内存等） ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Java ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Python ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"C# ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:4","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"PHP ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:5","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"JavaScript ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:6","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Ruby ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:4:7","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"VCS ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:5:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Git的基本使用 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:5:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Repo hosting services ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:5:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"GitHub ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:5:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Relational Database ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:6:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"MySQL ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:6:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"MariaDB ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:6:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Oracle ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:6:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"More about Databases ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"NoSQL Databases MongoDB ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"ACID ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"ORMs ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Transactions事务 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:4","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"N + 1 Problem ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:5","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"数据库常识 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:6","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"索引 它们如何运作 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:7","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Data Replication（数据复制） ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:8","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Sharding Strategies（存储分区策略） ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:9","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"CAP Theorem（CAP 定理） ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:7:10","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"学习了解APIs ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"HATEOAS Hypermedia As The Engine Of Application State（REST服务中的一环） ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Open API Spec and Swagger描述Rest API的语言 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"权限认证 Authentication Cookie Based OAuth Basic Authentication Token Authentication JWT OEPNId SAML安全主张标记语言 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"REST read Roy fielding‘s paper ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:4","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"JSON APIs ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:5","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"SOAP（Simple Object access Protocol） ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:8:6","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Caching 缓存 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:9:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"CDN ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:9:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Server Side Redis Memcached ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:9:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Client Side ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:9:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"网络安全知识 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"MD5 为何使用 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"SHA family ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"scrypt bcryot ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"HTTPS ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:4","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Content Security Policy ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:5","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"CORS ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:6","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"SSL/TLS ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:7","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"开放式Web应用程序安全项目OWASP Security Risks ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:10:8","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"测试 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:11:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"单元测试 Unit Testing ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:11:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Functional Testing ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:11:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Integration Testing（集合测试） ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:11:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"CI/CD（持续集成和持续交付） ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:12:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"设计和开发原则 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"GOF 设计模式 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"SOLID 面向对象设计 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"KISS Keep It Simple \u0026 Stupid ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:3","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"YAGNI You ain’t Gonna Need it ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:4","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"DRY Don’t Repeat Yourself ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:13:5","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"搜索引擎 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:14:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Elasticsearch ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:14:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"solar ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:14:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Message Brokers ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:15:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"RabbitMQ ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:15:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Kafka ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:15:2","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"虚拟容器 ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:16:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"Docker ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:16:1","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["学习路线"],"content":"… ","date":"2020-11-06 09:59:12","objectID":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/:17:0","tags":["学习路线"],"title":"学习路线","uri":"/2020/11/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"categories":["设计模式"],"content":"抽象工厂模式（Abstract Factory） 在工厂模式中具体工厂负责具体产品，每个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般一个具体工厂只有一个工厂方法或者一组重载工厂方法。抽象工厂模式和工厂方法模式虽然主要意图都是为了解决接口选择问题，但实际上，抽象工厂是一个中心工厂，创建其它工厂的模式。 ","date":"2020-11-05 18:49:16","objectID":"/2020/11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"抽象工厂模式","uri":"/2020/11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 ","date":"2020-11-05 18:49:16","objectID":"/2020/11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"抽象工厂模式","uri":"/2020/11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 包含如下角色： AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：具体产品 Product：具体产品 ","date":"2020-11-05 18:49:16","objectID":"/2020/11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"抽象工厂模式","uri":"/2020/11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式应用 不同系统内的回⻋车换⾏ Unix系统⾥，每⾏结尾只有 \u003c换⾏\u003e，即 \\n ； Windows系统⾥⾯，每⾏结尾是 \u003c换⾏\u003e\u003c回⻋\u003e，即 Mac系统⾥，每⾏结尾是 \u003c回⻋\u003e ","date":"2020-11-05 18:49:16","objectID":"/2020/11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"抽象工厂模式","uri":"/2020/11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"总结 抽象⼯⼚模式，所要解决的问题就是在⼀个产品族，存在多个不同类型的产品(Redis集群、操作系 统)情况下，接⼝选择的问题。⽽这种场景在业务开发中也是⾮常多⻅见的，只不过可能有时候没有 将它们抽象化出来。 你的代码只是被ifelse埋上了！ 当你知道什么场景下何时可以被抽象⼯程优化代码，那么你的代码 层级结构以及满⾜业务需求上，都可以得到很好的完成功能实现并提升扩展性和优雅度。 那么这个设计模式满⾜了；单⼀职责、开闭原则、解耦等优点，但如果说随着业务的不断拓展，可 能会造成类实现上的复杂度。但也可以说算不上缺点，因为可以随着其他设计⽅式的引⼊和代理类 以及⾃动⽣成加载的⽅式降低此项缺点。 ","date":"2020-11-05 18:49:16","objectID":"/2020/11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"抽象工厂模式","uri":"/2020/11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["JVM"],"content":"虚拟机类加载机制 Java虚拟机把描述类的数据从Class问价加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用得当Java类型，这个过程称作虚拟机的类加载机制。 ","date":"2020-11-05 16:39:47","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/:0:0","tags":["JVM"],"title":"虚拟机类加载机制","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"categories":["JVM"],"content":"类加载的时机 类加载分为三个阶段：加载、连接、初始化 生命周期： 加载Loading 验证Verification 准备Perparation 解析Resolution 初始化Initialization 使用Using 卸载Unloading 连接Linking：3、4、5 其中前五部的顺序是确定的，类加载的过程必须按此顺序进行。 关于在什么时候需要开始类加载的第一个过程“Loading”，可以由虚拟机自由把握。但是对于初始化阶段，则是严格规定了有且只有六种情况必须立刻对类进行”初始化Initialization 何时触发初始化： 为一个类型创建一个新的对象实例时（比如new、反射、序列化） 调用一个类型的静态方法时（即在字节码中执行invokestatic指令） 调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式 调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法） 初始化一个类的派生类时（Java虚拟机规范明确要求初始化一个类时，它的超类必须提前完成初始化操作，接口例外） JVM启动包含main方法的启动类时。 ","date":"2020-11-05 16:39:47","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/:1:0","tags":["JVM"],"title":"虚拟机类加载机制","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"categories":["JVM"],"content":"类加载的过程 即加载、连接（验证、准备、解析）、初始化 ","date":"2020-11-05 16:39:47","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/:2:0","tags":["JVM"],"title":"虚拟机类加载机制","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"categories":["JVM"],"content":"加载 通过一个类的全限定名来获取定义类的二进制字节流 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 加载完毕后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区中。 ","date":"2020-11-05 16:39:47","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/:2:1","tags":["JVM"],"title":"虚拟机类加载机制","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"categories":["JVM"],"content":"验证 确保奥class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息当做代码运行后不会危害虚拟机自身安全。 文件格式验证 元数据验证 对字节码信息进行语义分析 字节码验证 主要目的是通过数据流分析和控制流分析，确定程序语义合法、符合逻辑的 符号引用验证 ","date":"2020-11-05 16:39:47","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/:2:2","tags":["JVM"],"title":"虚拟机类加载机制","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"categories":["JVM"],"content":"准备 准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始化值的阶段。在JDK1.7及之前，HotSpot使用永久代来实现方法区，而在JDK8及以后，类变量则会随着Class对象一起存放在Java堆中。 注意例如：public static int value = 123； value在准备阶段过后的初始值为0而不是123，因为在这时还未开始执行任何Java方法，而吧value赋值为123的putstatic命令是程序编译后，存放于类构造器 \u003cclinit\u003e()方法中，是在初始化阶段。 ","date":"2020-11-05 16:39:47","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/:2:3","tags":["JVM"],"title":"虚拟机类加载机制","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"categories":["JVM"],"content":"解析 解析阶段是Java虚拟机将常量池内符号引用替换为直接引用的过程。 **符号引用（Symbolic References）：**符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量。 **直接引用（Direct References）：**是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。 类或接口解析 字段解析 方法解析 接口方法解析 ","date":"2020-11-05 16:39:47","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/:2:4","tags":["JVM"],"title":"虚拟机类加载机制","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"categories":["JVM"],"content":"初始化 类的初始化阶段是类加载过程的最后一步，在之前的步骤中，除了在加载阶段用户应用程序可以通过自定义的类加载器的方式局部参与外，其余所有动作都完全有Java虚拟机来主导，直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权交给应用程序。 ","date":"2020-11-05 16:39:47","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/:2:5","tags":["JVM"],"title":"虚拟机类加载机制","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"categories":["JVM"],"content":"类加载器 ”通过一个类的完全限定类名来获取描述该类的二进制字节流“这个动作放到JVM外外部去实现，以便让应用程序自己去获取所需要的类。”实现这个动作的代码被称为：类加载器（Class Loader） ","date":"2020-11-05 16:39:47","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/:3:0","tags":["JVM"],"title":"虚拟机类加载机制","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"categories":["JVM"],"content":"类和类加载器 对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确定在Java虚拟机中的唯一性，每一个类加载器都有一个独立的类名成空间。 即通俗讲：比较两个类是否”相等“，只有在这两个类是由同一个类加载器的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，就不相等。 ","date":"2020-11-05 16:39:47","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/:3:1","tags":["JVM"],"title":"虚拟机类加载机制","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"categories":["JVM"],"content":"双亲委派模型（Parents Delefation Model） 站在Java虚拟机的角度来看，只有两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader）是虚拟机自身的一部分； 其它所有的类加载器，这些加载器都是由Java语言实现的，独立存在于虚拟机外部，并全部继承自抽象类java.lang.ClassLoader 站在Java开发人员角度来看，Class Loader应该被划分的更细致一点。 启动类加载器（Bootstrap Class Loader）：负责加载存放在 \u003cJAVA_HOME\u003e\\lib目录，或者被参数所指定的目录中，而且是Java虚拟机能够识别的。 拓展加载类（Extension Class Loader）：负责加载 \u003cJAVA_HOME\u003e\\lb\\ext目录中，或被系统变量所制定的路径中的所有类库。 应用程序加载类（Application Class Loader）：负载加载用户类路径 ClassPath中的所有类库。 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）关系来实现的，而是通常使用组合（Composition）来复用父类加载器代码。 工作流程 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成该加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。 好处是：Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。 ","date":"2020-11-05 16:39:47","objectID":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/:3:2","tags":["JVM"],"title":"虚拟机类加载机制","uri":"/2020/11/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"categories":["JVM"],"content":"类文件格式 ","date":"2020-11-05 16:17:24","objectID":"/2020/11/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/:0:0","tags":["JVM"],"title":"类文件结构","uri":"/2020/11/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"},{"categories":["JVM"],"content":"Class类文件的结构 Class文件类是一组由8个字节为基础单位的二进制流，各个数据项目按顺序紧凑地排列在文件中，中间没有任何分割符。使得整个Class文件中存储的内容几乎全是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在上的方式分割成若干个8个字节进行存储。 魔数：每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件。且这是四个字节的值为“0xCAFEBABE” ","date":"2020-11-05 16:17:24","objectID":"/2020/11/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/:0:1","tags":["JVM"],"title":"类文件结构","uri":"/2020/11/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"},{"categories":["Spring"],"content":"SpringSecurity 和 JWT 实现认证和授权 ","date":"2020-11-04 19:08:32","objectID":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:0:0","tags":["SpringSecurity"],"title":"SpringSecurity和JWT实现认证和授权","uri":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":["Spring"],"content":"SpringSecurity SpringSecurity 是一个强大可高度定制的认证和授权框架，对于Spring应用来说它是一套Web安全标准。SpringSecurity注重于为Java应用提供认证和授权功能，像所有Spring项目一样，它对自定义需求具有强大的拓展性。 ","date":"2020-11-04 19:08:32","objectID":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:1:0","tags":["SpringSecurity"],"title":"SpringSecurity和JWT实现认证和授权","uri":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":["Spring"],"content":"JWT JWT是JSON WEB TOKEN 的缩写，基于RFC7519标准定义的一种可安全传输的JSON对象，由于使用了数字签名，所以是可信任和安全的 ","date":"2020-11-04 19:08:32","objectID":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:2:0","tags":["SpringSecurity"],"title":"SpringSecurity和JWT实现认证和授权","uri":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":["Spring"],"content":"Hutool Hutool是一个丰富的Java开源工具包 ","date":"2020-11-04 19:08:32","objectID":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:2:1","tags":["SpringSecurity"],"title":"SpringSecurity和JWT实现认证和授权","uri":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":["Spring"],"content":"添加JWT token的工具类 用于生成和解析JWT token的工具类 相关方法： generateToken(UserDetails userDetails) :用于根据登录用户信息生成token getUserNameFromToken(String token)：从token中获取登录用户的信息 validateToken(String token, UserDetails userDetails)：判断token是否还有效 package common.utils; import cn.hutool.core.date.DateUtil; import cn.hutool.core.util.StrUtil; import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.beans.factory.annotation.Value; import org.springframework.security.core.userdetails.UserDetails; import java.util.Date; import java.util.HashMap; import java.util.Map; /** * JwtToken生成的工具类 * JWT token的格式：header.payload.signature * header的格式（算法、token的类型）： * {\"alg\": \"HS512\",\"typ\": \"JWT\"} * payload的格式（用户名、创建时间、生成时间）： * {\"sub\":\"wang\",\"created\":1489079981393,\"exp\":1489684781} * signature的生成算法： * HMACSHA512(base64UrlEncode(header) + \".\" +base64UrlEncode(payload),secret) * @author edgarding */ public class JwtTokenUtil { private static final Logger LOGGER = LoggerFactory.getLogger(JwtTokenUtil.class); private static final String CLAIM_KEY_USERNAME = \"sub\"; private static final String CLAIM_KEY_CREATED = \"created\"; @Value(\"${jwt.secret}\") private String secret; @Value(\"${jwt.expiration}\") private Long expiration; @Value(\"${jwt.tokenHead}\") private String tokenHead; /** * 根据负责生成JWT的token */ private String generateToken(Map\u003cString, Object\u003e claims) { return Jwts.builder() .setClaims(claims) .setExpiration(generateExpirationDate()) .signWith(SignatureAlgorithm.HS512, secret) .compact(); } /** * 从token中获取JWT中的负载 */ private Claims getClaimsFromToken(String token) { Claims claims = null; try { claims = Jwts.parser() .setSigningKey(secret) .parseClaimsJws(token) .getBody(); } catch (Exception e) { LOGGER.info(\"JWT格式验证失败:{}\", token); } return claims; } /** * 生成token的过期时间 */ private Date generateExpirationDate() { return new Date(System.currentTimeMillis() + expiration * 1000); } /** * 从token中获取登录用户名 */ public String getUserNameFromToken(String token) { String username; try { Claims claims = getClaimsFromToken(token); username = claims.getSubject(); } catch (Exception e) { username = null; } return username; } /** * 验证token是否还有效 * * @param token 客户端传入的token * @param userDetails 从数据库中查询出来的用户信息 */ public boolean validateToken(String token, UserDetails userDetails) { String username = getUserNameFromToken(token); return username.equals(userDetails.getUsername()) \u0026\u0026 !isTokenExpired(token); } /** * 判断token是否已经失效 */ private boolean isTokenExpired(String token) { Date expiredDate = getExpiredDateFromToken(token); return expiredDate.before(new Date()); } /** * 从token中获取过期时间 */ private Date getExpiredDateFromToken(String token) { Claims claims = getClaimsFromToken(token); return claims.getExpiration(); } /** * 根据用户信息生成token */ public String generateToken(UserDetails userDetails) { Map\u003cString, Object\u003e claims = new HashMap\u003c\u003e(); claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername()); claims.put(CLAIM_KEY_CREATED, new Date()); return generateToken(claims); } /** * 当原来的token没过期时是可以刷新的 * * @param oldToken 带tokenHead的token */ public String refreshHeadToken(String oldToken) { if(StrUtil.isEmpty(oldToken)){ return null; } String token = oldToken.substring(tokenHead.length()); if(StrUtil.isEmpty(token)){ return null; } //token校验不通过 Claims claims = getClaimsFromToken(token); if(claims==null){ return null; } //如果token已经过期，不支持刷新 if(isTokenExpired(token)){ return null; } //如果token在30分钟之内刚刷新过，返回原token if(tokenRefreshJustBefore(token,30*60)){ return token; }else{ claims.put(CLAIM_KEY_CREATED, new Date()); return generateToken(claims); } } /** * 判断token在指定时间内是否刚刚刷新过 * @param token 原token * @param time 指定时间（秒） */ private boolean tokenRefreshJustBefore(String token, int time) { Claims claims = getClaimsFromToken(token); Date created = claims.get(CLAIM_KEY_CREATED, Date.class); Date refreshDate = new Date(); //刷新时间在创建时间的指定时间内 if(refreshDate.after(created)\u0026\u0026refreshDate.before(Da","date":"2020-11-04 19:08:32","objectID":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:2:2","tags":["SpringSecurity"],"title":"SpringSecurity和JWT实现认证和授权","uri":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":["Spring"],"content":"添加SpringSecurity的配置类 package djj.fortuna.mall.config; import djj.fortuna.mall.componet.JwtAuthenticationTokenFilter; import djj.fortuna.mall.componet.RestAuthenticationEntryPoint; import djj.fortuna.mall.componet.RestfulAccessDeniedHandler; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.HttpMethod; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; /** * Description: * SpringSecurity的配置 * @author:edgarding * @date:2020/11/4 **/ @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) public class SpringSecurity extends WebSecurityConfigurerAdapter { @Autowired private RestfulAccessDeniedHandler restfulAccessDeniedHandler; @Autowired private RestAuthenticationEntryPoint restAuthenticationEntryPoint; @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().disable() // 由于使用JWT，因此不需要csrf .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 基于token，所以不需要session .and() .authorizeRequests() .antMatchers(HttpMethod.GET, // 允许对于网站静态资源的无授权访问 \"/\", \"/*.html\", \"/favicon.ico\", \"/**/*.html\", \"/**/*.css\", \"/**/*.js\", \"/swagger-resources/**\", \"/v2/api-docs/**\" ) .permitAll() .antMatchers(\"/admin/login\", \"/admin/register\") //对登陆和注册要允许匿名请求 .permitAll() .antMatchers(HttpMethod.OPTIONS) // 跨域请求会先进行一次options请求 .permitAll() //todo：测试时使用，记得注释掉 .antMatchers(\"/**\") .permitAll() .anyRequest() // 除上面外的所有请求全部需要鉴权认证 .authenticated(); // 禁用缓存 http.headers().cacheControl(); // 添加JWT filter http.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class); // 添加自定义未授权和未登陆结果返回 http.exceptionHandling() .accessDeniedHandler(restfulAccessDeniedHandler) .authenticationEntryPoint(restAuthenticationEntryPoint); } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Bean public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter() { return new JwtAuthenticationTokenFilter(); } @Override @Bean public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } } 相关依赖和方法说明 configure(HttpSecurity httpSecurity)：用于配置需要拦截的url路径、jwt过滤器及出异常后的处理器； configure(AuthenticationManagerBuilder auth)：用于配置UserDetailsService及PasswordEncoder； RestfulAccessDeniedHandler：当用户没有访问权限时的处理器，用于返回JSON格式的处理结果； RestAuthenticationEntryPoint：当未登录或token失效时，返回JSON格式的结果； UserDetailsService:SpringSecurity定义的核心接口，用于根据用户名获取用户信息，需要自行实现； UserDetails：SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限），需要自行实现； PasswordEncoder：SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder； JwtAuthenticationTokenFilter：在用户名和密码校验前添加的过滤器，如果有jwt的token，会自行根据token信息进行登录。 ","date":"2020-11-04 19:08:32","objectID":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:2:3","tags":["SpringSecurity"],"title":"SpringSecurity和JWT实现认证和授权","uri":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":["Spring"],"content":"补充 ","date":"2020-11-04 19:08:32","objectID":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:3:0","tags":["SpringSecurity"],"title":"SpringSecurity和JWT实现认证和授权","uri":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":["Spring"],"content":"如何获取当前登录的用户名 SecurityContextHolder + Authentication.getName() import org.springframework.security.core.Authentication; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.stereotype.Controller; import org.springframework.ui.ModelMap; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; @Controller public class LoginController { @RequestMapping(value=\"/login\", method = RequestMethod.GET) public String printUser(ModelMap model) { Authentication auth = SecurityContextHolder.getContext().getAuthentication(); String name = auth.getName(); //get logged in username model.addAttribute(\"username\", name); return \"hello\"; } //... SecurityContextHolder + User.getUsername() import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.userdetails.User; import org.springframework.stereotype.Controller; import org.springframework.ui.ModelMap; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; @Controller public class LoginController { @RequestMapping(value=\"/login\", method = RequestMethod.GET) public String printUser(ModelMap model) { User user = (User)SecurityContextHolder.getContext().getAuthentication().getPrincipal(); String name = user.getUsername(); //get logged in username model.addAttribute(\"username\", name); return \"hello\"; } //... UsernamePasswordAuthenticationToken This is more elegant solution, in runtime, Spring will injects UsernamePasswordAuthenticationToken into the Principal interface. import java.security.Principal; import org.springframework.stereotype.Controller; import org.springframework.ui.ModelMap; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; @Controller public class LoginController { @RequestMapping(value=\"/login\", method = RequestMethod.GET) public String printWelcome(ModelMap model, Principal principal ) { String name = principal.getName(); //get logged in username model.addAttribute(\"username\", name); return \"hello\"; } //... ","date":"2020-11-04 19:08:32","objectID":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:3:1","tags":["SpringSecurity"],"title":"SpringSecurity和JWT实现认证和授权","uri":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":["Spring"],"content":"Spring Security 什么是 Principal 了解用户是谁 注入Principal对象到controller 注入Authentication对象到controller 使用SecurityContextHolder来获取安全上下文 使用@AuthenticationPrincipal注解来标注方法 Principal 是指一个存储系统资源的实体（Entitiy），简单来说就是登入使用者。 但Principal与User的差别在于，Principal是一个可辨认的唯一身份。在安全验证的概念中，使用系统资源对象的概念可分为Subject，Principal及User。 ","date":"2020-11-04 19:08:32","objectID":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:3:2","tags":["SpringSecurity"],"title":"SpringSecurity和JWT实现认证和授权","uri":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":["Spring"],"content":"Spring security 注解 @EnableGlobalMethodSecurity Spring Security默认是禁用注解的，要想开启注解需要在继承WebSecurityConfigurerAdapter的类上加上@EnableGlobalMethodSecurity注解，来判断某个控制层的方法是否具有访问权限 ","date":"2020-11-04 19:08:32","objectID":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:3:3","tags":["SpringSecurity"],"title":"SpringSecurity和JWT实现认证和授权","uri":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":["Spring"],"content":"BCryptPasswordEncoder 浅谈使用springsecurity中的BCryptPasswordEncoder方法对密码进行加密(encode)与密码匹配(matches) spring security中的BCryptPasswordEncoder方法采用SHA-256 +随机盐+密钥对密码进行加密。SHA系列是Hash算法，不是加密算法，使用加密算法意味着可以解密（这个与编码/解码一样），但是采用Hash处理，其过程是不可逆的。 （1）加密(encode)：注册用户时，使用SHA-256+随机盐+密钥把用户输入的密码进行hash处理，得到密码的hash值，然后将其存入数据库中。 （2）密码匹配(matches)：用户登录时，密码匹配阶段并没有进行密码解密（因为密码经过Hash处理，是不可逆的），而是使用相同的算法把用户输入的密码进行hash处理，得到密码的hash值，然后将其与从数据库中查询到的密码hash值进行比较。如果两者相同，说明用户输入的密码正确。 这正是为什么处理密码时要用hash算法，而不用加密算法。因为这样处理即使数据库泄漏，黑客也很难破解密码（破解密码只能用彩虹表）。 ","date":"2020-11-04 19:08:32","objectID":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/:3:4","tags":["SpringSecurity"],"title":"SpringSecurity和JWT实现认证和授权","uri":"/2020/11/springsecurity%E5%92%8Cjwt%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/"},{"categories":["设计模式"],"content":"工厂模式 ","date":"2020-11-04 16:18:55","objectID":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"工厂模式","uri":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"简单工厂模式（Simple Factory Pattern） 考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。 有点类似于多态中的概念，同一行为在不同条件下有着不同的效果。 ","date":"2020-11-04 16:18:55","objectID":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"工厂模式","uri":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 简单工厂模式（Simple Factory Pattern）：又称静态工厂模式方法（Static Factory Method）模式。 即作用：在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都有共同的父类。 ","date":"2020-11-04 16:18:55","objectID":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:1","tags":["设计模式"],"title":"工厂模式","uri":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 Factory：工厂角色 负责实现创建所有实例的内部逻辑 Product：抽象产品角色 抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ConcreteProduct：具体产品角色 即创建目标，所有创建的对象都充当这个角色的某个具体类的实例 ","date":"2020-11-04 16:18:55","objectID":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:2","tags":["设计模式"],"title":"工厂模式","uri":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式应用 JDK类库广泛使用了简单工厂类，如工具类java.text.DateFormat，用于格式化时间 Java加密技术 ","date":"2020-11-04 16:18:55","objectID":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:3","tags":["设计模式"],"title":"工厂模式","uri":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"工厂方法模式（Factory Method Pattern） 现在对该系统进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。 ","date":"2020-11-04 16:18:55","objectID":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"工厂模式","uri":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 工厂方法模式又称工厂模式，也叫多态工厂（Polymorphic Factory）模式，工厂模式父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，将产品类实例化操作延迟到工厂子类中完成，由工厂子类确定应该实例化哪一个具体产品类。 ","date":"2020-11-04 16:18:55","objectID":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:1","tags":["设计模式"],"title":"工厂模式","uri":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂 ","date":"2020-11-04 16:18:55","objectID":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:2","tags":["设计模式"],"title":"工厂模式","uri":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"实例 日志记录器 ","date":"2020-11-04 16:18:55","objectID":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:3","tags":["设计模式"],"title":"工厂模式","uri":"/2020/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["网络"],"content":"SSL（Secure Socket Layer安全层套接层） ","date":"2020-11-03 20:13:46","objectID":"/2020/11/ssl/:0:0","tags":["SSL"],"title":"SSL","uri":"/2020/11/ssl/"},{"categories":["网络"],"content":"前言 什么是SSL，它与HTTPS中的联系？ SSL是一Secure Socket Layer，一种用于加密网络流量的加密协议。SSL处于TCP/IP模型中的应用层和传输层之间，它遵循PKCS（公钥加密标准）的客户端-服务器身份验证（通过握手和基于证书的身份验证完成），一旦建立了安全通道的消息通信（使用某些达成共识的加密标准来在发送端和接收端执行适当的加密/解密）。总之除非建立经过身份验证authenticated ，否则encrypted channel将关闭，无法进行消息通行。 HTTPS是应用层的协议在TCP/IP模型中，因此HTTPS通过SSL来进行加密。 ","date":"2020-11-03 20:13:46","objectID":"/2020/11/ssl/:1:0","tags":["SSL"],"title":"SSL","uri":"/2020/11/ssl/"},{"categories":["网络"],"content":"SSL证书 HTTPS核心的一个部分是数据传输之前的握手，握手过程确定了数据加密的密码。在握手过程中，网站会向浏览器发送SSL证书，SSL证书和我们日常用的身份证类似，是一个支持HTTPS网站的身份证明，SSL证书里面包含了网站的域名，证书的有效性，证书的颁发机构以及用于加密传输密码的公钥等信息，由于公钥加密的密码只能在申请证书生成的私钥解密，因此浏览器在生成密码之前需要先核对当前访问域名与证书上绑定的域名是否一致，同时还要对证书的颁发机构进行验证，如果验证失败，浏览器还会给出证书错误的提示。 ","date":"2020-11-03 20:13:46","objectID":"/2020/11/ssl/:2:0","tags":["SSL"],"title":"SSL","uri":"/2020/11/ssl/"},{"categories":["网络"],"content":"SSL协议的工作流程 客户端的浏览器向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机以及其他服务器与客户端之间通讯所需要的各种信息。 服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还向客户端传送自己的证书。 客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性：证书是否过期，发行服务器的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开，如果合法性验证通过，将继续进行第四步。 用户端随机产生一个用于后面通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的”预主密码“一起传给服务器。 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。 服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。 SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。 ","date":"2020-11-03 20:13:46","objectID":"/2020/11/ssl/:3:0","tags":["SSL"],"title":"SSL","uri":"/2020/11/ssl/"},{"categories":["网络"],"content":"TLS（传输层） TSL（传输层安全）是更为安全的升级版SSL。由于SSL这一术语更为常用，因此我们仍然将我们的安全证书称为SSL。 TSL/SSL 是一种加密通道的规范，它利用对称加密、公私钥不对称加密及其密钥交换算法，CA系统进行加密且可信任的信息传输在HTTP SSL中常用的对称加密算法RC4，AES，3DES等。 ","date":"2020-11-03 20:13:46","objectID":"/2020/11/ssl/:4:0","tags":["SSL"],"title":"SSL","uri":"/2020/11/ssl/"},{"categories":["网络"],"content":"SSL证书的安全问题 对HTTPS最常见的攻击手段就是SSL证书欺骗或者叫SSL劫持，是一种典型的中间人攻击。不过SSL劫持并非只是用于攻击目的，在一些特殊情况下利用SSL劫持我们可以更顺畅的访问网络，我会在后文提到。 以攻击为目的的SSL劫持如果不注意浏览器安全提示的话，很容易就中招。当网络中有中间人发起SSL劫持攻击时，攻击者需要伪造一个SSL证书发给浏览器，这个时候由于伪造的SSL证书不受信任，浏览器会给出提示。 这里有一个误区，当SSL证书不受信任的时候，并不一定就是有SSL劫持发生，有种例外情况是：一些个人网站买不起合法的SSL证书，因此会自己制作一个SSL证书来加密传输的数据。如果你经常访问某个个人网站，而且你知道这个网站是干什么的，那么这种情况可以不用担心。但是如果你访问的是网银，在线支付，或者是hotmail.com，gmail.com等，这类公司性质的网站一定会申请合法的SSL证书（12306.cn除外），一旦SSL证书不受信任，应该果断的终止访问，这个时候网络中一定会存在异常行为，对于一些小区宽带的用户一定要注意这点。 所以作为个人用户，你一定要知道你访问的是什么网站，如果你只是一个没有多少计算机只是的普通网民，我相信你不会经常上那些自己制作SSL证书的个人网站（12306.cn除外），因此如果你没有办法判断网络是不是有异常，只要是证书有问题的，干脆就别再访问了。 ","date":"2020-11-03 20:13:46","objectID":"/2020/11/ssl/:5:0","tags":["SSL"],"title":"SSL","uri":"/2020/11/ssl/"},{"categories":["数据库"],"content":"高性能MySQL 一条MySQL的更新语句的执行过程： ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:0:0","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"并发控制 共享锁（shared lock）读锁 排他锁（exclusive lock）写锁 在不同的搜索引擎下，写锁和读锁有着不同的优先级，写锁的优先级一般大于读锁。 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:1:0","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"事务 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:2:0","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"事务ACID **原子性（Atomicity）：**一个事务要么执行完成，要么失败回滚。 **一致性（consistency）：**数据库总是从一个一致性的状态转换到另一个一致性的状态。 **隔离性（isolation）：**一个事务所做的修改在最终提交之前，对其他事务是不可见的。 **持久性（durability）：**一旦事务提交，则其所做的修改就会永久保存到数据库中。 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:2:1","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"事务的隔离级别 读 未提交 读 已提交（不可重复读） 可重复读 REPEATABLE READ 可串行化 SERIALIZABLE ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:2:2","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"死锁 资源互相持有彼此的资源，并进行相互请求。 死锁的四个条件 互斥条件（加锁就是为了得到互斥，因此解决死锁问题只能从另外三个条件中进行解决） 请求与保持条件 不可剥夺条件 循环等待条件 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:2:3","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"事务日志 存储引擎在修改表的数据的时候只需要修改内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到硬盘。事务日志持久后，内存中被修改的数据可以慢慢刷回到磁盘，称预写式日志（Write-Ahead-Logging） ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:2:4","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"多版本并发控制 MMVC是行级锁的一个变种，很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。 MVCC的实现，是通过保存数据在某个时间点的快照来实现的，有乐观和悲观两种，只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:3:0","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"基准测试 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:4:0","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"两种主要策略 集成式full-stack：针对整个系统的整体测试 单件式single-component：单独测试MySQL ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:4:1","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"测试指标 吞吐量：单位时间内的事务处理数，测试单位是每秒事务数（TPS），或每分钟事务（TPM） 响应时间（通常也用来衡量一个数据库的性能） 并发性 可拓展性 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:4:2","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"基准测试方法 需要避免的一些常见错误： 使用真实数据的子集而不是全集 使用错误的数据分布 使用不真实的分布参数 在多用户场景中，只做单用户测试 在单服务器上测试分布式应用 与真实用户行为不匹配 反复执行同一个查询 没有检查错误 忽略了系统预热（warm up）的过程 使用默认的服务器配置 测试时间太短 2.应该建立将参数和结果文档化的规范，每一轮测试都必须进行详细记录 3.基准测试应该运行足够长的时间，需要在稳定状态下测试并观察 4.在执行基准测试时，需要尽可能多地收集被测试系统的信息 5.自动化基准测试可以防止测试人员偶尔遗漏某些步骤，或者误操作，另外也有助于归档整个测试过程，可以选择shell、php、perl等，要尽可能使所有测试过程都自动化，包括装载数据、系统预热、执行测试、记录结果等 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:4:3","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"服务器性能剖析 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:5:0","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"Schema 与数据类型优化 数据类型的选择原则 更小通常更好 简单就好 尽量避免NULL 对于性能的开销极小，但对于索引的创建，查询等，开销巨大 能用整数类型时，尽量使用整数类型，如IP地址等，因为字符串类型涉及道路字符集等，会有开销 varchar使用的合适情况：字符串列的最大长度比平均长度大很多；列更新很少，所以碎片不是问题；主要是删除时，会产生碎片垃圾，可以使用optimzation进行优化 对于定长char类型，适合存储很短的字符串，长度一定的字符串，如一些加密MD5等了，不容易产生碎片，在存储空间上更有效率 timestamp和datetime，前者为4个字节，后者8字节，开销不一样，但timestamp可显示的时间只能从1970~2038年，但有着动态时域，不同的地方时间会自动进行时域的加减，而datetime显示时间则很大。 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:6:0","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"范式和反范式 第一范式：对属性的原子性 第二范式：对记录的唯一性，即实体的唯一性，不存在部分依赖 第三范式：对字段的冗余性，要求任何字段不能由其他字段派生出来，要求字段没有冗余，即不存在传递依赖 1.范式的优点： * 范式化的更新操作通常比反范式化要快 * 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据 * 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快 * 很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句 2.范式化设计的缺点是通常需要关联 3.反范式的优点：避免关联，避免了随机I/O，能使用更有效的索引策略 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:6:1","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"缓存表和汇总表 1.有时提升性能最好的方法是同一张表中保存衍生的冗余数据，有时也需要创建一张完全独立的汇总表或缓存表 2.物化视图，MySQL并不原生支持，Flexviews 3.如果应用在表中保存计数器，则在更新计数器时可能踫到并发问题，创建一张独立的表存储计数器，可以帮助避免缓存失效 * 解决独立表并发问题可以建多行，根据id随机更新，然后统计时sum() * 按天或小时可以单独建行，旧时间可定时任务合并到统一的一行 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:6:2","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"加快ALTER TABLE操作的速度 两种方式 一是一台不提供服务的机器执行的ALTER TABLE 操作 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:6:3","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["数据库"],"content":"创建高性能的索引 A. 索引基础 索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列 ORM工具能够产生符合逻辑的、合法的查询，除非只是生成非常的查询，否则它很难生成适合索引的查询 在MySQL中，索引是在存储引擎层而不是服务器层实现的，所以，并没有统一的索引标准。 不同的存储引擎的索引的工作方式不一样，并不是所有的存储引擎都支持所有类型的索引。 ","date":"2020-11-03 19:42:51","objectID":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/:6:4","tags":["数据库"],"title":"高性能MySQL","uri":"/2020/11/%E9%AB%98%E6%80%A7%E8%83%BDmysql/"},{"categories":["网络"],"content":"TCP / IP ","date":"2020-11-01 11:31:23","objectID":"/2020/11/tcpip/:0:0","tags":["网络"],"title":"TCPIP","uri":"/2020/11/tcpip/"},{"categories":["网络"],"content":"三次握手的验证 过程 客户端–发送带有 SYN 标志的数据包–一次握手–服务端 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端 第一次握手：client什么都不能确认，server确认了对方发送正常，自己接受正常 第二次握手：client确认了：自己发送接收正常；server确认了：对方发送正常，自己接受正常 第三次握手：client确认了：自己发送、接受正常、对方发送、接受正常；server确认了：自己发送、接受正常，对方发送、接受正常 因此三次握手就能确定对方的收发正常。 ","date":"2020-11-01 11:31:23","objectID":"/2020/11/tcpip/:0:1","tags":["网络"],"title":"TCPIP","uri":"/2020/11/tcpip/"},{"categories":["网络"],"content":"四次挥手 断开一个 TCP 连接则需要“四次挥手”： 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号 服务器-关闭与客户端的连接，发送一个FIN给客户端 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 例子：举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。 详解 ","date":"2020-11-01 11:31:23","objectID":"/2020/11/tcpip/:0:2","tags":["网络"],"title":"TCPIP","uri":"/2020/11/tcpip/"},{"categories":["工具"],"content":"Chrome DevTools ","date":"2020-11-01 10:53:05","objectID":"/2020/11/chrome-devtools/:0:0","tags":["Chrome"],"title":"Chrome DevTools","uri":"/2020/11/chrome-devtools/"},{"categories":["工具"],"content":"网络面板 控件。控制功能 过滤器。可以控制在请求表中显示的内容。 概述。显示了何时检索资源的时间表。 请求表。列出检索的到的资源列表，默认按时间顺序排序。 摘要。告诉请求总数，传输数据量和加载时间等。 默认情况，“请求表”显示以下列。可以“添加”和“删除列”。 Name. The name of the resource. Status. The HTTP status code. Type. The MIME type of the requested resource. Initiator. The object or process that initiated the request. It can have one of the following values: Parser. Chrome’s HTML parser initiated the request. Redirect. An HTTP redirect initiated the request. Script. A script initiated the request. Other. Some other process or action initiated the request, such as the user navigating to a page via a link, or by entering a URL in the address bar. Size. 服务器提供的响应标头的组合大小（通常为几百个字节）加上响应正文。 Time. 从请求开始到响应中最后一个字节接收的总持续时间。 Timeline. “时间轴”列显示所有网络请求的可视瀑布。单击此列的标题将显示其他排序字段的菜单。 MIME（Mutipurpose Internet Mail Extensions）互联网标准 Headers：与资源关联的HTTP标头 Preview：JSON，图像和文本资源的预览 Response：HTTP响应数据（如果有） Timing：资源的请求生命周期的详细细分 ","date":"2020-11-01 10:53:05","objectID":"/2020/11/chrome-devtools/:1:0","tags":["Chrome"],"title":"Chrome DevTools","uri":"/2020/11/chrome-devtools/"},{"categories":["JVM"],"content":"JVM内存区域 由于Java不需要像C/C++一样为每个new操作去对应一个delete/free操作，不会出现内存泄漏和内存溢出问题，但正因如此，在出现此问题的时候，将会更加麻烦，因此我们需要了解虚拟机是如何使用内存的。 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:0:0","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"运行时的数据区域 JDK8之前： 线程共享： Heap Method Area Runtime Constant pool 线程私有： VM Stack Native Method Stack Program Counter Register JDK8： 线程共享： Heap 元空间Metaspace 直接内存 Direct Memory 线程私有： VM Stack Native Method Stack Program Counter Register ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:1:0","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"Program Counter Register 程序计数器 程序计数器是一块小的内存空间，可以认为是当前线程所执行字节码的行号指示器。 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 作用： 字节码解释器通过程序计数器来保证指令的顺序读取，从而实现代码的流程控制。 在多线程情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道上次线程所运行的位置。 程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，生命周期随着线程的创建而创建，随着线程的结束而死亡。 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:1:1","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"虚拟机栈 于程序计数器一样，Java虚拟机栈线程私有，生命周期与线程相同，描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。 Java内存可粗糙分为，堆内存Heap和栈内存Stack，即栈就是指虚拟机栈，或是虚拟机中局部变量表的部分。（实际上，Java虚拟机栈是由一个一个栈帧组成，而每个栈帧中拥有：局部变量表、操作数表、动态链接、方法出口信息） 局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char等等）、对象引用（reference类型，是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置） Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。 StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。 OutOfMemoryError： 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。 Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。 那么方法和函数如何调用 Java栈可用相当于数据结构中的栈，Java栈中保存的内容主要是栈帧，每一次函数调用都会有一儿栈帧被压入Java栈，每一个函数结束，会有一个栈帧被弹出。 两种返回方式： return 抛出异常 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:1:2","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"本地方法栈 Native Method Stack 与虚拟机栈相类似，区别是： 虚拟机栈为虚拟机执行Java方法（即字节码）服务，而本地方法栈则为虚拟机使用的到Native方法服务器 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:1:3","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"堆 Heap JVM所管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在JVM启动时创建。 唯一目的就是存放对象实例，几乎所有对象实例和数组都在这分配内存。 Java中”几乎“所有对象都在堆中分配，但是，随着JIT编译期的发展和逃逸分析的技术成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。 在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分： 新生代内存(Young Generation) 老生代(Old Generation) 永生代(Permanent Generation) JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。 大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者s1，并且对象的年龄还会增加1（Eden区-\u003eSurvivor区后对象的初始年龄变为1）当它的年龄增加到了一定程度（默认为15岁）就会被升到老年代中。对象晋升到老年代的年龄阈值，可以通过 -XX：MaxTenuringThreshold来设置。 修正：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。 动态年龄计算的代码如下 uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) { //survivor_capacity是survivor空间的大小 size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100); size_t total = 0; uint age = 1; while (age \u003c table_size) { total += sizes[age];//sizes数组是每个年龄段对象大小 if (total \u003e desired_survivor_size) break; age++; } uint result = age \u003c MaxTenuringThreshold ? age : MaxTenuringThreshold; ... } 堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如： OutOfMemoryError: GC Overhead Limit Exceeded ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。 java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发java.lang.OutOfMemoryError: Java heap space 错误。(和本机物理内存无关，和你配置的内存大小有关！) …… ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:1:4","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"方法区 方法区也与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态常量、即使编译器编译后的代码等数据。 方法区也被称为 永久代。 方法区和永久代的关系 《Java虚拟机规范》只是规定了有方法区这个概念和它的作用，并没有规定如何去实现它。那么在不同的JVM上方法区的实现肯定不同。 方法区和永久代的关系类似于Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。 即永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其它的虚拟机实现并没有永久代这一说。 常用参数 JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小 -XX:PermSize=N //方法区 (永久代) 初始大小 -XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen 相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。 JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。 下面是一些常用参数： -XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小） -XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小 为什么要将永久代（PermGen）替换为元空间（MetaSpace） 整个永久代有一个JVM本身设置固定大小上限，无法调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。 当你元空间溢出时会得到如下错误： java.lang.OutOfMemoryError: MetaSpace 你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。 元空间里面放的是类的元数据，这样加载多少类的元数据就不由MaxPerSize控制了，而由系统的实际空间来控制，这样能加载的类就更多了。 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:1:5","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"运行时常量池 运行时常量池时方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息，还有常量池表（用于存放编译器生成的各种字面量和符号引用） 既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemory。 JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代 JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代 。 JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace) ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:1:6","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"直接内存 直接内存并不是虚拟机运行时数据区对的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OOM错误 JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。 本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:1:7","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"HotSpot 虚拟机对象探秘 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:2:0","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"对象的创建 类加载检查 分配内存 初始化零值 设置对象头 执行init方法 Step1 类加载检查 虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能够在常量池中定位到这个类的符号引用，并且检查引用代表的类是否已经被加载过、解析过和初始化过。如果没有，必须先执行相应的类加载过程。 Step2 分配内存 在类加载检查后，接下来虚拟机将为新生对象分配对象。对象所需的内存大小，在类加载完成后便可确定，为对象空间的任务等同于把一块确定大小的内存够从Java堆中划分出来。 分配方式有 指针碰撞 和 空闲列表，选择哪种方式，由Java堆是否规整决定，而Java堆是否规整由GC是否带有压缩整理功能决定（标记-清除和标记-清理）。 指针碰撞 **适合场景：**堆内存规整（即没有内存碎片）的情况 **原理：**用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。 **GC收集器：**Serial、ParNew 空闲列表 **适用场景：**堆内存不规整的情况下 **原理：**虚拟机会维护一个列表，该列表会记录哪些内存块是可用的，在分配的时候，找一块足够大的内存来划分给对象实例，最后更新列表。 **GC收集器：**CMS 内存并发问题 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事，作为虚拟机必须保证线程安全，通常来讲，有两种方式： CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配 Step3 初始化零值 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步保证了对象实例字段在Java代码中可以不赋值就直接使用。 Step4 设置对象头 初始化零值后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的hashcode、对象的GC分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如果是否使用偏向锁，对象头会有不同的设置。 Step5 执行init方法 上述步骤完成后，从虚拟机来看，一个新的对象已经产生，但从Java程序角度来看，对象创建才刚开始 init方法还没有执行，所有字段都还为0。所以一般来说，执行new指令后会接着执行init方，把对象按照程序员的意愿将对象进行初始化。 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:2:1","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"对象的内存布局 在HotSpot虚拟机中，对象在内存中的布局可以分为：对象头、实例数据、对齐填充 HotSpot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（hashcode、GC分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据指针，虚拟机通过该指针来确定这个对象是哪个类的实例。 实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。 **对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。**因为HotSpot虚拟机的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:2:2","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"对象的访问定位 建立对象就是为了使用对象，我们Java程序通过栈上的reference数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问有两种： 使用句柄 直接指针 句柄： 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息； **直接指针：**如果使用直接指针访问。那么Java堆对象的布局必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。 这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。 对象类型数据：虚拟机加载的类信息加载的类信息 对象实例数据：被new出来的对象信息 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:2:3","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"重点补充 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:3:0","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"String类和常量池 String str1 = \"abcd\";//先检查字符串常量池中有没有\"abcd\"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向\"abcd\"\"； String str2 = new String(\"abcd\");//堆中创建一个新的对象 String str3 = new String(\"abcd\");//堆中创建一个新的对象 System.out.println(str1==str2);//false System.out.println(str2==str3);//false 这两种不同的创建方法是有差别的。 第一种方式是在常量池中拿对象； 第二种方式是直接在堆内存空间创建一个新的对象。 记住一点：只要使用 new 方法，便需要创建新的对象。 String 类型的常量池比较特殊。它的主要使用方法有两种： 直接使用双引号声明出来的 String 对象会直接存储在常量池中。 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。 String s1 = new String(\"计算机\"); String s2 = s1.intern(); String s3 = \"计算机\"; System.out.println(s2);//计算机 System.out.println(s1 == s2);//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象， System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象 字符串拼接: String str1 = \"str\"; String str2 = \"ing\"; String str3 = \"str\" + \"ing\";//常量池中的对象 String str4 = str1 + str2; //在堆上创建的新的对象 String str5 = \"string\";//常量池中的对象 System.out.println(str3 == str4);//false System.out.println(str3 == str5);//true System.out.println(str4 == str5);//false 尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:3:1","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"String s1 = new String(“abc”);这句话创建了几个字符串对象？ 将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。 验证： String s1 = new String(\"abc\");// 堆内存的地址值 String s2 = \"abc\"; System.out.println(s1 == s2);// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。 System.out.println(s1.equals(s2));// 输出 true 结果： false true ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:3:2","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["JVM"],"content":"8种基本类型的包装类和常量池 Java基本类型的包装类大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。 为啥把缓存设置为[-128，127]区间？性能和资源之间的权衡。 public static Boolean valueOf(boolean b) { return (b ? TRUE : FALSE); } private static class CharacterCache { private CharacterCache(){} static final Character cache[] = new Character[127 + 1]; static { for (int i = 0; i \u003c cache.length; i++) cache[i] = new Character((char)i); } } 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。 Integer i1 = 33; Integer i2 = 33; System.out.println(i1 == i2);// 输出 true Integer i11 = 333; Integer i22 = 333; System.out.println(i11 == i22);// 输出 false Double i3 = 1.2; Double i4 = 1.2; System.out.println(i3 == i4);// 输出 false Integer 缓存源代码： /** *此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。 */ public static Integer valueOf(int i) { if (i \u003e= IntegerCache.low \u0026\u0026 i \u003c= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 应用场景： Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。 Integer i1 = new Integer(40);这种情况下会创建新的对象。 Integer i1 = 40; Integer i2 = new Integer(40); System.out.println(i1==i2);//输出 false Integer 比较更丰富的一个例子: Integer i1 = 40; Integer i2 = 40; Integer i3 = 0; Integer i4 = new Integer(40); Integer i5 = new Integer(40); Integer i6 = new Integer(0); System.out.println(\"i1=i2 \" + (i1 == i2)); System.out.println(\"i1=i2+i3 \" + (i1 == i2 + i3)); System.out.println(\"i1=i4 \" + (i1 == i4)); System.out.println(\"i4=i5 \" + (i4 == i5)); System.out.println(\"i4=i5+i6 \" + (i4 == i5 + i6)); System.out.println(\"40=i5+i6 \" + (40 == i5 + i6)); 结果： i1=i2 true i1=i2+i3 true i1=i4 false i4=i5 false i4=i5+i6 true 40=i5+i6 true 解释： 语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。 ","date":"2020-10-30 11:52:44","objectID":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/:3:3","tags":["JVM"],"title":"JVM内存区域","uri":"/2020/10/jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"},{"categories":["进阶"],"content":"Elasticsearch Elasticsearch是一个基于Lucene库的搜索引擎。提供了一个分布式，支持多租户的全文搜索引擎，具有HTTP Web接口和无模式JSON文档。 Lucene库是一套用于全文检索和搜索的开放源码程序库，提供了一个简单却强大的应用程序接口，能够做全文索引和搜索。 ","date":"2020-10-30 00:07:26","objectID":"/2020/10/elasticsearch/:0:0","tags":["Elasticsearch"],"title":"Elasticsearch","uri":"/2020/10/elasticsearch/"},{"categories":["进阶"],"content":"概述 Elasticsearch 与传统的 SQL数据库的一个明显的不同点是，Elasticsearch 是一个 非结构化 的数据库，或者说是一个 无模式 的数据库。 Elasticsearch 中数据最重要的三要素当属：索引、类型、文档。 其中索引这个概念非常重要，我们可以粗略地将其类比到传统SQL数据库中的 数据表。本文就从 Elasticsearch 的索引映射如何配置开始讲起。 ","date":"2020-10-30 00:07:26","objectID":"/2020/10/elasticsearch/:1:0","tags":["Elasticsearch"],"title":"Elasticsearch","uri":"/2020/10/elasticsearch/"},{"categories":["进阶"],"content":"基本概念 ","date":"2020-10-30 00:07:26","objectID":"/2020/10/elasticsearch/:2:0","tags":["Elasticsearch"],"title":"Elasticsearch","uri":"/2020/10/elasticsearch/"},{"categories":["进阶"],"content":"Node 与 Cluster Elastic 本质是一个分布式数据库，允许多台服务器协同工作，每台服务器可运行多个Elastic实例。 单个Elastic实例称为一个Node，一组Node构成一个Cluster（集群） ","date":"2020-10-30 00:07:26","objectID":"/2020/10/elasticsearch/:2:1","tags":["Elasticsearch"],"title":"Elasticsearch","uri":"/2020/10/elasticsearch/"},{"categories":["进阶"],"content":"Index Elastic会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。 因此，Elastic数据管理的顶层单位就叫做Index（索引）。它是一个单个数据库的同义词。每个Index（即数据库）的名字必须是小写。 下面的命令可以查看当前节点的所有 Index。 $ curl -X GET 'http://localhost:9200/_cat/indices?v' ","date":"2020-10-30 00:07:26","objectID":"/2020/10/elasticsearch/:2:2","tags":["Elasticsearch"],"title":"Elasticsearch","uri":"/2020/10/elasticsearch/"},{"categories":["进阶"],"content":"Document Index里面的单条记录称为Document（文档），许多Document构成一个Index。 Documet 使用JSON格式表示，例： { \"user\": \"djj\", \"age\": \"21\", \"phone\": \"1511234xxxx\" } 同一index里面的Document，不要求有相同的结构scheme，但是最好保持相同，有助于提高效率。 ","date":"2020-10-30 00:07:26","objectID":"/2020/10/elasticsearch/:2:3","tags":["Elasticsearch"],"title":"Elasticsearch","uri":"/2020/10/elasticsearch/"},{"categories":["进阶"],"content":"Type Document 可以分组，比如weather这个index里面，可以按城市分组（上海、深圳），也可以按气候（晴天、雨天）。按照虚拟逻辑来进行分组，用来过滤Document。 不同你的Type应该有相似的结构scheme，例 ","date":"2020-10-30 00:07:26","objectID":"/2020/10/elasticsearch/:2:4","tags":["Elasticsearch"],"title":"Elasticsearch","uri":"/2020/10/elasticsearch/"},{"categories":["Linux"],"content":"Linux常用命令 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:0:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"查看目录以及权限 在Linux中，通常 ls -l列出，其中可以查看文件属性，所属用户组等较为详细的信息。 [edgarding@localhost ~]$ ls -l 总用量 0 drwxrwxr-x. 2 edgarding edgarding 6 10月 29 22:52 perl5 drwxrwxr-x. 2 edgarding edgarding 92 10月 25 14:25 unix_exp drwxr-xr-x. 2 edgarding edgarding 6 7月 28 12:45 公共 drwxr-xr-x. 2 edgarding edgarding 6 7月 28 12:45 模板 drwxr-xr-x. 2 edgarding edgarding 6 7月 28 12:45 视频 drwxr-xr-x. 2 edgarding edgarding 6 7月 28 12:45 图片 drwxr-xr-x. 2 edgarding edgarding 6 7月 28 12:45 文档 drwxr-xr-x. 2 edgarding edgarding 6 7月 28 12:45 下载 drwxr-xr-x. 2 edgarding edgarding 6 7月 28 12:45 音乐 drwxr-xr-x. 4 edgarding edgarding 36 10月 25 14:34 桌面 第一列 第一个字段 文件类型，后面9个字符是模式，其中分为三组，每一个组三个字段。 用户权限 所属组权限 其他用户权限 r（read）代表可读 w（write）代表可写 e（execute）代表可执行 如果“-”代表没有权限。 -rw-r-r–:为普通文件，对于所属用户可读可写不能执行，对于所属组仅仅可读，对于其他用户可查。 第二列 硬链接数目 硬链接允许作用之一是允许一个文件拥有多个有效路径名，从而防止误删。但是只能在同一文件系统中的文件之间进行连接，不能对目录进行创建。 第三列是所属用户，第四列为所属组，第五列为文件大小，第六列为文件被修改的时间，最后为文件名。其中使用chown改变所属用户，chgrp改变所属组。 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:1:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"Nohup (no hang up 不要挂起的意思) 这也是常用的后台启动程序的常用方法，如果交互命令行中运行程序，我们就很容易终止它。在交互环境下，我们输出一般都是直接输出到当前界面，在后台启动的时候通常都会定向到文件，通常都是下面这个命令 nohup command \u003eX.file 2 \u003e\u00261 \u0026 其中1表示标准输出。2表示文件标准错误输出。2\u003e1\u0026即将两者合并，合并到X.file ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:2:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"查看进程 有的时候我们需要查看进程是否已经启动或者尝试终止进程。经常使用的命令为ps -ef列出当前正在运行的程序，那如何定位我们想要查看的进程A，这个时候使用grep，即ps -ef| grep A. ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:3:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"awk ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:4:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"tar解压缩 解压缩命令 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:5:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"常用参数 -c：创建的tar文件 -x：解开tar文件 -t：列出tar文件中包含的文件信息 -r：附加新的文件到tar文件中 常用命令组合 tar -xvf /home/a.tar //打开tar打包文件 tar -zxvf /home/a.tar.gz //解压以gzip压缩的文件 tar -jxvf /home/a.tar.bz2 //解压以bzip压缩的文件 tar -cvf /home/a.tar /home 打包/home下所有文件 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:5:1","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"scp 通过scp命令在多台服务器中相互复制传输文件。为了省下输入密码，可以设置免密登陆。 常用组合： 例子1：将A服务器中/home/a.txt 复制到B服务器的/home中 scp -r /home/a.txt root@B_ip:/home ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:6:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"rm 删除 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:7:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"watch 这个命令是动态查看命令执行的结果。比如如果需要每隔一秒高亮显示网络连接数的变化情况。则 watch -n 1 -d netstat -ant 例子：每隔一秒高亮显示http连接数的变化情况 watch -n 1 -d ‘pstree | grep http’ 例子:十秒一次输出系统的平均负载 watch -n 10 ‘cat /proc/loadavg’ ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:8:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"df 查看磁盘大小 df -h [edgarding@localhost ~]$ df -h 文件系统 容量 已用 可用 已用% 挂载点 devtmpfs 470M 0 470M 0% /dev tmpfs 487M 0 487M 0% /dev/shm tmpfs 487M 8.6M 478M 2% /run tmpfs 487M 0 487M 0% /sys/fs/cgroup /dev/mapper/centos-root 17G 6.3G 11G 37% / /dev/sda1 1014M 173M 842M 17% /boot tmpfs 98M 28K 98M 1% /run/user/1000 /dev/sr0 4.5G 4.5G 0 100% /run/media/edgarding/CentOS 7 x86_64 vmhgfs-fuse 466G 291G 176G 63% /mnt/hgfs ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:9:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"tcpdump 和它类似的工具在windows中是wireshark，其采用底层库winpcap/libpcap实现。采用了bpf过滤机制。下面我们看看提供的不同参数的含义。 参数名 含义 -n 使用IP地址表示主机。使用数字表示端口 -i 指定要监听的端口。如果为\"-i any\"表示住区所有网卡数据包 -v 输出诸如ip数据包中的TTL更加详细的信息 -t 不打印时间戳 -e 显示以太网帧头部信息 -c 仅仅抓取指定数量的数据包 -x 按照十六进制显示数据包内容 -X 不仅仅输出-x结果还输出十六进制对应的ASCII字符 -s 设置抓包时的抓包长度 -w 将输出结果定向到某个文件，一般为pcap后缀 -r 从文件读取数据包并显示数字表示端口 -i 指定要监听的端口。如果为\"-i any\"表示住区所有网卡数据包 -v 输出诸如ip数据包中的TTL更加详细的信息 -t 不打印时间戳 -e 显示以太网帧头部信息 -c 仅仅抓取指定数量的数据包 -x 按照十六进制显示数据包内容 -X 不仅仅输出-x结果还输出十六进制对应的ASCII字符 -s 设置抓包时的抓包长度 -w 将输出结果定向到某个文件，一般为pcap后缀 -r 从文件读取数据包并显示 知道了相关参数，下面看几个案例 执行任务 执行命令 捕获特定网口数据包 tcpdump -i eth0 捕获特定个数(1000)的包 tcpdump -c 1000 -i eth0 将捕获的包保存到文件 tcpdump -w a.pcap -i eth0 读取pcap格式的包 tcpdump -r a.pcap 增加捕获包的时间戳 tcpdump -n -ttt -i eth0 指定捕获包的协议类型 tcpdump -i eth0 arp 捕获指定端口 tcpdump -i eth0 post 22 捕获特定目标ip+port的包 tcpdump -i eth0 dst address and port 22 捕获DNS请求和响应 tcpdump -i eth0 -s0 port 53 匹配Http请求头 tcpdump -s 0 -v -n -l | egrep -i “POST /|GET /|Host:” 将捕获的包保存到文件 tcpdump -w a.pcap -i eth0 读取pcap格式的包 tcpdump -r a.pcap 增加捕获包的时间戳 tcpdump -n -ttt -i eth0 指定捕获包的协议类型 tcpdump -i eth0 arp 捕获指定端口 tcpdump -i eth0 post 22 捕获特定目标ip+port的包 tcpdump -i eth0 dst address and port 22 捕获DNS请求和响应 tcpdump -i eth0 -s0 port 53 匹配Http请求头 tcpdump -s 0 -v -n -l | egrep -i “POST /|GET /|Host:” ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:10:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"lsof 列出当前系统打开的文件描述符工具。可以得知感兴趣的描述符是被哪些进程使用 参数 描述 -i 显示sokcet文件描述符 -c 显示指定的命令打开的所有文件描述符 -t 仅显示打开了目标文件描述符的进程pid 执行任务 命令 列出所有的网络链接 lsof -i 列出所有udp的网络链接 lsof -i udp 列出谁在使用某个端口 lsof -i :3306 列出谁在使用特定的tcp端口 lsof -i tcp:80 根据文件描述范围列出文件信息 lsof -d 2-3 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:11:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"nc nc–\u003e“瑞士军刀”。不知大家在渗透过程中，拿了shell有没有使用nc搞点事儿。它用来快速构建网络链接。常用来调试客户端程序。 参数 描述 -i 设置数据包传送的时间间隔 -l 以服务器方式运行。默认为客户端运行 -k 重复接受并处理某个端口上的所有链接 -p 以客户端运行时强制其使用指定端口 -C 将CR和LF两个字符作为结束符 -u 使用udp协议。默认tcp协议 -X nc客户端余代理服务器通信时默认为socks5协议。 -z 扫描目标机器某个范围服务是否开启 小贱上案例 执行任务 执行命令 扫描机器A端口号在30-40的服务 nc -z A 30-40 连接服务器A 端口号为5000 nc -C A 5000 传送文件 MachineA:nc -v -n ip portE:\\a.exe ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:12:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"netstat netstat是一个网络信息统计工具。它可以得到网卡接口上全部了解，路由表信息，网卡接口信息等。通常在网络编程中我们用它来显示TCP连接以及状态信息。 参数 描述 -n 使用IP地址表示主机 -a 显示结果中包含监听的socket -t 仅显示TCP连接 -r 显示路由信息 -i 显示网卡接口数据流量 -c 每隔1s输出一次 -o 显示socket定时器的信息 -p 显示socket所属的进程的PID和名字 下面列举几个常用例子 执行任务 执行命令 列出所有连接 netstat -a 只列出TCP或者UDP netstat -at/netstat -au 列出监听中的连接 netstat -tnl 获取进程名、进程号以及用户 ID nestat -nlpt 打印统计信息 netstat -s netstat持续输出 netstat -ct 打印active状态的连接 netstat -atnp | grep ESTA 查看服务是否运行(npt) netstat -aple| grep ntp vmstat vmstat能够实时输出系统的进程信息，内存使用，cpu使用等资源的使用情况 参数 描述 -f 显示系统自启动以来执行的fork次数 -s 显示内存相关统计信息 -d 显示磁盘相关统计信息 -p 显示指定磁盘分区统计信息 count 采样次数。 字段名 描述 procs r表示等待运行的而进程数目。b表示处于不可中断睡眠状态的进程数目 memory swpd：使用的虚拟内存量。free：空闲内存量。buff：用作缓冲区的内存量。cache：用作缓存的内存量。 swap si：从磁盘换入的内存量（/s）。so：交换到磁盘的内存量（/s）。 io bi：从块设备接收的块（blocks/s）。bo：发送到块设备的块（blocks/s）。 system in：每秒中断的次数，包括时钟。cs：每秒上下文切换的次数。 这里注意哈，如果查看磁盘的更加详细信息，有另外iostat所得到的信心就更加详细哟 mpstat 能够实时监测多处理器系统中各个cpu的使用情况。这个命令的执行需要安装sysstat，在centos中执行yum install systat就好了。 然后我们看看各个字段什么意思。 字段 描述 cpu 表示当前条信息属于哪个cpu的数据 %usr 进程运行在用户空间所占cpu运行时间的比例 %nice nice值为负的进程运行在用户空间的时间占cpu总运行时间的比例 %iowait cpu等待磁盘操作的时间占cpu总运行时间的比例 %irq cpu用于处理硬件中断时间占cpu总运行时间的比例 %soft cpu用于处理软件中断的时间占cpu用运行时间的比例 %steal 一对虚拟cpu。当超级管理员在处理某个虚拟cpu时，另一个等待它处理完才能运行。这段等待时间表示为steal时间占总运行时间的比例 %guest 运行虚拟cpu时间占cpu总运行时间的比例 %idle 系统空闲时间占cpu总运行时间的比例 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:13:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"split 将文件分割为数个。 split -5 a.txt//将a.txt每5行分割为一个文件 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:14:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"wc -c +filename 统计文件中单词的个数。 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:15:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"more/less 一页一页显示，通过空白键显示下一页/上一页 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:16:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"head/tail 查看某文件前几行或者后几行 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:17:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["Linux"],"content":"diff diff -c file1 file2 //显示两个文件的差异 ","date":"2020-10-29 22:46:20","objectID":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:18:0","tags":["Linux"],"title":"Linux常用指令","uri":"/2020/10/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"categories":["数据库"],"content":"Redis常见问题 ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"Redis是什么？ Redis是通过C编写的一种键值对存储数据库，由于是基于内存的，因此读写速度非常快，多被用于做缓存。 ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:1","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"Redis过期Key是怎么清理的？ 惰性清理 在访问key时，如果发现key过期，将其清理 定时清理 Redis配置项hz定义了serverCron任务的执行周期，默认每次清理时间为25ms，每次清理会依次遍历所有DB，从db随机取出20个key，如果过期就删除，如果其中有5个key过期，那么久继续对这个db进行清理，否则开始清理下一个db。 内存不够时进行清理 当执行写command时，如果发现内存不够，则会按照配置的淘汰策略清理内存，淘汰策略一般有6种，Redis4.0又增加了两种，主要分为三类： 不处理，等报错（默认） noeviction，发现内存不够时，不删除key，执行写入命令时直接返回错误信息。（Redis默认的配置就是noeviction） 从所有结果集的key中挑选，进行淘汰 allkeys-random 就是从所有的key中随机挑选key，进行淘汰 allkeys-lru 就是从所有的key中挑选最近使用时间距离现在最远的key，进行淘汰 allkeys-lfu 就是从所有的key中挑选使用频率最低的key，进行淘汰。（这是Redis 4.0版本后新增的策略） 从设置了过期时间的key中挑选，进行淘汰 volatile-random 从设置了过期时间的结果集中随机挑选key删除。 volatile-lru 从设置了过期时间的结果集中挑选上次使用时间距离现在最久的key开始删除 volatile-ttl 从设置了过期时间的结果集中挑选可存活时间最短的key开始删除(也就是从哪些快要过期的key中先删除) volatile-lfu 从过期时间的结果集中选择使用频率最低的key开始删除（这是Redis 4.0版本后新增的策略） ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:2","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"如何解决Redis缓存穿透问题？ Redis缓存穿透指的事攻击者故意大量请求一些Redis缓存中不存在的key的数据，导致请求打在数据库上，导致数据库压力过大。 总结来说就是： 缓存层不中 存储层不命中，不将空结果写入缓存 返回空结果给客户端 解决方案 做好参数校验，无效请求直接返回，只能避免部分 如果缓存和数据库都查不到某个key的数据就写入到一个redis中去并设置过期时间，如 SET key value EX 10086。可以解决请求key变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致redis中缓存大量无效的key，因此这种方案不能从根本上解决问题，如果非要用这种方式，就需尽量将key的过期时间设置的短些，如1分钟。 也可以使用布隆过滤器，将所有可能存在的数据通过hash值的方法存入到一个足够大的bitmap中去，处理请求时在bitmap中查找，可以将不存在的数据拦截掉。 Bit-map就是一个bit位用来标记某个元素对应的Value，而Key是该元素。采用以Bit为单位来存储数据。 Bit（Byte） ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:3","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"如何解决Redis缓存击穿问题？ Redis缓存击穿指的是某个key失效，导致大量请求全部转向数据库，导致数据库压力过大。 解决方案 对热点key设置永不过期 加互斥锁，缓存中没有热点key对应的数据时，等待100ms，由获得的线程去读取数据库然后设置缓存 ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:4","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"如何解决Redis缓存雪崩的问题？ 缓存雪崩主要指短时间内大量key失效，导致请求全部转向数据库，导致数据库压力过大。 解决方案 给缓存设置失效时间加一个随机值，避免集体同时失效 双缓存机制，缓存A的失效时间为20分钟，缓存B没有失效时间。从缓存A中读取数据，缓存A中没有时，去缓存B中读取，并且启动一个异步线程来更新缓存A ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:5","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"如何解决缓存与数据库的数据一致性问题？ 多个诱因： 多个写请求顺序不同，导致脏数据。（丢失修改） 更新时正好有读请求，导致还没更新数据，进行读操作（脏读） 或者数据库读写分离，在主库更新完后，需要一定的时间，从库才更新 先更新数据库，后更新缓存 先删除缓存，在更新数据库 先更新数据库，再删除缓存 正确的方案 写请求串行化 将写请求更新之前获取分布式锁，获得之后才能更新，这样实现请求的串行化，但是会导致效率遍变低。 先更新数据库，异步删除缓存，删除失败之后再重试 先更新数据库，异步删除缓存，删除缓存失败时，继续异步重试，或者将操作放到消息队列中，再进行删除操作。（如果数据库是读写分离的，那么删除缓存时需要延迟删除，否则可能会删除缓存时，从库中还没有收到更新后的数据，其他读请求就去从库读到旧数据然后设置到缓存中。） 业务项目更新数据库，其他项目订阅binlog更新 业务项目直接更新数据库，然后其他项目订略binlog，接收到更新数据库操作的消息后，更新缓存，更新缓存失败时，新建异步线程去重试或者将操作发到消息队列，然后后续进行处理。但是这种方案更新mysql后还是有一定延迟，缓冲中才是新值。 ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:6","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"Redis为什么采用单线程模型 Redis是基于内存进行操作，因此CPU不会成为瓶颈所在。 采用单线程带来的好处： Redis项目代码清晰，处理逻辑简单 不用考虑多格线程修改数据的情况，修改数据时也不用加锁，解锁等问题 不存在多进程或多线程切换带来的性能开销 劣势： 无法充分发挥多核机器的优势，但可以启动多个Redis实例来利用资源 ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:7","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"Redis的性能为何高 完全基于内存操作，少去了I/O操作 采用单线程模型，没有上下文开销 Redis项目中使用的数据结构都是经过专门设计的，例如SDS（Simple Dynamic String）对C语言中的字符串频繁修改，会频繁地进行内存分配，十分消耗性能，而SDS会使用预空间分配和惰性空间来释放避免出现这些问题。 如果修改后SDS实际长度为len 当len \u003c 1M时，分配的空间会是2*len + 1，也就是预留len长度的未使用空间，其中1存储空字符 当len \u003e 1M时，分配的空间会是len + 1 + 1M，会预留1M长度未使用空间，其中1存储空字符 采用多路复用IO模型，可以同时检测多个流的IO事件能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态唤醒，轮询那些真正发出请求的流，并依次处理就绪的流。可以让单个线程高效的处理多个连接请求。 ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:8","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"Linux中IO模型有哪些 IO模型主要有 阻塞式I/O模型，非阻塞式I/O模型，I/O复用模型，信息驱动型I/O模型，异步I/O模型 阻塞式 用户发出一个IO请求，如果当前内核中的数据报未准备好，会让其一直占用CPU时间片，知道准备完成后，才让出，然后将数据报从内核拷贝用户空间内存，然后返回成功的信号，此时用户态才接触阻塞的状态处理数据报。 非阻塞式 当线程处于等待内核的时候，当数据未准备成功的时候，用户态进程会一直轮询内核，直到内核准备好。 多路复用式 指多个IO复用一个进程。最初级的I/O复用，就是一个进程对应多个连接，每次从头至尾进行遍历，判断是否有I/O事件需要处理，有的话就进行处理，缺点是效率比较低，如果一直没有事件进来，会导致CPU空转。 升级版的I/O复用模型 当没有I/O事件时，进程处于阻塞状态，当有I/O事件时，就会有一个代理去唤醒进程，去进行轮询，来处理I/O事件。（这里的代理也就是select和poll，select只能观察1024个连接，poll可以观察无限个连接，因为poll是基于链表来实现的） epoll是对select和poll的升级版，解决了很多问题，是线程安全的，而且可以通知进程是哪个Socket连接有I/O事件,提高了查找效率。 epoll和select/poll最大区别是 (1)epoll内部使用了mmap共享了用户和内核的部分空间，避免了数据的来回拷贝 (2)epoll基于事件驱动，epoll_wait只返回发生的事件避免了像select和poll对事件的整个轮寻操作（时间复杂度为O（N）），epoll时间复杂度为O（1）。 信号驱动式 是非阻塞的，当需要数据等待的时候，用户态进程会给内核发送一个信号，告知自己需要数据，然后就去执行其他任务，待内核准备好数据会给用户态发送信号，用户态接收到信号后，会返回revfrom，等待数据从内核复制到用户内存空间，待完成之后的revfrom返回成功指示，用户态进程才处理数据。 异步IO模型 与信息驱动式I/O模型区别在于，是在数据从内核态拷贝到用户空间之后，内核才通知用户态进程来处理数据。在复制数据到用户空间这个时间段内，用户态进程也是不阻塞的。 ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"Redis主从同步是如何实现的 ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:0","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"Redis中哨兵是什么 edis中的哨兵服务器是一个运行在哨兵模式下的Redis服务器，核心功能是监测主节点和从节点的运行情况，在主节点出现故障后， 完成自动故障转移，让某个从节点升级为主节点 ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:1","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"客户端是怎么接入哨兵系统的 首先Redis中的哨兵节点是一个配置提供者，而不是代理。 区别在于，配置提供者 前者只负责存储当前最新的主从节点信息，供客户端获取。 代理客户端 所有请求都会经过哨兵节点。 所以实际开发中，通过在客户端配置哨兵节点的地址+主节点的名称(哨兵系统可能会监控多个主从节点，名称用于区分)就可以获取到主节点信息， 下面的代码在底层实现是客户端向依次向哨兵节点发送\"sentinel get-master-addr-by-name\"命令， 成功获得主节点信息就不向后面的哨兵节点发送命令。 同时客户端会订阅哨兵节点的+switch-master频道，一旦主节点发送故障，哨兵服务器对主节点进行自动故障转移，会将从节点升级主节点， 并且更新哨兵服务器中存储的主节点信息，会向+switch-master频道发送消息，客户端得到消息后重新从哨兵节点获取主节点信息，初始化连接池。 String masterName = \"mymaster\"; Set\u003cString\u003e sentinels = new HashSet\u003c\u003e(); sentinels.add(\"192.168.92.128:26379\"); sentinels.add(\"192.168.92.128:26380\"); JedisSentinelPool pool = new JedisSentinelPool(masterName, sentinels); //初始化过程做了很多工作 Jedis jedis = pool.getResource(); jedis.set(\"key1\", \"value1\"); pool.close(); ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:2","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"补充 ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:3:0","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"布隆过滤器 布隆过滤器在针对大数据海量数据去重或验证数据合法性的时候非常有用。 本质上是（bit）数组，即每一个存入布隆过滤器的数据都只占一位，相比平时我们使用的list、map、set等数据结构，占用的空间更少且效率更高，但缺点是返回的结果是概率性的，不是非常准确。 操作 当一个元素加入布隆过滤器中的时候： 使用布隆过滤器中的hash（）函数对元素值进行计算，得到hash值（有几个hash函数得到几个hash值） 根据得到的hash值，在位数组中把对应下标的值置为1 当我们需要判断一个元素是否存在于布隆过滤器的时候： 对给定的元素再次进行相同的hash计算 得到值之后判断位数组中的每个元素是否都为1，如果为1，则在这个布隆过滤器中，如果存在一个值不为1，则说明该元素不在布隆过滤器中。 布隆过滤器说某个元素存在，小概率会误判，但说某个元素不存在，那一定不存在。 ","date":"2020-10-28 18:34:24","objectID":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:3:1","tags":["Redis"],"title":"Redis常见问题","uri":"/2020/10/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["消息中间件"],"content":"消息中间件 ","date":"2020-10-28 16:26:09","objectID":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/:0:0","tags":["消息中间件"],"title":"消息中间件","uri":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["消息中间件"],"content":"前言 消息（Message）是指应用在应用间传送的数据。 **消息队列中间件（Message Queue Middleware，简称MQ）**指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的继承。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。 一般有两种传递模式： 点对点（P2P，Point to Point） 发布/订阅（Pub/Sub） P2P是基于队列，消息生产者生产消息到队列，消息消费者从队列中接收消息，队列的存在使得消息异步传输成为可能。 Pub/Sub定义了如何向一个内容节点发布或订阅消息，这个内容节点称为topic（主题），topic可以认为是消息传递的一个中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。在消息的一对多广播中采用。 ","date":"2020-10-28 16:26:09","objectID":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/:1:0","tags":["消息中间件"],"title":"消息中间件","uri":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["消息中间件"],"content":"MQ的作用 ","date":"2020-10-28 16:26:09","objectID":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:0","tags":["消息中间件"],"title":"消息中间件","uri":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["消息中间件"],"content":"冗余（存储） 在有些情况下，处理数据的过程可能会失败，而MQ可以将数据持久化直到它们完全被处理。 ","date":"2020-10-28 16:26:09","objectID":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:1","tags":["消息中间件"],"title":"消息中间件","uri":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["消息中间件"],"content":"拓展性 MQ解耦了应用的处理过程，因此提高消息入队和处理效率是很容易的，只要另外增加处理即可，不需要更改代码，也不需要调节参数。 ","date":"2020-10-28 16:26:09","objectID":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:2","tags":["消息中间件"],"title":"消息中间件","uri":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["消息中间件"],"content":"削峰 通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高分期的并发事务。 ","date":"2020-10-28 16:26:09","objectID":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:3","tags":["消息中间件"],"title":"消息中间件","uri":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["消息中间件"],"content":"异步通信 在很多时候，应用不想也不需要立刻处理消息。MQ提供了异步处理机制。 在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。 ","date":"2020-10-28 16:26:09","objectID":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:4","tags":["消息中间件"],"title":"消息中间件","uri":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["消息中间件"],"content":"降低系统耦合性 分布式消息队列 分布式服务 目前使用比较多的用来构建SOA（Service Oriented Architecture 面向服务体系结构）的分布式服务框架是阿里巴巴开源的Dubbo。 **消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。**消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。 消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。 另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息 ","date":"2020-10-28 16:26:09","objectID":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/:2:5","tags":["消息中间件"],"title":"消息中间件","uri":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["消息中间件"],"content":"常用的MQ ","date":"2020-10-28 16:26:09","objectID":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/:3:0","tags":["消息中间件"],"title":"消息中间件","uri":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["消息中间件"],"content":"带来的问题 系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！ 系统复杂性提高： 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！ 一致性问题： 消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了! 特性 ActiveMQ RabbitMQ RocketMQ Kafka 单机吞吐量 万级，吞吐量比 RocketMQ 和 Kafka 要低了一个数量级 万级，吞吐量比 RocketMQ 和 Kafka 要低了一个数量级 10 万级，RocketMQ 也是可以支撑高吞吐的一种 MQ 10 万级别，这是 kafka 最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景 topic 数量对吞吐量的影响 topic 可以达到几百，几千个的级别，吞吐量会有较小幅度的下降这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic topic 从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，kafka 尽量保证 topic 数量不要过多。如果要支撑大规模 topic，需要增加更多的机器资源 可用性 高，基于主从架构实现高可用性 高，基于主从架构实现高可用性 非常高，分布式架构 非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 消息可靠性 有较低的概率丢失数据 经过参数优化配置，可以做到 0 丢失 经过参数优化配置，消息可以做到 0 丢失 时效性 ms 级 微秒级，这是 rabbitmq 的一大特点，延迟是最低的 ms 级 延迟在 ms 级以内 功能支持 MQ 领域的功能极其完备 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低 MQ 功能较为完善，还是分布式的，扩展性好 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 优劣势总结 非常成熟，功能强大，在业内大量的公司以及项目中都有应用。偶尔会有较低概率丢失消息，而且现在社区以及国内应用都越来越少，官方社区现在对 ActiveMQ 5.x 维护越来越少，几个月才发布一个版本而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 erlang 语言开发，性能极其好，延时很低；吞吐量到万级，MQ 功能比较完备而且开源提供的管理界面非常棒，用起来很好用。社区相对比较活跃，几乎每个月都发布几个版本分在国内一些互联网公司近几年用 rabbitmq 也比较多一些但是问题也是显而易见的，RabbitMQ 确实吞吐量会低一些，这是因为他做的实现机制比较重。而且 erlang 开发，国内有几个公司有实力做 erlang 源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复 bug。而且 rabbitmq 集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是 erlang 语言本身带来的问题。很难读源码，很难定制和掌控。 接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障。日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是 ok 的，还可以支撑大规模的 topic 数量，支持复杂 MQ 业务场景。而且一个很大的优势在于，阿里出品都是 java 系的，我们可以自己阅读源码，定制自己公司的 MQ，可以掌控。社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的 kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。而且 kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。 ","date":"2020-10-28 16:26:09","objectID":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/:3:1","tags":["消息中间件"],"title":"消息中间件","uri":"/2020/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"categories":["Spring"],"content":"SpringMVC原理 M 代表 Model model 就是数据，dao、bean V 代表 View 网页、JSP，用来展示模型中的数据 C 代表 Controller 把不同的数据（Model），显示在不同的视图（View）上 MVC模式主要解决了页面代码和后台代码的分离。 ","date":"2020-10-27 17:13:01","objectID":"/2020/10/springmvc%E5%8E%9F%E7%90%86/:0:0","tags":["SpringMVC"],"title":"SpringMVC原理","uri":"/2020/10/springmvc%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"Spring MVC原理 客户端发送请求，request请求url 前端控制器（DispatcherServlet）接收客户端请求，找到处理器映射HandlerMapping解析请求对应的Handle HandlerAdaptor会根据Handler来调用真正的处理器controller处理请求，并处理相应的业务逻辑 处理器返回一个模型视图ModeAndView 视图解析器View resolver进行解析 返回一个视图对象 前端控制器DispatcherServlet渲染数据（Model） 将得到的视图返回个客户端 前端控制器DispatcherServlet Servlet会拦截并处理HTTP请求，DispatcherServlet会拦截所有这些请求，并发送给Spring MVC控制器 \u003cservlet-mapping\u003e \u003cservlet-name\u003edispatcher\u003c/servlet-name\u003e \u003c!-- 拦截所有的请求 --\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 处理器映射HandlerMapping DispatcherServlet会查询一个或多个处理器映射来确定请求的下一站在哪 ","date":"2020-10-27 17:13:01","objectID":"/2020/10/springmvc%E5%8E%9F%E7%90%86/:1:0","tags":["SpringMVC"],"title":"SpringMVC原理","uri":"/2020/10/springmvc%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"Spring Bean ","date":"2020-10-27 17:13:01","objectID":"/2020/10/springmvc%E5%8E%9F%E7%90%86/:1:1","tags":["SpringMVC"],"title":"SpringMVC原理","uri":"/2020/10/springmvc%E5%8E%9F%E7%90%86/"},{"categories":["Spring"],"content":"Spring IoC AOP ","date":"2020-10-27 17:11:51","objectID":"/2020/10/springioc%E5%92%8Caop/:0:0","tags":["Spring"],"title":"SpringIOC和AOP","uri":"/2020/10/springioc%E5%92%8Caop/"},{"categories":["Spring"],"content":"IoC IoC（Inverse of Control：控制反转）是一种设计思想，**就是将原本在程序中手动创建对象的控制权，交给由Spring框架管理。**IoC容器是Spring用来实现IoC的载体，IoC容器实际上就是个Map，Map中存放的是各种对象。 将对象之间的相互依赖关系交给IoC容器管理，并由IoC容器完成对象的注入。即很大程度的简化了应用的开发，把应用从复杂的依赖关系中解放出来。IoC容器就像一个工厂，当我们需要创建一个对象的时候，只需要配置好配置文件/注解，完全不用考虑对象如何被创建。 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。 Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。 ","date":"2020-10-27 17:11:51","objectID":"/2020/10/springioc%E5%92%8Caop/:1:0","tags":["Spring"],"title":"SpringIOC和AOP","uri":"/2020/10/springioc%E5%92%8Caop/"},{"categories":["Spring"],"content":"依赖倒置原理： 把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。 控制反转（Inversion of Control） 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的依赖注入（Dependency Injection） ","date":"2020-10-27 17:11:51","objectID":"/2020/10/springioc%E5%92%8Caop/:1:1","tags":["Spring"],"title":"SpringIOC和AOP","uri":"/2020/10/springioc%E5%92%8Caop/"},{"categories":["Spring"],"content":"核心思想 Inverseion of Control的最核心的思想就是，资源不由使用资源的双方管理，而由不使用资源的第三方管理。 例子： 就是甲方要达成某种目的不需要直接依赖乙方，只需要将目的告诉给第三个。例如甲方需要一台电脑，乙方卖一台电脑，乙方要将电脑卖出去也不需要找到甲方，也只需要将电脑寄托到淘宝（电商平台）去告诉我要卖一台电脑。这样甲乙双方进行交易活动，都不需要自己去找互相，相当于程序内部开放接口，而卖家由第三方作为参数传入。甲乙不相互依赖，只有在交易的时候产生联系，反之亦然，解决了甲乙直接进行交易之间的不信任，因为交易由第三方负责联系。 这就是ioc的核心思想。生活中这种例子比比皆是，支付宝在整个淘宝体系里就是庞大的ioc容器，交易双方之外的第三方，提供可靠性可依赖可灵活变更交易方的资源管理中心。另外人事代理也是，雇佣机构和个人之外的第三方。 而所谓的依赖注入，就是甲方开发接口，在需要的时候，将乙方注入进来。 而所谓的控制反转，就是甲乙双方不互相依赖，交易活动的进行不依赖于互相，整个活动的进行全部由第三方负责管理。 ","date":"2020-10-27 17:11:51","objectID":"/2020/10/springioc%E5%92%8Caop/:1:2","tags":["Spring"],"title":"SpringIOC和AOP","uri":"/2020/10/springioc%E5%92%8Caop/"},{"categories":["Spring"],"content":"带来的好处 拿来就用 享受单例的好处，效率高，不浪费空间 便于AOP操作，对于使用者是透明的 统一配置，方便修改 ","date":"2020-10-27 17:11:51","objectID":"/2020/10/springioc%E5%92%8Caop/:1:3","tags":["Spring"],"title":"SpringIOC和AOP","uri":"/2020/10/springioc%E5%92%8Caop/"},{"categories":["Spring"],"content":"AOP AOP(Aspect-Oriented Programming：面向切面编程)，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 主要功能：让关注点代码与业务代码分离 面向切面编程：对很多功能具有重复代码抽取，再在运行的时候往业务方法上动态注入“切面类代码” ","date":"2020-10-27 17:11:51","objectID":"/2020/10/springioc%E5%92%8Caop/:2:0","tags":["Spring"],"title":"SpringIOC和AOP","uri":"/2020/10/springioc%E5%92%8Caop/"},{"categories":["Spring"],"content":"AOP相关术语 通知（Advice） 通知描述了切面要完成的工作以及何时执行。比如我们的日志切面需要记录每个接口调用时长，就需要在接口调用前后分别记录当前时间，再取差值。 前置通知（Before）：在目标方法调用前调用通知功能； 后置通知（After）：在目标方法调用之后调用通知功能，不关心方法的返回结果； 返回通知（AfterReturning）：在目标方法成功执行之后调用通知功能； 异常通知（AfterThrowing）：在目标方法抛出异常后调用通知功能； 环绕通知（Around）：通知包裹了目标方法，在目标方法调用之前和之后执行自定义的行为。 连接点（JoinPoint） 通知功能被应用的时机。比如接口方法被调用的时候就是日志切面的连接点。 切点（Pointcut） 切点定义了通知功能被应用的范围。比如日志切面的应用范围就是所有接口，即所有controller层的接口方法。 切面（Aspect） 切面是通知和切点的结合，定义了何时、何地应用通知功能。 引入（Introduction） 在无需修改现有类的情况下，向现有的类添加新方法或属性。 织入（Weaving） 把切面应用到目标对象并创建新的代理对象的过程。 ","date":"2020-10-27 17:11:51","objectID":"/2020/10/springioc%E5%92%8Caop/:2:1","tags":["Spring"],"title":"SpringIOC和AOP","uri":"/2020/10/springioc%E5%92%8Caop/"},{"categories":["Spring"],"content":"一些思考 AOP（Aspect oriented Programming）主要是为了将在业务代码中无关且大量存在的代码（日志，权限验证、性能检测、事务控制等）从业务代码中剥离。 OOP中，如果我们要实现一个日志记录，则需要定义一个接口，或者父类实现去减少一些代码的重复，但不可避免的在业务层的代码中留下，使得业务代码掺杂了无关业务以外的，且重复。而AOP就是将这些重复的代码进行剥离出来（切入点）。 而将代码剥离出来后，对其进行预编译，当目标方法执行的时候，再往业务方法上动态织入weaving函数方法。 利用AOP将各个业务层面逻辑进行了切分，减少了业务逻辑和各个部分的耦合性，提高了程序的可重用性，提高了开发效率。 ","date":"2020-10-27 17:11:51","objectID":"/2020/10/springioc%E5%92%8Caop/:2:2","tags":["Spring"],"title":"SpringIOC和AOP","uri":"/2020/10/springioc%E5%92%8Caop/"},{"categories":["架构"],"content":"网站架构 大型网站软件系统的特点： 高并发、大流量 高可用：系统需要不间断提供服务 海量数据 用户分布广泛，网络情况复杂 安全环境恶劣 需求快速变更，发布频繁 渐进式发展：几乎所有大网站都是从一个小网站开始的 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:0:0","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"发展历程 初始阶段的网络架构： 应用程序、数据库、文件等所有资源都在同一台服务器上 应用服务和数据库分离： 网站使用三台服务器：应用服务器、文件服务器和数据库服务器 使用缓存改善性能： 使用缓存后，数据库的压力得到释放且性能提高 使用服务器集群改善网站的并发处理能力： 通过负载均衡调度服务器将请求分配到集群中的服务器上 数据库读写分离： 应用服务器在写数据的时候访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库，这样读数据的时候就可以通过从数据库了 使用反向代理和CDN加速网络响应 使用分布式文件系统和分布式数据库系统 使用Nosql和搜索引擎 业务拆分 分布式服务 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:1:0","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"架构模式 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:2:0","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"一、分层 初步可以将网站软件系统分为：应用层、服务层、数据层后续还可以继续分层 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:2:1","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"二、分割 网站越大，功能越复杂，因此服务和处理的种类越多，将这些不同的功能和服务分割开，包装成高内聚低耦合的模块。有助于开发和维护，同时便于不同模块的分布式部署，提高网站的并发和处理能力和功能拓展能力 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:2:2","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"三、分布式 分层和分割的一个主要目的是为了切分后的模块便于分布式部署，及不同模块部署到不同的服务器上，通过远程调用协同工作。分布式意味着使用更多的计算机完成同一功能，能并发处理的资源和数据量就越多。 分布式应用和服务 分布式静态资源 分布式数据和存储 分布式计算 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:2:3","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"四、集群 使用分布式虽然已经将分层和分割后的模块独立部署，但是对于用户访问集中的模块（比如网页的首页）还需要将独立部署的服务器集群化，将多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务，当用户更多的时候，仅需向集群中增加服务器即可。 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:2:4","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"五、缓存 CDN、反向代理、本地缓存、分布式缓存 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:2:5","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"六、异步 在单一服务器可通过多线程共享队列的方式实现异步，处在业务操作前面的线程将输出写入到队列，后面的线程从队列中读取数据进行处理。在分布式系统中，多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看做内存队列的分布式部署。 提供系统可用性 加快网站响应速度 消除并发访问高峰：使用消息队列放入消息队列里依次进行处理，降低网站的负载 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:2:6","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"七、冗余 数据库除了定期备份，存档保存，实现冷备份之外，为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步实现热备份。 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:2:7","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"八、自动化 在无人值守的情况下，一切自动化（理想化） 不知道是否可通过机器学习，进行服务器参数的自我调整（自我猜想） ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:2:8","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"九、安全 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:2:9","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["架构"],"content":"架构要素 性能 可用性 伸缩性 拓展性 安全性 ","date":"2020-10-26 19:05:43","objectID":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/:3:0","tags":["架构"],"title":"网站架构","uri":"/2020/10/%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84/"},{"categories":["进阶"],"content":"RESTfulAPI简明 RESTful API 可以看到url + http method 就知道这个url是干什么的，让你看到啦http状态码（status code）就知道请求结果如何。 是一种架构的风格。 ","date":"2020-10-26 18:25:32","objectID":"/2020/10/restfulapi%E7%AE%80%E6%98%8E/:0:0","tags":["RESful"],"title":"RESTfulAPI简明","uri":"/2020/10/restfulapi%E7%AE%80%E6%98%8E/"},{"categories":["进阶"],"content":"重要的概念 REST，即REpresentational State Transfer的缩写。实际全称：Resource Representational State Tranfe“资源”在网络传输中以某种“表现形式”进行“状态转移“。 **资源（Resource）：**真实的对象数据（资源）。一个资源可以是一个集合，也可以是单个个体。 表现形式（Representational）：”资源“是一种信息实体，它可以有多种外在表现形式。 **状态转移（State Transfer）：**通过增删改查引起的资源状态的改变。ps：互联网通信协议HTTP协议，是一个无状态协议，所有资源都保存在服务端。 RESTful架构： 每一个URL代表一种资源； 客户端和服务端之间，传递这种资源的某种表现形式：json、xml、image、txt等 客户端通过特定的HTTP动词，对服务器端资源进行操作，实现”表现层状态转换“ ","date":"2020-10-26 18:25:32","objectID":"/2020/10/restfulapi%E7%AE%80%E6%98%8E/:1:0","tags":["RESful"],"title":"RESTfulAPI简明","uri":"/2020/10/restfulapi%E7%AE%80%E6%98%8E/"},{"categories":["进阶"],"content":"REST接口规范 动作 GET：请求从服务器获取特定资源 POST：在服务器创建一个新的资源 PUT：更新服务器的资源（客户端提供更新后的整个资源） DELETE：从服务器删除特定的资源 PATCH：更新服务器上的资源（客户端提供的更新的属性，可以看做是部分更新） 路径（接口命名） 路径又称”终点“（endpoint），表示API的具体网址。实际开发中的规范如下： **网址中不能有动词，只能有名词。API中的名词也应该是使用复数。**因为 REST 中的资源往往和数据库中的表对应，而数据库中的表都是同种记录的\"集合\"（collection）。如果 API 调用并不涉及资源（如计算，翻译等操作）的话，可以用动词。 比如：GET /calculate?param1=11\u0026param2=33 不用大写字母，建议用中杠 - 不用下杠 _ 比如邀请码写成 invitation-code而不是 invitation_code 接口尽量使用名词，禁止使用动词。 下面是一些例子： GET /classes：列出所有班级 POST /classes：新建一个班级 GET /classes/classId：获取某个指定班级的信息 PUT /classes/classId：更新某个指定班级的信息（一般倾向整体更新） PATCH /classes/classId：更新某个指定班级的信息（一般倾向部分更新） DELETE /classes/classId：删除某个班级 GET /classes/classId/teachers：列出某个指定班级的所有老师的信息 GET /classes/classId/students：列出某个指定班级的所有学生的信息 DELETE classes/classId/teachers/ID：删除某个指定班级下的指定的老师的信息 反例： /getAllclasses /createNewclass /deleteAllActiveclasses 理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源:/schools，老师: /schools/teachers，学生: /schools/students 就是二级资源。 过滤信息（Filtering） 如果我们在查询的时候需要添加特定条件的话，建议使用 url 参数的形式。比如我们要查询 state 状态为 active 并且 name 为 guidegege 的班级： GET /classes?state=active\u0026name=guidegege 比如我们要实现分页查询： GET /classes?page=1\u0026size=10 //指定第1页，每页10个数据 状态码（Status Codes） 2xx：成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误 200 成功 301 永久重定向 400 错误请求 500 服务器错误 201 创建 304 资源未修改 401 未授权 502 网关错误 403 禁止访问 504 网关超时 404 未找到 405 请求方法不对 ","date":"2020-10-26 18:25:32","objectID":"/2020/10/restfulapi%E7%AE%80%E6%98%8E/:2:0","tags":["RESful"],"title":"RESTfulAPI简明","uri":"/2020/10/restfulapi%E7%AE%80%E6%98%8E/"},{"categories":["设计模式"],"content":"设计模式 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。 设计模式分三种类型，共23种： 创建型模式：单例模式、建造者模式、工厂模式、抽象工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模板方法模式、命令模式、迭代器模式、观察者模式、策略模式、中介者模式、备忘录模式、解释器模式、责任链模式、访问者模式。 一些重要的设计模式： 创建型模式：工厂模式、单例模式、抽象工厂模式 结构型模式：适配器模式、组合模式、外观模式、代理模式 行为型模式：命令模式、迭代器模式、观察者模式、策略模式 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"引言 设计面向对象的软件比较困难，而设计可复用的面向对象软件更加困难。必须找到相关的对象，以适当的粒度将他们定义，再定义类的接口和继承层次，建立对象之间的基本关系。因此设计的时候必须具有针对性，同时将带来的问题和需求也要有足够的通用性。 因此未来避免重复设计或尽可能的减少做重复设计。设计模式的诞生因此而来，它是由无数设计者们的经验堆叠而来，它们帮助设计者将新的设计建立在以往的工作的基础上，复用以往成功的设计方案。 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"创建模式 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Singleton（单态/单件） 保证一个类只有一个实例，并提供一个访问它的全局访问点 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:1","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Factory（工厂方法和抽象工厂） 使用工厂模式就像使用new一样频繁 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:2","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Builder（建造者模式） 汽车由车轮、方向盘、发动机很多部件组成，同时，将这些部件组装成汽车也是一件复杂的工作，Builder模式就是将这两种情况分开进行 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:3","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Prototype（原型） 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:2:4","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"结构模式 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Adapter（适配器） 使用类再生的两个方式：组合（new）和继承（extends) ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:1","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Proxy（代理） 剖析代理模式在于用户级别授权机制上的应用 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:2","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Facade（外观） 可拓展使用JDBC针对不同的数据库编程，提供了一种灵活的实现 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:3","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Composite（组合） 将类用树形结构组合成一个单位：你向别人介绍你是某单位，你是单位中的一个元素，别人和你做买卖，相当于和单位做买卖 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:4","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Decorator（装饰） ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:5","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Bridge（桥接） 本应在一起，分开它们，形成两个接口，在他们之间搭建一个桥（动态结合） ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:6","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Flyweight（共享元） 提供Java运行性能，降低小而大量的重复的类的开销 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:3:7","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"行为模式 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Command（命令） 将行为封装 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:1","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Observer（观察者模式） 如何使用JavaAPI提供的现成Observer ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:2","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Iterator（迭代器） Java的Collection，在大多场合无需自己制造一个Iterator，只要将对象装入Collection中，直接使用Iterator进行对象遍历 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:3","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Template（模板方法） ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:4","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Strategy（策略模式） 不同算法各自封装，用户端可随意挑选需要的算法 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:5","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Chain of Responsesiability（责任链） 各司其职的类串成一串，类似击鼓传花，如果自己能完成就不要委托给下一个 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:6","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Mediator（中介） Mediator像十字路口的红绿灯，每个车辆只需和红绿灯交互就可以 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:7","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"State（状态） 状态是编程中常常碰到的实例，将状态对象化，设立状态变换器，便可在状态中轻松切换1 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:8","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Memento（注释状态） 在内存中保留原来数据的备份 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:9","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Interpreter（解释器） 对语言的分析，用的少 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:10","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Visitror（访问者） 访问者在进行访问的时候，完成一系列实质性操作，而且还可以拓展。 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:4:11","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式的六大原则 单一职责（一个类和方法只只做一件事） 里式替换（多态，子类可以拓展父类） 依赖倒置（细节依赖抽象，下层依赖上层） 接口隔离（建立单一接口） 迪米特原则（最少知道，降低耦合） 开闭原则（抽象架构，拓展实现） 1、开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 ","date":"2020-10-26 10:41:21","objectID":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/:5:0","tags":["设计模式"],"title":"设计模式","uri":"/2020/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Java实现单例模式 ","date":"2020-10-26 10:33:31","objectID":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"单例模式","uri":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单例定义 Singleton 模式主要作用保证在Java应用程序中，一个类Class只有一个实例存在。 另外方面，Singleton 也能够被无状态化。提供工具性质的功能， Singleton 模式就为我们提供了这样实现的可能。使用 Singleton 的好处还在于可以节省内存，因为它限制了实例的个数，有 利于 Java 垃圾回收（garbage collection）。 ","date":"2020-10-26 10:33:31","objectID":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["设计模式"],"title":"单例模式","uri":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"案例场景 数据库的连接池不会反复创建 spring中一个单例模式bean的生成和使用 在我们平常开发的代码中需要设置全局的一些属性保存 主要解决的是，一个全局使用的类频繁的创建和消费，从而提升整体的代码性能。 ","date":"2020-10-26 10:33:31","objectID":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["设计模式"],"title":"单例模式","uri":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计思想 及解决问题的关键就是保证应用中仅存有一个对象。 不允许其它应用程序用new对象 因为new就是开辟新的空间，更改数据只是更改所创建对象的数据，如果可以new的话，每一次new都产生一个对象，这样肯定保证不了对象的唯一性。 在该类中创建对象 因为不允许其它程序new对象，所以这里的对象需要在本类中new出来 对外提供一个可以让其它程序获取该对象的方法 因为对象是在本类中创建的，所以需要提供一个方法让其它类获取该对象 1、私有化该类的构造函数 2、通过new在本类中创建一个本类对象 3、定义一个公有方法 ","date":"2020-10-26 10:33:31","objectID":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["设计模式"],"title":"单例模式","uri":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"如何使用？ 一般有以下几种模式： 懒汉式 饿汉式 双重校验锁 静态内部类 枚举 饿汉与懒汉的区别： 饿汉是在内部已经创建好了实例，只要Singleton被装载就会实例化，因此会产生延迟（来源实例化） ","date":"2020-10-26 10:33:31","objectID":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["设计模式"],"title":"单例模式","uri":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"饿汉式[可用]： public class Singleton { private Singleton() { // 在自己内部定义自己一个实例 // 注意这里是private只供内部调用 private static Singleton instance = new Singleton(); // 这里提供一个外部访问本class 的静态方法 public static Singleton getInstance() { return instance; } } } 获取实例方法： Singleton instance = Singleton.getInstance(); 及它在类创建的时候就已经实例化了对象。 这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonHolder类，从而完成Singleton的实例化。 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 优点：避免了线程不安全，延迟加载，效率高。 ","date":"2020-10-26 10:33:31","objectID":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:1","tags":["设计模式"],"title":"单例模式","uri":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"懒汉式： 单例模式的懒汉式[线程安全，效率低]： public class Singleton { private static Singleton instance = null; public static synchronized Singleton getInstance() { // 这个方法比上面有所改进，不用每次都进行生成对象，只是第一次 // 使用时生成实例，提高了效率 if(instance == null) { instance = new Singleton(); return instance; } } } 这种方式是在调用getInstance方法时才创建对象的，因为比较懒，才被称为懒汉式。 缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。 单例模式懒汉式双重校验锁[推荐用] package Advance.design_pattern.singleton; /** * Description: * static + 锁 双重锁检验 * 减少了锁带来的资源开销 * 注意实例前的volatile关键字，由于实例化一个对象需要三步 * 1、为instance分配内存 * 2、初始化instance * 3、将instance指向内存空间 * 由于JVM具有指令重排的特性，所以以上的执行步骤有可能变为132，因此有可能对象拿到了一个未初始化的对象实例 * 在多线程的情况下，可能会有线程在进行判断未初始化成功，进入锁代码块中重新实例化了一次，从而破坏了单例模式 * 使用volatile修饰变量，防止指令的重排列 * 1、解决内存可见性问题 2、防止指令重排列 * @author:edgarding * @date:2020/11/4 **/ public class SingletonLanHan03 { private static volatile SingletonLanHan03 instance; private SingletonLanHan03() {} public static SingletonLanHan03 getInstance() { // 判断对象是否实例化过，没有才进入 if(instance == null) { // 没有实例化，对其类对象进行加锁 synchronized (SingletonLanHan03.class) { if (instance == null) { // 进行实例化，但注意这里是非原子性操作 instance = new SingletonLanHan03(); } } } return instance; } } 访问方式： Singleton instance = Singleton.getInstance(); 优点：线程安全；延迟加载；效率较高。 ","date":"2020-10-26 10:33:31","objectID":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:2","tags":["设计模式"],"title":"单例模式","uri":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"枚举[极其推荐使用] /** * 枚举[极推荐使用] * * 这里SingletonEnum.instance * 这里的instance即为SingletonEnum类型的引用所以得到它就可以调用枚举中的方法了。 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象 */ public enum SingletonEnum { instance; private SingletonEnum() { } public void whateverMethod() { } // SingletonEnum.instance.method(); } 访问方式： SingletonEnum.instance.method(); ","date":"2020-10-26 10:33:31","objectID":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:3","tags":["设计模式"],"title":"单例模式","uri":"/2020/10/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["Java基础"],"content":"Collections 工具类 Collections 工具值常用方法： 排序 查找，替换操作 同步操作 ","date":"2020-10-23 17:30:25","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-collections%E5%B7%A5%E5%85%B7%E7%B1%BB/:0:0","tags":["集合框架"],"title":"集合框架-Collections工具类","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"categories":["Java基础"],"content":"排序操作 void reverse(List list) // 反转 void shuffle(List list) // 随机排序 void sort(List list) // 按自然排序的升序 void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑 void swap(List list, int i , int j)//交换两个索引位置的元素 void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面 ","date":"2020-10-23 17:30:25","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-collections%E5%B7%A5%E5%85%B7%E7%B1%BB/:0:1","tags":["集合框架"],"title":"集合框架-Collections工具类","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"categories":["Java基础"],"content":"查找替换操作 int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的 int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll) int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c) void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。 int frequency(Collection c, Object o)//统计元素出现次数 int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target). boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素 ","date":"2020-10-23 17:30:25","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-collections%E5%B7%A5%E5%85%B7%E7%B1%BB/:0:2","tags":["集合框架"],"title":"集合框架-Collections工具类","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"categories":["Java基础"],"content":"同步操作 Collections 提供了多个synchronizedXxx()方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。 我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合。 最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。 synchronizedCollection(Collection\u003cT\u003e c) //返回指定 collection 支持的同步（线程安全的）collection。 synchronizedList(List\u003cT\u003e list)//返回指定列表支持的同步（线程安全的）List。 synchronizedMap(Map\u003cK,V\u003e m) //返回由指定映射支持的同步（线程安全的）Map。 synchronizedSet(Set\u003cT\u003e s) //返回指定 set 支持的同步（线程安全的）set。 ","date":"2020-10-23 17:30:25","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-collections%E5%B7%A5%E5%85%B7%E7%B1%BB/:0:3","tags":["集合框架"],"title":"集合框架-Collections工具类","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"categories":["其他"],"content":"x86汇编语言 ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:0:0","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"x86汇编——寄存器 8086CPU中共有14个寄存器，且均为16位 即 AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES 共 14 个。而这 14 个寄存器按照一定方式又分为了通用寄存器，控制寄存器和段寄存器。 ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:1:0","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"通用寄存器 AX，BX，CX，DX称作为数据寄存器： AX (Accumulator)：累加寄存器，也称之为累加器； BX (Base)：基地址寄存器； CX (Count)：计数器寄存器； DX (Data)：数据寄存器； SP和BP又称作为指针寄存器： SP (Stack Pointer)：堆栈指针寄存器； BP (Base Pointer)：基指针寄存器； SI和DI又称作为变址寄存器： SI (Source Index)：源变址寄存器； DI (Destination Index)：目的变址寄存器； ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:1:1","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"控制寄存器： IP (Instruction Pointer)：指令指针寄存器； FLAG：标志寄存器； ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:1:2","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"段寄存器： CS (Code Segment)：代码段寄存器； DS (Data Segment)：数据段寄存器； SS (Stack Segment)：堆栈段寄存器； ES (Extra Segment)：附加段寄存器； ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:1:3","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"详细 ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:0","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"数据寄存器（AX，BX，CX，DX） 数据寄存器有 AX，BX，CX，DX 四个组成，由于在 8086 之前的 CPU 为 8 位 CPU，所以为了兼容以前的 8 位程序，在 8086 CPU 中，每一个数据寄存器都可以当做两个单独的寄存器来使用，由此，每一个 16 位寄存器就可以当做 2 个独立的 8 位寄存器来使用了。 AX 寄存器可以分为两个独立的 8 位的 AH 和 AL 寄存器； BX 寄存器可以分为两个独立的 8 位的 BH 和 BL 寄存器； CX 寄存器可以分为两个独立的 8 位的 CH 和 CL 寄存器； DX 寄存器可以分为两个独立的 8 位的 DH 和 DL 寄存器； 除了上面 4 个数据寄存器以外，其他寄存器均不可以分为两个独立的 8 位寄存器 ； ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:1","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"AX 寄存器 如上所说，AX 的另外一个名字叫做累加寄存器或者简称为累加器，其可以分为 2 个独立的 8 位寄存器 AH 和 AL，可以有以下代码(即将 AX当做普通的寄存器使用，即可以用来暂存数据)： MOV AX,1234H 向寄存器 AX 传入数据 1234H MOV AH,56H 向寄存器 AX 的高 8 位寄存器 AH 中传入数据 56H MOV AL,78H 向寄存器 AX 的低 8 位寄存器 AL 中传入数据 78H 既然 AX 又被称作为累加器，AX 寄存器还具有特殊的用途，其可以在使用 DIV 和 MUL 指令时使用 DIV 在 8086 CPU 中是除法指令，而在使用除法的时候有两种情况，即除数可以是 8 位或者是 16 位的。除数可以存放在寄存器中或者是内存单元中，被除数放在AX中。当除数是 8 位时，被除数一定会是 16 位的，并且默认是放在 AX 寄存器中；而当除数是 16 位时，被除数一定是 32 位的，其中高16位放到DX中，低16位放在AX中。当除法指令执行完成以后，如果除数是 8 位的，则在 AL 中会保存此次除法操作的商，而在 AH 中则会保存此次除法操作的余数；如果除数是 16 位的话，则 AX 中会保存本次除法操作的商，而 DX 则保存本次除法操作的余数。 MUL 在8086CPU中是乘法指令，在做乘法运算时，两个相乘的数要么都是 8 位，要么都是 16 位。如果两个相乘的数都是 8 位的话，则一个默认是放在 AL 中，而另一个 8 位的乘数则位于其他的寄存器或者说是内存字节单元中；而如果两个相乘的数都是 16 位的话，则一个默认存放在 AX 中，另一个则是某个寄存器中或者是某个内存字单元中。当 MUL 指令执行完毕后，如果是 8 位的乘法运算，则默认乘法运算的结果是保存在 AX 中；如果是 16 位的乘法运算的话，则默认乘法运算的结果有 32 位，其中高位默认保存在 DX 中，而低位则默认保存在 AX 中。 AX 寄存器在 DIV 指令中的使用： MOV DX,0H 设置 32 位被除数的高 16 位为 0H MOV AX,8H 设置 32 位被除数的低 16 位为 8H MOV BX,2H 设置 16 位除数为 2H DIV BX 执行计算 AX 寄存器在 MUL 指令中的使用： MOV AX,800H 设置 16 位乘数为 800H MOV BX,100H 设置 16 位乘数为 100H MOV DX,0H 清空用来保存乘法结果的高16 位 MUL BX 执行计算 ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:2","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"BX寄存器 首先可以明确的是，BX 作为数据寄存器，表明其是可以暂存一般的数据的，即在某种程度上，它和 AX 可以暂存一般性数据的功能是一样的，其同样为了适应以前的 8 位 CPU ，而可以将 BX 当做两个独立的 8 位寄存器使用，即 BH 和 BL。除了暂存一般性数据的功能外，BX 作为通用寄存器的一种，BX 主要还是用于其专属功能——寻址(物理内存地址)上。8086中的地址表示是段地址:[偏移]，段地址可省略，省略时取默认情况。内存大小1MB,20位地址。 BX 寄存器在寻址中的使用： MOV BX,5H MOV AH,[BX] 设置 AX 的值为偏移地址为 BX 的内存单元中的值(此时默认DS段) ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:3","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"CX 寄存器 CX 寄存器作为数据寄存器的一种呢，其同样具有和AX，BX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的 8 位寄存器使用，即CH 和 CL 两个 8 位寄存器，当然，CX 也是有其专门的用途的，CX 中的 C 被翻译为 Counting 也就是计数器的功能，当在汇编指令中使用循环 LOOP 指令时，可以通过 CX 来指定需要循环的次数，而 CPU 在每一次执行 LOOP 指令的时候，都会做两件事：一件就是令 CX = CX – 1，即令 CX 计数器自动减去 1；还有一件就是判断 CX 中的值，如果 CX 中的值为 0 则会跳出循环，而继续执行循环下面的指令，如果 CX 中的值不为 0 ，则会继续执行循环中所指定的指令。 CX 寄存器在循环中的使用(输出 5 个白底蓝字的 A)： MOV AX,0B800H MOV DS,AX 使用 80x25 彩色字符模式，内存地址0xB8000 - 0xBFFFFF MOV BX,0 从 0xB8000 开始 MOV CX,5H 循环 5 次（每次运行到loop就减一） MOV DX,41H A的16 进制为 41H MOV AX,01110001B 显示白底蓝字 s: MOV [BX],DX 显示 ASCII 字符 ADD BX,1 MOV [BX],AX 设置字符显示属性 ADD BX,1 LOOP s ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:4","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"DX寄存器 DX 寄存器作为数据寄存器的一种，同样具有和AX，BX，CX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的 8 位寄存器使用，有 DH 和 DL，同时，DX 作为一个通用寄存器，当在使用 DIV 指令进行除法运算时，如果除数为 16 位时，被除数将会是 32 位，而被除数的高 16 位就是存放在 DX 中，执行完 DIV 指令后，本次除法运算所产生的余数将会保存在 DX 中；在执行 MUL 指令时，如果两个相乘的数都是 16 位的话，相乘后产生的结果显然需要 32 位来保存，而这 32 位的结果的高 16 位就是存放在 DX 寄存器中。 DX 寄存器在 DIV 指令中的使用（即 2293812 / 256 = 8960 余数为 52）： MOV DX,0023H 32 位被除数的高 16 位 MOV AX,0034H 32 位被除数的低 16 位 MOV BX,100H 16的除数 DIV BX ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:5","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"指针寄存器（BP，SP） BP寄存器 8086 CPU 中的指针寄存器包括两个，SP 和 BP，因为 SP 寄存器实质上必须和 SS 段寄存器一起使用，所以，把 SP 寄存器留到后面和 SS 段寄存器一起作介绍。 BP也就是基指针寄存器，它和其他的几个用来进行寻址操作所使用的寄存器(还有 BX，SI，DI)没有太大的区别。首先，BP 寄存器作为通用寄存器的一种，说明其是可以暂存数据的，而后，BP 又不是数据寄存器，也就意味着其不能分割成 2 个独立的 8 位寄存器使用。 当以 […] 的方式访问内存单元而且在 […] 中使用了寄存器 BP 的话，如果在指令中**没有明确或者说是显示的给出段地址时, 段地址使用默认的 SS 寄存器中的值(BX，SI，DI 会默认使用 DS 段寄存器)。**比如 DS:[BP] 则在这里明确给出了段地址位于 DS 中，代表的内存单元即是段地址为 DS ，偏移量为 BP 寄存器中的值的内存单元；而如果是仅使用 [BP] 的话，则代表的内存单元是段地址为 SS，偏移量为 BP 寄存器中的值的内存单元。 在 8086 CPU 中，只有 4 个寄存器可以以 […] 的方式使用，这四个寄存器分别是 BX，SI，DI，BP。BX 寄存器在寻址中的使用： MOV BP,0 MOV AX,[BP] 将 SS:[BP] 代表的内存单元移入 AX 中 MOV AX,CS:[BP] 将 CS:[BP] 代表的内存单元移入 AX 中 变址寄存器（SI，DI） 首先，变址寄存器和上面介绍的指针寄存器（也就是 BP 和 SP），它们的功能其实都是用于存放某个存储单元地址的偏移，或者是用于某组存储单元开始地址的偏移，即作为存储器指针使用，当然，由于变址寄存器和指针寄存器都是属于通用寄存器，所以它们也可以保存算术结果或者说是具有暂存数据的功能，但是因为它们不是数据寄存器，所以无法分割成 2 个独立的 8 位寄存器使用。 SI 是源变址寄存器，DI 是目的变址寄存器，8086 CPU 中的 SI 寄存器和 DI 寄存器其实和 BX 寄存器的功能是差不多的，只不过 SI 寄存器和 DI 寄存器均不是数据寄存器，所以它们不能够拆分为 2 个独立的 8 位寄存器。同时，通过使用 SI 和 DI 寄存器也可以用来完成寻址操作。 MOV SI,0 初始化偏移地址为 0 MOV AX,[SI] 将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX中 MOV AX,DS:[SI] 将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中 MOV AX,SS:[SI] 将段地址为 SS 偏移地址为 SI 的内存单元中的值移入 AX 中 ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:6","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"其他寄存器（CS，IP，SS，SP，DS，ES） 由于段寄存器总是和其他一些像指针寄存器，变址寄存器，控制寄存器一起使用，所以在这里，不单独介绍段寄存器，而是将段寄存器和一些其他的常用寄存器搭配介绍。 ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:7","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"CS寄存器和IP寄存器 CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中 CS 为代码段寄存器，而 IP 为指令指针寄存器 。当一个可执行文件加载到内存中以后，CS:IP 两个寄存器便指向了这个可执行文件的起始地址，然后 CPU 就可以从这个起始地址开始往下读取指令，当读取完指令后，CS:IP 将会自动的改变，基本上是改变 IP，从而指向下一条要读取的指令，这样就可以执行这个可执行文件了。任何时候，CS:IP 指向的地址中的内容都是 CPU 当前执行的指令。 ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:8","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"SS寄存器和SP寄存器 SS:SP 两个寄存器指向的是内存栈的栈顶元素。当使用 PUSH 指令向栈中压入 1 个字节单元时，SP =SP - 1；即栈顶元素会发生变化；当使用 POP 指令从栈中弹出 1 个字节单元时， SP =SP + 1；即栈顶元素会发生变化。 ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:9","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"DS寄存器和ES寄存器 DS 寄存器和 ES 寄存器都属于段寄存器，其实它们和 CS 寄存器以及 SS 寄存器用起来区别不大，既然是段寄存器的话，自然它们存放的就是某个段地址了。我们知道，CPU 要访问一个内存单元时，必须要提供一个指向这个内存单元的物理地址给 CPU ，而**在 8086 CPU中,物理地址是由段地址左移 4 位(乘以16)后加上偏移地址形成的。**我们也就只需要提供段地址和偏移地址即 OK 。DS寄存器存放的就是数据段的段地址 ，除了BP基指针寄存器外，其余的寄存器都默认使用DS寄存器的值作为段地址。 ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:10","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["其他"],"content":"标志寄存器（FLAG） 前面已经介绍了 8086 CPU 14个寄存器中的 13 个了，下面我们将介绍最后一个寄存器也就是 FLAG 寄存器。FLAG 中的每一个位都表示不同的状态，存储的信息通常又被称作程序状态字（PSW） 。下面是 FLAG 寄存器中各个位的示意图： ","date":"2020-10-22 20:29:48","objectID":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/:2:11","tags":["汇编"],"title":"汇编语言x86笔记","uri":"/2020/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80x86%E7%AC%94%E8%AE%B0/"},{"categories":["JVM"],"content":"Java GC垃圾收集器 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:0:0","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"简介 Java GC（Garbage Collection，垃圾回收）机制是Java 与 C++之间区别的一个重要特征，C++需要开发者自己实现垃圾回收的逻辑，而Java只需要专注于业务开发，垃圾回收的事由JVM代劳。 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:1:0","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"JVM内存管理 根据JVM规范，JVM把内存划分为以下几个区域 方法区（Method Area） 堆区（Heap） 虚拟机栈（VM Stack） 本地方法栈（Native Method Stack） 程序计数器（Program Counter Register） ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:2:0","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"方法区（Method Area） 方法区存放要加载的类的信息（如类名，修饰符等）、静态变量、构造方法等等。方法区是全局共享的，在一定的条件下也会被GC。当方法区超过所允许的大小时，就会抛出OutOfMemory：PermGen Space异常。 在Hotspot虚拟机中，这块区域对应 持久代（Permanent Generation），一般来说，方法区上执行GC的情况很少，这也是方法区被称为持久代的原因之一，但并不代表方法区上没有GC，其上的GC主要针对常量池的回收和已加载类的卸载。在其上进行GC，条件相当苛刻且困难。 **运行时常量池（Runtime Constant Pool）**是方法区的一部分，用于存储编译器生成的常量和引用。一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的intern（）方法，作用是String类维护了一个常量池，如果调用的字符\"hello\"已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。 堆区（Heap） 堆区是GC最频繁的，也是理解GC机制最重要的区域。堆区由所有线程共享，在虚拟机启动时创建。堆区主要用于存放对象实例及数组，所有new出来的对象都存储在该区域。 虚拟机栈（VM Stack） 虚拟机栈占用的是操作系统的内存，每一个线程对应一个虚拟机栈，它是线程私有的，生命周期和线程一样，每个方法被执行时产生一个栈帧（Stack Frame），栈帧用于存储局部变量表、动态链接、操作数和方法出口等信息，当方法被调用时，帧栈入栈，当方法调用结束时，帧栈出栈。 局部变量表中存储着方法相关的局部变量，包括各种基本数据类型及对象的引用地址等，因此有个特点：内存空间可以在编译期间就确定，运行时不再改变。 虚拟机栈定义了两种 异常类型：StackOverFlowError（栈溢出）和OutOfMemoryError（内存溢出）。如果线程调用的栈深度待遇虚拟机所允许的最大深度，则抛出栈溢出；不过大多数虚拟机都运行动态扩张虚拟机栈的大小，所以线程可以一直申请栈，直到内存不足为止，抛出内存溢出。 本地方法栈（Native Method Stack） 本地方法栈用于支持native方法的执行，存储每个native方法的执行状态。本地方法栈和虚拟机的运行机制一致，唯一区别是，虚拟机栈执行Java方法，本地方法栈执行native方法。在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将虚拟机栈和本地方法栈一起使用。 程序计数器（Program Counter Register） 程序计数器是一个很小的内存区域，不在RAM上，而是直接划分在CPU上，无法对其进行操作，作用是：JVM在解释字节码（.class）文件时，存储当前线程执行的字节码行号，只是一种概念模型，各种JVM所采用的方式不一样。字节码解释器工作时，就是通过改变程序计数器的值来取下一条要执行的指令，分支、循环、跳转等基础功能都是依赖此技术区完成的。 每个程序计数器只能记录一个线程的行号，因此它是线程私有的。 ​ 如果程序当前正在执行的是一个java方法，则程序计数器记录的是正在执行的虚拟机字节码指令地址，如果执行的是native方法，则计数器的值为空，此内存区是唯一不会抛出OutOfMemoryError的区域。 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:2:1","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"GC机制 随着程序的运行，内存中的实例对象、变量等占据的内存越来越多，如果不及时进行回收，会降低程序运行效率，甚至引发系统异常。 ​ 在上面介绍的五个内存区域中，有3个是不需要进行垃圾回收的： 本地方法栈 程序计数器 虚拟机栈 因为他们的生命周期是和线程同步的，随着线程的销毁，他们占用的内存会自动释放。所以，只有方法区和堆区需要进行垃圾回收，回收的对象就是那些不存在任何引用的对象。 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:3:0","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"查找算法 经典的 引用计数算法 每个对象添加到引用计数器，没被引用一次，计数器+1，失去引用，计数器-1，当计数器在一段时间内为0时，则认为该对象可进行回收。 但有个明显的缺点：当两个对象相互引用的时候，没有作用时，理应都该被回收，但因为相互引用，不符合垃圾回收的条件，所以导致无法处理。 因此采用的是 根搜索算法 基本思想是：从一个叫GC Roots的根节点出发，向下搜索，如果一个对象不能达到GC Roots的时候，说明该对象不能再被引用，可以被回收。 补充概念，在JDK1.2之后引入了四个概念：强引用、软引用、弱引用、虚引用。 强引用：new出来的对象都是强引用，GC无论如何都不会回收，即使抛出OOM异常。 软引用：只有当JVM内存不足时才会被回收。 弱引用：只要GC,就会立马回收，不管内存是否充足。 虚引用：可以忽略不计，JVM完全不会在乎虚引用，你可以理解为它是来凑数的，凑够\"四大天王\"。它唯一的作用就是做一些跟踪记录，辅助finalize函数的使用。 最后总结，什么样的类需要被回收： a.该类的所有实例都已经被回收； b.加载该类的ClassLoad已经被回收； c.该类对应的反射类java.lang.Class对象没有被任何地方引用。复制代码 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:3:1","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"内存分区 内存主要被分为三块：新生代（Youn Generation）、旧生代（Old Generation）、持久代（Permanent Generation）。三代的特点不同，造就了他们使用的GC算法不同，新生代适合生命周期较短，快速创建和销毁的对象，旧生代适合生命周期较长的对象，持久代在Sun Hotpot虚拟机中就是指方法区（有些JVM根本就没有持久代这一说法）。 新生代（Youn Generation）：大致分为Eden区和Survivor区，Survivor区又分为大小相同的两部分：FromSpace和ToSpace。新建的对象都是从新生代分配内存，Eden区不足的时候，会把存活的对象转移到Survivor区。当新生代进行垃圾回收时会出发Minor GC（也称作Youn GC）。 老年代（Old Generation）：旧生代用于存放新生代多次回收依然存活的对象，如缓存对象。当旧生代满了的时候就需要对旧生代进行回收，旧生代的垃圾回收称作Major GC（也称作Full GC）。 持久代（Permanent Generation：在Sun 的JVM中就是方法区的意思，尽管大多数JVM没有这一代。在Java8中已被去除，被一个称为”元数据区（元空间）的区域取代“，本质与永久代相似，但最大的区别在于，元空间不在虚拟机中，而是使用本地内存中。这样可加载多少类的元数据就不再由MaxPermSize控制，而是由系统的实际可用空间来控制。 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:3:2","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"GC算法 常见的GC算法：标记-复制、标记-清除和标记-整理 标记-清除（Mark-Sweep）：该算法是从根集合开始扫描，对存活的对象进行标记，标记完毕后，在扫描整个空间中未被标记的对象，并进行清除。标记-清除动作不需要移动对象，且仅对不存活的对象进行清理，在空间中存活对象较多的时候，效率较高，但由于只是清除，没有重新整理，因此会造成内存碎片，再需要分配较大对象空间的时候无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 标记-复制：为了解决标记-清除算法面对大量可回收对象执行效率低的问题。采用从根集合进行扫描，将存活的对象移动到一块空闲的区域，当存活对象较少的时候，复制算法比较高效（新生代的Eden区就是采用该种算法），其成本就是需要一块额外的空间和对象移动。 内存的分配担保也一样，如果另一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，那么这些对象将通过分配担保机制直接进入老年代。 标记-整理：其中的标记过程仍然与“标记-清除”一样，但后续步骤不是直接对可回收对象直接进行清理，而是让所有存活的对象都指向内存空间的一段移动，然后直接清理掉边界意外的内存 标记-复制和标记-清理的本质差异在于，标记-复制是一种非移动式的算法，而后者是移动式的。 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:4:0","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"垃圾收集器 在JVM中，GC是由垃圾回收器来进行执行。 衡量垃圾收集器的标准： 内存占用（footprint） 吞吐量（throughput） 延迟（lateency） ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:5:0","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"串行收集器（Serial GC) Serial GC是最古老也是最基本的收集器，但是现在依然广泛使用，JAVA SE5和JAVA SE6中客户端虚拟机采用的默认配置。比较适合于只有一个处理器的系统。在串行处理器中minor和major GC过程都是用一个线程进行回收的。它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the world），对于有些应用是难以接受的，但是如果应用的实时性要求不是那么高，只要停顿的时间控制在N毫秒之内，大多数应用还是可以接受的，而且事实上，它并没有让我们失望，几十毫秒的停顿，对于我们客户机是完全可以接受的，该收集器适用于单CPU、新生代空间较小且对暂停时间要求不是特别高的应用上，是client级别的默认GC方式。 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:5:1","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"ParNew GC ​ 基本和Serial GC一样，但本质区别是加入了多线程机制，提高了效率，这样它就可以被用于服务端上（server），同时它可以与CMS GC配合，所以，更加有理由将他用于server端。 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:5:2","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"Parallel Scavenge GC ​ 在整个扫描和复制过程采用多线程并行的方式进行，适用于多CPU、对暂停时间要求较短的应用，是server级别的默认GC方式。 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:5:3","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"CMS (Concurrent Mark Sweep)收集器 ​ 该收集器的目标是解决Serial GC停顿的问题，以达到最短回收时间。常见的B/S架构的应用就适合这种收集器，因为其高并发、高响应的特点，CMS是基于标记-清除算法实现的。 运作过程： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 其中初始标记、重新标记这两步骤仍然需要“Stop the world”。 初始标记仅仅只是标记一下GC roots 能直接关联到的对象，速度很快。并发标记就是从GC Roots的直接关联对象开始遍历整个对象图。 CMS收集器的优点：并发收集、低停顿，但远没有达到完美； CMS收集器的缺点： a.CMS收集器对CPU资源非常敏感，在并发阶段虽然不会导致用户停顿，但是会占用CPU资源而导致应用程序变慢，总吞吐量下降。 b.CMS收集器无法处理浮动垃圾，可能出现“Concurrnet Mode Failure”，失败而导致另一次的Full GC。 c.CMS收集器是基于标记-清除算法的实现，因此也会产生碎片。复制代码 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:5:4","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["JVM"],"content":"Garbage First收集器 Garbage First（G1）是一款主要面向服务端应用的垃圾收集器。 G1开创的基于Region的堆内存布局，G1不在坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region根据需求扮演Eden空间，Survivor空间，或者老年代空间。收集器能够根据不同的Region策略去进行处理。 此外Region中还有一类特殊的Humongous区域，专门用来存储大对象，G1认为只要大于超过一个Region容量一半的对象即为大对象。且每个Region可以通过参数 -XX:G1HeapRegionSize设定，G1的大多数行为都把Humongous Region作为老年代的一部分来看待。 ","date":"2020-10-22 17:21:25","objectID":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/:5:5","tags":["JVM"],"title":"Java GC垃圾收集器","uri":"/2020/10/java-gc%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"},{"categories":["Spring"],"content":"Spring Data Redis Spring Data Redis 是Spring框架提供的用来操作Redis的方式。 ","date":"2020-10-22 14:27:33","objectID":"/2020/10/spring-data-redis/:0:0","tags":["Redis"],"title":"Spring Data Redis","uri":"/2020/10/spring-data-redis/"},{"categories":["Spring"],"content":"Spring Cache 操作 Redis ","date":"2020-10-22 14:27:33","objectID":"/2020/10/spring-data-redis/:1:0","tags":["Redis"],"title":"Spring Data Redis","uri":"/2020/10/spring-data-redis/"},{"categories":["Spring"],"content":"常用注解 @EnableCaching 开启缓存功能 @Cacheable 使用该注解的方法当缓存存在时，会从缓存中获取数据而不执行方法，当缓存不存在时，会执行方法并把返回结果存入缓存中。一般使用在查询方法上，可以设置如下属性： value：缓存名称（必填），指定缓存的命名空间； key：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义； unless：条件符合则不缓存； condition：条件符合则缓存； @CachePut 使用该注解的方法每次执行时都会把返回结果存入缓存中。一般使用在新增方法上，可以设置如下属性： value：缓存名称（必填），指定缓存的命名空间； key：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义； unless：条件符合则不缓存； condition：条件符合则缓存。 @CacheEvict 使用该注解的方法执行时会清空指定的缓存。一般使用在更新或删除方法上，可以设置如下属性： value：缓存名称（必填），指定缓存的命名空间； key：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义； condition：条件符合则缓存。 @Service @Slf4j public class UserServiceImpl implements UserService { /** * 模拟数据库 */ private static final Map\u003cLong, User\u003e DATABASES = Maps.newConcurrentMap(); /** * 初始化数据 */ static { DATABASES.put(1L, new User(1L, \"user1\")); DATABASES.put(2L, new User(2L, \"user2\")); DATABASES.put(3L, new User(3L, \"user3\")); } /** * 保存或修改用户 * * @param user 用户对象 * @return 操作结果 */ @CachePut(value = \"user\", key = \"#user.id\") @Override public User saveOrUpdate(User user) { DATABASES.put(user.getId(), user); log.info(\"保存用户【user】= {}\", user); return user; } /** * 获取用户 * * @param id key值 * @return 返回结果 */ @Cacheable(value = \"user\", key = \"#id\") @Override public User get(Long id) { // 我们假设从数据库读取 log.info(\"查询用户【id】= {}\", id); return DATABASES.get(id); } /** * 删除 * * @param id key值 */ @CacheEvict(value = \"user\", key = \"#id\") @Override public void delete(Long id) { DATABASES.remove(id); log.info(\"删除用户【id】= {}\", id); } } ","date":"2020-10-22 14:27:33","objectID":"/2020/10/spring-data-redis/:1:1","tags":["Redis"],"title":"Spring Data Redis","uri":"/2020/10/spring-data-redis/"},{"categories":["Spring"],"content":"使用步骤 pom.xml \u003c!--redis依赖配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e 配置文件application.yml spring: redis: host: localhost # 连接超时时间（记得添加单位，Duration） timeout: 10000ms # Redis默认情况下有16个分片，这里配置具体使用的分片 # database: 0 lettuce: pool: # 连接池最大连接数（使用负值表示没有限制） 默认 8 max-active: 8 # 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1 max-wait: -1ms # 连接池中的最大空闲连接 默认 8 max-idle: 8 # 连接池中的最小空闲连接 默认 0 min-idle: 0 cache: # 一般来说是不用配置的，Spring Cache 会根据依赖的包自行装配 type: redis ","date":"2020-10-22 14:27:33","objectID":"/2020/10/spring-data-redis/:2:0","tags":["Redis"],"title":"Spring Data Redis","uri":"/2020/10/spring-data-redis/"},{"categories":["Spring"],"content":"存储JSON格式 此时我们就会想到有没有什么办法让Redis中存储的数据变成标准的JSON格式，然后可以设置一定的过期时间，不设置过期时间容易产生很多不必要的缓存数据。 @Configuration @AutoConfigureAfter(RedisAutoConfiguration.class) @EnableCaching public class RedisConfig { /** * 默认情况下的模板只能支持RedisTemplate\u003cString, String\u003e，也就是只能存入字符串，因此支持序列化 */ @Bean public RedisTemplate\u003cString, Serializable\u003e redisCacheTemplate(LettuceConnectionFactory redisConnectionFactory) { RedisTemplate\u003cString, Serializable\u003e template = new RedisTemplate\u003c\u003e(); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); template.setConnectionFactory(redisConnectionFactory); return template; } /** * 配置使用注解的时候缓存配置，默认是序列化反序列化的形式，加上此配置则为 json 形式 */ @Bean public CacheManager cacheManager(RedisConnectionFactory factory) { // 配置序列化 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig(); RedisCacheConfiguration redisCacheConfiguration = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer())).serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer())); return RedisCacheManager.builder(factory).cacheDefaults(redisCacheConfiguration).build(); } } ","date":"2020-10-22 14:27:33","objectID":"/2020/10/spring-data-redis/:2:1","tags":["Redis"],"title":"Spring Data Redis","uri":"/2020/10/spring-data-redis/"},{"categories":["Spring"],"content":"使用Redis连接池 SpringBoot 1.5.x版本Redis客户端默认是Jedis实现的，SpringBoot 2.x版本中默认客户端是用Lettuce实现 Jedis vs Lettuce Jedis 在实现上是直连Redis服务，多线程环境下非线程安全，除非使用连接池，为每个RedisConnection 实例增加物理连接。 Lettuce 是一种可伸缩，线程安全，完全非阻塞的Redis客户端，多个线程可以共享一个RedisConnection，它利用Netty NIO架构来高效管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序 使用步骤 spring: redis: lettuce: pool: max-active:8# 连接池最大连接数 max-idle:8# 连接池最大空闲连接数 min-idle:0# 连接池最小空闲连接数 max-wait:-1ms# 连接池最大阻塞等待时间，负值表示没有限制 由于SpringBoot 2.x中默认没有使用Redis连接池，所以需要在pom.xml中添加commons-pool2的依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e \u003cartifactId\u003ecommons-pool2\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2020-10-22 14:27:33","objectID":"/2020/10/spring-data-redis/:2:2","tags":["Redis"],"title":"Spring Data Redis","uri":"/2020/10/spring-data-redis/"},{"categories":["Spring"],"content":"自由操作Redis Spring Cache 给我们提供了操作Redis缓存的便捷方法，但是也有很多局限性。比如说我们想单独设置一个缓存值的有效期怎么办？我们并不想缓存方法的返回值，我们想缓存方法中产生的中间值怎么办？此时我们就需要用到RedisTemplate这个类了，接下来我们来讲下如何通过RedisTemplate来自由操作Redis中的缓存。 RedisService 定义Redis操作业务类，在Redis中有几种数据结构，比如普通结构（对象），Hash结构、Set结构、List结构，该接口中定义了大多数常用操作方法。 publicinterface RedisService { /** * 保存属性 */ void set(String key, Object value, long time); /** * 保存属性 */ void set(String key, Object value); /** * 获取属性 */ Object get(String key); /** * 删除属性 */ Boolean del(String key); /** * 批量删除属性 */ Long del(List\u003cString\u003e keys); /** * 设置过期时间 */ Boolean expire(String key, long time); /** * 获取过期时间 */ Long getExpire(String key); /** * 判断是否有该属性 */ Boolean hasKey(String key); /** * 按delta递增 */ Long incr(String key, long delta); /** * 按delta递减 */ Long decr(String key, long delta); /** * 获取Hash结构中的属性 */ Object hGet(String key, String hashKey); /** * 向Hash结构中放入一个属性 */ Boolean hSet(String key, String hashKey, Object value, long time); /** * 向Hash结构中放入一个属性 */ void hSet(String key, String hashKey, Object value); /** * 直接获取整个Hash结构 */ Map\u003cObject, Object\u003e hGetAll(String key); /** * 直接设置整个Hash结构 */ Boolean hSetAll(String key, Map\u003cString, Object\u003e map, long time); /** * 直接设置整个Hash结构 */ void hSetAll(String key, Map\u003cString, Object\u003e map); /** * 删除Hash结构中的属性 */ void hDel(String key, Object... hashKey); /** * 判断Hash结构中是否有该属性 */ Boolean hHasKey(String key, String hashKey); /** * Hash结构中属性递增 */ Long hIncr(String key, String hashKey, Long delta); /** * Hash结构中属性递减 */ Long hDecr(String key, String hashKey, Long delta); /** * 获取Set结构 */ Set\u003cObject\u003e sMembers(String key); /** * 向Set结构中添加属性 */ Long sAdd(String key, Object... values); /** * 向Set结构中添加属性 */ Long sAdd(String key, long time, Object... values); /** * 是否为Set中的属性 */ Boolean sIsMember(String key, Object value); /** * 获取Set结构的长度 */ Long sSize(String key); /** * 删除Set结构中的属性 */ Long sRemove(String key, Object... values); /** * 获取List结构中的属性 */ List\u003cObject\u003e lRange(String key, long start, long end); /** * 获取List结构的长度 */ Long lSize(String key); /** * 根据索引获取List中的属性 */ Object lIndex(String key, long index); /** * 向List结构中添加属性 */ Long lPush(String key, Object value); /** * 向List结构中添加属性 */ Long lPush(String key, Object value, long time); /** * 向List结构中批量添加属性 */ Long lPushAll(String key, Object... values); /** * 向List结构中批量添加属性 */ Long lPushAll(String key, Long time, Object... values); /** * 从List结构中移除属性 */ Long lRemove(String key, long count, Object value); } RedisServiceImpl RedisService的实现类，使用RedisTemplate来自由操作Redis中的缓存数据。 @Service publicclass RedisServiceImpl implements RedisService { @Autowired private RedisTemplate\u003cString, Object\u003e redisTemplate; @Override public void set(String key, Object value, long time) { redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); } @Override public void set(String key, Object value) { redisTemplate.opsForValue().set(key, value); } @Override public Object get(String key) { return redisTemplate.opsForValue().get(key); } @Override public Boolean del(String key) { return redisTemplate.delete(key); } @Override public Long del(List\u003cString\u003e keys) { return redisTemplate.delete(keys); } @Override public Boolean expire(String key, long time) { return redisTemplate.expire(key, time, TimeUnit.SECONDS); } @Override public Long getExpire(String key) { return redisTemplate.getExpire(key, TimeUnit.SECONDS); } @Override public Boolean hasKey(String key) { return redisTemplate.hasKey(key); } @Override public Long incr(String key, long delta) { return redisTemplate.opsForValue().increment(key, delta); } @Override public Long decr(String key, long delta) { return redisTemplate.opsForValue().increment(key, -delta); } @Override public Object hGet(String key, String hashKey) { return redisTemplate.opsForHash().get(key, hashKey); } @Override public Boolean hSet(String key, String hashKey, Object value, long time) { redisTemplate.opsForHash().put(key, hashKey, value); return expire(key, time); } @Override public void hSet(String key, String hashKey, Object value) { redisTemplate.opsFo","date":"2020-10-22 14:27:33","objectID":"/2020/10/spring-data-redis/:2:3","tags":["Redis"],"title":"Spring Data Redis","uri":"/2020/10/spring-data-redis/"},{"categories":["JUC"],"content":"Java并发编程一 ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:0:0","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"并发编程基础 ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:1:0","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"线程 进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程至少有一个线程，进程中多个线程共享进程的资源。 ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:1:1","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"线程的创建 继承 Thread 类并重写 run 的方法 // 继承Thread类，并重写run方法 public static class MyThread extends Thread { @Override public void run() { System.out.println(\"I am a child thread\"); } } public static void main(String[] args) { // 创建线程 MyThread myThread = new MyThread(); // 启动线程 myThread.start(); } 缺点：如果继承了Thread就无法继承其他类，任务和代码没有分离。 实现 Runnable 接口的 run 方法 public static class RunnableTask implements Runnable { @Override public void run() { System.out.println(\"I am a child thread\"); } } public static void main(String[] args) { // MyThread myThread = new MyThread(); // myThread.start(); RunnableTask task = new RunnableTask(); new Thread(task).start(); new Thread(task).start(); } 两个线程公用一个task代码逻辑，如果需要可以给RunableTask添加参数，进行业务区分，且也可以支持继承其他类，但与Thread类重新一样，都没有返回值。 使用 FutureTask 方式 而使用FutureTask的方式可以拿到结果返回值。 public class CallerTask implements Callable\u003cString\u003e { @Override public String call() throws Exception { return \"hello world\"; } public static void main(String[] args) { // 创建异步任务 FutureTask\u003cString\u003e futureTask = new FutureTask\u003c\u003e(new CallerTask()); new Thread(futureTask).start(); String result = null; try { result = futureTask.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } System.out.println(result); } } ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:1:2","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"线程死锁 什么是线程死锁 死锁是指两个或两个以上的线程在执行过程中，因争夺资源而资源而造成的互相等待的现象，在无外力的作用的情况下，这些线程会一直相互等待而无法继续运行下去。 死锁的条件 互斥条件 请求并持有资源 不可剥夺条件 环路等待条件 破坏死锁的条件，只有请求并持有资源和环路等待条件是可以被破坏的 /** * Description: * 死锁 * @author:edgarding * @date:2020/10/20 **/ public class DeadLock { private static final Object resourceA = new Object(); private static final Object resourceB = new Object(); public static void main(String[] args) { Thread threadA = new Thread(new Runnable() { @Override public void run() { synchronized (resourceA) { System.out.println(Thread.currentThread() + \" get A ResourceA\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread() + \" waiting get ResourceB\"); synchronized (resourceB) { System.out.println(Thread.currentThread() + \"get ResourceB\"); } } } }); Thread threadB = new Thread(new Runnable() { @Override public void run() { synchronized (resourceB) { System.out.println(Thread.currentThread() + \" get B ResourceB\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread() + \" waiting get ResourceA\"); synchronized (resourceA) { System.out.println(Thread.currentThread() + \"get ResourceA\"); } } } }); threadA.start(); threadB.start(); } } 输出结果： Thread[Thread-0,5,main] get A ResourceA Thread[Thread-1,5,main] get B ResourceB Thread[Thread-1,5,main] waiting get ResourceA Thread[Thread-0,5,main] waiting get ResourceB 破坏以上死锁条件，仅需要将threadB的持有资源条件改下，和请求的顺序改下。 Thread threadB = new Thread(new Runnable() { @Override public void run() { // 注意这将resourceB改为resourceA synchronized (resourceA) { System.out.println(Thread.currentThread() + \" get B ResourceB\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread() + \" waiting get ResourceA\"); synchronized (resourceB) { System.out.println(Thread.currentThread() + \"get ResourceA\"); } } } }); 输出结果： Thread[Thread-0,5,main] get A ResourceA Thread[Thread-0,5,main] waiting get ResourceB Thread[Thread-0,5,main]get ResourceB Thread[Thread-1,5,main] get B ResourceB Thread[Thread-1,5,main] waiting get ResourceA Thread[Thread-1,5,main]get ResourceA 解决死锁的几个常见方法： 避免一个线程同时获得多个锁 避免一个线程在锁内同时占有多个资源，尽量保证每个锁只占用一个资源 尝试使用定时锁 对于数据库锁，加锁去锁都必须在同一个数据库连接里 ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:1:3","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"守护线程与用户线程 Java 中的线程分为两类：daemon 线程（守护线程）和 user 线程（用户线程） JVM启动时，会调用main函数，main函数所在的线程就是一个用户线程，而在JVM中启动不仅仅只有main这一个用户线程，还会启动许多守护线程，例如：垃圾回收线程。 区别之一就是当最后一个非守护线程结束的时候，JVM会退出，并不管当前是否有守护线程。 调用thread.setDaemon(true) 设置为守护线程。 ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:1:4","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"ThreadLocal 当创建一个变量后，每个线程访问的时候访问的是自己线程的变量。 ThreadLocal 是JDK 包提供，提供了线程本地变量，也就是如果创建了一个ThreadLocal变量，那么访问这个变量每个线程都会有这个变量的一个本地变量。 TreadLocal的使用示例 public class ThreadLocalTest { static ThreadLocal\u003cString\u003e localVariable = new ThreadLocal\u003c\u003e(); static void print(String str) { // 打印当前localVariable变量的值 System.out.println(str + \":\" + localVariable.get()); // 清除当前本地内存中localVariable变量 // localVariable.remove(); } public static void main(String[] args) { // 创建线程one Thread threadOne = new Thread(new Runnable() { @Override public void run() { // 设置线程one中本地变量localVariable的值 localVariable.set(\"thread local variable\"); // 调用打印函数 print(\"threadOne\"); // 打印本地变量值 System.out.println(\"threadOne remove after\" + \":\" + localVariable.get()); } }); // 创建线程two Thread threadTwo = new Thread(new Runnable() { @Override public void run() { localVariable.set(\"threadTwo local variable\"); print(\"threadTwo\"); System.out.println(\"threadTwo remove after\" + \":\" + localVariable.get()); } }); threadOne.start(); threadTwo.start(); } } ThreadLocal实现原理 Thread类中有一个threadLocals和一个inherittableThreadLocals，他们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的HashMap，每个线程的变量都是null，只有当前线程第一次调用ThreadLocal的set或者get方法时，才会创建他们。其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在threadLocals变量里面，就是说，ThreadLocal类型的本地变量存放在具体的线程内存空间中。 void set（T value） public void set(T value) { // 获取当前线程 Thread t = Thread.currentThread(); // 将当前线程作为key，去查找对应的线程变量，找到则设置 ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else // 第一次调用就创建当前线程对应的HashMap createMap(t, value); } T get（） public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); // 如果threadLocals不为null，则返回对应本地变量的值 if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue(); } ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:1:5","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"并发编程的其它知识 内存可见性问题 当一个线程操作一个共享变量的时候，会将共享变量从主内存中取到自己的工作内存中，处理完后，再将工作变量更新到主内存中。 ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:2:0","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"synchronized 和 volatile synchronized synchronized是Java提供的一种原子性内置锁，Java中的每个对象都可以将它当做一个同步锁来进行使用，这些Java内置的使用者看不到的锁，被称为内部锁（监视器锁）。 原子性操作Atomcity：指执行一系列操作时，要么全部执行，要么全部不执行，不存在只执行一部分的问题。 线程的代码在进入synchronized的代码块时会自动获取内部锁，这时其它线程范文将会被阻塞挂起。而内置锁是排他锁，当一个线程获得这个锁后，其它线程必须等待该线程释放锁后才能获取该锁。因此会造成一个问题，就是当阻塞一个线程的时候，需要从用户态切换到内核态执行阻塞状态操作，这是很耗时的操作，而synchronized的使用就会导致上下文的切换。 synchronized用的锁是存在Java对象头里的。 偏向锁：加锁和解锁不需要额外的消耗 轻量锁：竞争的线程不会阻塞 重量锁：线程竞争不使用自旋，不会消耗CPU volatile 由于锁太笨重，会带来上下文的切换开销，杜宇解决内存可见性问题，Java还提供一种弱形式同步，就是使用volatile关键字，该关键字可以确保一个变量的更新和对其他线程马上可见。当一个变量被声明为一个volatile时，共享变量不会把值缓存到寄存器或者其他中，会直接更新到主内存中。 特性：可见性、原子性 实现原则 Locak前缀指令会引起处理器缓存直接写回到内存 一个处理器的缓存回写到内存会导致其它处理器的缓存无效 及和synchronized的使用区别在于，一个在于使用在方法上，一个使用在变量上。 虽然volatile提供了可见性保证，但并不保证操作的原子性。 内存可见性问题：当一个线程对共享变量进行修改的时候，另一线程能直接获取到修改后的共享变量 使用场所： 写入变量值不依赖变量的当前值。 读写变量值时没有加锁。 Java中的CAS操作 CAS及Compare And Swap，其是JDK提供的非阻塞原子性操作。 经典ABA问题 通过添加一个时间戳进行解决 ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:2:1","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"锁 ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:3:0","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"锁的内存语义 线程A释放一个锁，实际上是线程A向接下来要获取该锁的线程发送消息 线程B获取一个锁，实际上是线程B接收了某个线程发出的消息（在释放这个锁对共享变量进行修改的）消息 线程A释放锁，线程B接收到线程A释放的锁，实际上是线程A通过主内存向线程B发送消息。 ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:3:1","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"乐观锁和悲观锁 悲观锁 悲观锁的定义来源于数据库引入的名词，但在并发中也引入了此思想。 悲观锁指对外界修改持有保守态度，认为数据很容易被其它线程修改，所以在数据被处理前，先对数据加锁，并在整个数据处理对的过程中，使得数据处于锁定的状态。 乐观锁 乐观锁是相对悲观锁来说的，认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突进行检测。 ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:3:2","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["JUC"],"content":"公平锁和非公平锁 按照抢锁机制来划分 公平锁表示线程获取锁的顺序是按照线程的请求顺序来进行的。先到先得。 ReentrantLock提供公平与非公平锁的实现： // 公平锁 ReentrantLock pairLock = new ReentrantLock（true） // 非公平锁 ReentrantLock pariLock = new ReentrantLock（false） 在没有公平的需求下，尽量使用非公平锁，公平锁会带来性能开销。 独享锁与共享锁 按照锁被单个线程持有还是能被多个线程持有 独占锁 = 悲观锁 共享锁 = 乐观锁 ","date":"2020-10-20 16:10:04","objectID":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/:3:3","tags":["Java并发编程"],"title":"Java并发编程一","uri":"/2020/10/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%80/"},{"categories":["生活"],"content":"驾照 科目二 驾照 科目二 一、调整坐姿！！！，系安全带 启动：挂空挡，踩离合刹车，降手刹，转钥匙 离合踩死，刹车踩住，挂一档，松刹车，缓慢松离合 熄火：踩住离合，刹车，挂空挡！！！后，再点火启动，挂挡 一立：四分之一圈 ","date":"2020-10-18 21:28:57","objectID":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/:0:0","tags":["杂"],"title":"驾照科目二","uri":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/"},{"categories":["生活"],"content":"侧方停车 喷水孔：对准路中间，启动 看右后视镜，看右后轮挡泥板到黄线直角三分之一处，停车！ 向右打一圈，再挂后退档！！看左后视镜，盯左后轮挡泥板，快到了，向左打死方向盘 快速盯左车盖缝，头顶住车框看，到黄线立刻踩刹车 保持方向盘不动，挂一档，打左转向，启动 看左喷水孔，碰到黄线，向右打三圈半（及正常时向右打一圈）！！ ","date":"2020-10-18 21:28:57","objectID":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/:1:0","tags":["杂"],"title":"驾照科目二","uri":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/"},{"categories":["生活"],"content":"S弯 喷水孔，中间 盯左车盖缝，碰黄线后，打一圈一立（1.25圈），保持缝头只出去一丢丢 结束第一个完后，回正坐姿看左车盖缝，接触黄线后，立刻回正方向盘 看右喷水孔，碰第二个弯黄线后立刻向右打一圈一立，将喷水口维持在黄线内侧 快出弯道后，看右后视镜，判断车后轮离黄线距离，调整方向盘，让车轮离黄线越来越窄 ","date":"2020-10-18 21:28:57","objectID":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/:2:0","tags":["杂"],"title":"驾照科目二","uri":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/"},{"categories":["生活"],"content":"倒车入库 右倒车 倒车坐正，余光瞄后视镜底部，要到黄线时，向右打死方向盘，挂后退档 看左后视镜，到方框前第一个角时，回正半圈，看到框后角，回正方向盘 调整左车距，余光瞄后视镜底部，一过车左前黄线，刹车！ 左倒车 挂一档，正出，当车门角与车前左黄线呈直角时向左打一圈半 当车锁压到黄线，停车，换挡 微调，倒车，先看左后视镜，判断车尾离黄线角的距离，距离大打死方向盘 而后马上看右后视镜，看到第一个角，回正半圈（此时方向盘正），看到第二个角全部回正，立马看左后视镜，余光瞄后视镜底部，准备刹车。 出去 挂一档，正出，当车门角与车前做黄线呈直角，向右打一圈半 ","date":"2020-10-18 21:28:57","objectID":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/:3:0","tags":["杂"],"title":"驾照科目二","uri":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/"},{"categories":["生活"],"content":"直角转弯 将左喷水孔对前方道路准调整至三分之一处靠右 向左打转向灯（注意听播报） 关闭转向灯（听播报） 当车门锁对准左黄线时，打死方向盘 自己判读调回车身 ","date":"2020-10-18 21:28:57","objectID":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/:4:0","tags":["杂"],"title":"驾照科目二","uri":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/"},{"categories":["生活"],"content":"坡道定点停车和起步 喷水口对准道路正中间，调整车身 坐直，余光瞄左后视镜底部，一到黄线，立马双脚踩刹车（左脚微微先踩离合，右脚踩刹车） 停好后，按住手刹提起超过两秒（按住不能放！！！）在下压 准备启动，将方向盘朝左打一立，双脚同时松开快速！！！！！ tips：双脚不同时松开容易熄火！！！熄火后，记得挂空挡，再点火，再挂一档（记得挂档，离合，刹车踩住）再双脚同时松开。 ","date":"2020-10-18 21:28:57","objectID":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/:5:0","tags":["杂"],"title":"驾照科目二","uri":"/2020/10/%E9%A9%BE%E7%85%A7%E7%A7%91%E7%9B%AE%E4%BA%8C/"},{"categories":["Java基础"],"content":"Map ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:0:0","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"HashMap、HashTable、ConcurrnetHashMap ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:1:0","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"HashMap 与 HashTable 差别 线程是否安全：HashMap是非线程安全，HashTable是线程安全的，因为HashTable内部的方法都是经过synchronized修饰过得。 效率：因为线程安全的问题，所以HashMap的效率会比HashTable高一些。且HashTable已经基本被淘汰 对 null key 和 null value 的支持：HashMapkey存储null的key和value，但null作为键只能有一个，null作为值可以有多个；HashTable不允许有null键和null值，否则会抛出NullPointerException。 初始容量大小和每次扩容容量的大小不一：① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小。 底层数据结构：JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。 /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n \u003e\u003e\u003e 1; n |= n \u003e\u003e\u003e 2; n |= n \u003e\u003e\u003e 4; n |= n \u003e\u003e\u003e 8; n |= n \u003e\u003e\u003e 16; return (n \u003c 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:1:1","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"HashMap和 HashSet的区别 HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。 HashMap HashSet 实现了 Map 接口 实现 Set 接口 存储键值对 仅存储对象 调用 put()向 map 中添加元素 调用 add()方法向 Set 中添加元素 HashMap 使用键（Key）计算 Hashcode HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以 equals()方法用来判断对象的相等性， ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:1:2","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"HashMap 和 TreeMap 区别 TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。 实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。 实现SortMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下： public class Person { private Integer age; public Person(Integer age) { this.age = age; } public Integer getAge() { return age; } public static void main(String[] args) { TreeMap\u003cPerson, String\u003e treeMap = new TreeMap\u003c\u003e(new Comparator\u003cPerson\u003e() { @Override public int compare(Person person1, Person person2) { int num = person1.getAge() - person2.getAge(); return Integer.compare(num, 0); } }); treeMap.put(new Person(3), \"person1\"); treeMap.put(new Person(18), \"person2\"); treeMap.put(new Person(35), \"person3\"); treeMap.put(new Person(16), \"person4\"); treeMap.entrySet().stream().forEach(personStringEntry -\u003e { System.out.println(personStringEntry.getValue()); }); } } person1 person4 person2 person3 上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式： TreeMap\u003cPerson, String\u003e treeMap = new TreeMap\u003c\u003e((person1, person2) -\u003e { int num = person1.getAge() - person2.getAge(); return Integer.compare(num, 0); }); 综上，相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。 ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:1:3","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"HashMap 和 ConcurrentHashMap差别 ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； 实现线程安全的方式（重要）： ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 JDK1.8 的 ConcurrentHashMap 不在是 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。当冲突链表达到一定长度时，链表会转换成红黑树。 ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:1:4","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"HashMap原理 ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:2:0","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"HashMap的底层实现 JDK1.8之前 JDK1.8之前 HashMap 的底层是 数组和链表结合使用及 链表散列。HashMap通过Key的hashcode经过扰动函数处理后得到hash值，然后通过（n - 1）\u0026 hash 判断当前元素存放的位置（这里n指数组的长度），如果当前位置存在元素的话，就判断当期元素的hash值以及key是否相同，如果相同的话直接覆盖，不相同的话就通过拉链法解决冲突。 所谓的扰动函数指的就是HashMap的hash方法。使用hash方法就是扰动函数实现一些比较差的hashCode（）方法，及使用扰动函数后可以减少碰撞。 JDK1.8 HashMap的hash方法： JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。 static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // \u003e\u003e\u003e:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16); }Copy to clipboardErrorCopied 对比一下 JDK1.7 的 HashMap 的 hash 方法源码. static int hash(int h) { // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12); return h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4); } 相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。 所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。 JDK1.8之后： 相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。 HashMap的长度为什么是2的幂次方 为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) \u0026 hash”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。 这个算法应该如何设计呢？ 我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(\u0026)操作（也就是说 hash%length==hash\u0026(length-1)的前提是 length 是 2 的 n 次方；）。” 并且 采用二进制位操作 \u0026，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方 ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:2:1","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"红黑树 ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:3:0","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"红黑树特性 每个节点非红即黑 根节点总是黑色的 每个叶子节点都是黑色的空节点（NIL节点） 如果节点是红色的，则它的子节点必须是黑色的 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑节点 ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:3:1","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"应用： TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树 ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:3:2","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"为什么要用红黑树 简单来说红黑树解决了二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构 ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:3:3","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Java基础"],"content":"红黑树这么优秀,为何不直接使用红黑树得了? 说一下自己对于这个问题的看法：我们知道红黑树属于（自）平衡二叉树，但是为了保持“平衡”是需要付出代价的，红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，这费事啊。你说说我们引入红黑树就是为了查找数据快，如果链表长度很短的话，根本不需要引入红黑树的，你引入之后还要付出代价维持它的平衡。但是链表过长就不一样了。至于为什么选 8 这个值呢？通过概率统计所得，这个值是综合查询成本和新增元素成本得出的最好的一个值。 ","date":"2020-10-17 20:11:56","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/:3:4","tags":["集合框架"],"title":"集合框架-Map","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-map/"},{"categories":["Spring"],"content":"SpringBoot 核心源码分析 ","date":"2020-10-17 14:55:50","objectID":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:0","tags":["SpringBoot"],"title":"SpringBoot核心源码分析","uri":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["Spring"],"content":"convention over configuration 约定优于配置 SprinBoot 核心特性：约定优于配置 举一个具体一点的例子，这个理念我们其实一直都在遵循并使用，比如我们在 MVC 项目的开发中会把实体类放到 entity 目录下、数据接口层会定义在 dao 目录下、控制器会定义在 controller 目录下，这就是大家都遵循的规矩，如果在项目中遵守命名规范就可以显著地减少系统需要的配置，不然目录名、包名乱取名字这些都会使得配置难度增大。这个理念在很多地方都有使用，比如我们常用的 SpringMVC 框架就能够找到很多设计是遵循这个理念，想要详细了解的可以去查一下convention over configuration的相关资料。 也就是说，SpringBoot 遵循“约定优于配置”这个理念，但是这个理念绝对不是 SpringBoot 所独有的，这个理念也不是由 Spring Boot 框架所创造出来的概念，Spring Boot 能够精简配置提升开发者的工作效率，并不仅仅因为 “约定优于配置” 这个特性，而是因为 Spring Boot 框架中众多的自动化配置类及相关优秀的程序设计导致的，这些自动化配置类在类路径下META-INF/spring.factories文件中，通过@EnableAutoConfiguration注解加载到容器中并发挥作用，从而使得开发这在使用 SpringBoot 框架甚至可以做到零配置就能够快速构建出所需的应用。 ","date":"2020-10-17 14:55:50","objectID":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:0","tags":["SpringBoot"],"title":"SpringBoot核心源码分析","uri":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["Spring"],"content":"SpringBoot 依赖管理 \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.3.4.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e 对spring-boot-starter-parent按住command进入查看其源码： \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.3.4.RELEASE\u003c/version\u003e \u003c/parent\u003e 发现该项目依赖于一个父项目 spring-boot-starter-parent，再进入该项目里面： \u003cproperties\u003e \u003cactivemq.version\u003e5.15.13\u003c/activemq.version\u003e \u003cantlr2.version\u003e2.7.7\u003c/antlr2.version\u003e \u003cappengine-sdk.version\u003e1.9.82\u003c/appengine-sdk.version\u003e \u003cartemis.version\u003e2.12.0\u003c/artemis.version\u003e \u003caspectj.version\u003e1.9.6\u003c/aspectj.version\u003e \u003cassertj.version\u003e3.16.1\u003c/assertj.version\u003e \u003catomikos.version\u003e4.0.6\u003c/atomikos.version\u003e \u003cawaitility.version\u003e4.0.3\u003c/awaitility.version\u003e \u003cbitronix.version\u003e2.1.4\u003c/bitronix.version\u003e \u003cbuild-helper-maven-plugin.version\u003e3.1.0\u003c/build-helper-maven-plugin.version\u003e \u003cbyte-buddy.version\u003e1.10.14\u003c/byte-buddy.version\u003e \u003ccaffeine.version\u003e2.8.5\u003c/caffeine.version\u003e \u003ccassandra-driver.version\u003e4.6.1\u003c/cassandra-driver.version\u003e \u003cclassmate.version\u003e1.5.1\u003c/classmate.version\u003e \u003ccommons-codec.version\u003e1.14\u003c/commons-codec.version\u003e \u003ccommons-dbcp2.version\u003e2.7.0\u003c/commons-dbcp2.version\u003e \u003ccommons-lang3.version\u003e3.10\u003c/commons-lang3.version\u003e \u003ccommons-pool.version\u003e1.6\u003c/commons-pool.version\u003e \u003ccommons-pool2.version\u003e2.8.1\u003c/commons-pool2.version\u003e \u003ccouchbase-client.version\u003e3.0.8\u003c/couchbase-client.version\u003e \u003cdb2-jdbc.version\u003e11.5.4.0\u003c/db2-jdbc.version\u003e \u003cdependency-management-plugin.version\u003e1.0.10.RELEASE\u003c/dependency-management-plugin.version\u003e \u003cderby.version\u003e10.14.2.0\u003c/derby.version\u003e \u003cdropwizard-metrics.version\u003e4.1.12.1\u003c/dropwizard-metrics.version\u003e \u003cehcache.version\u003e2.10.6\u003c/ehcache.version\u003e \u003cehcache3.version\u003e3.8.1\u003c/ehcache3.version\u003e \u003celasticsearch.version\u003e7.6.2\u003c/elasticsearch.version\u003e 进入之后可以发现，该 pom 文件中定义了大量的依赖信息，如 commons 相关依赖、log 相关依赖、数据库相关依赖、Spring 相关依赖、elastic search 搜索引擎相关依赖、消息队列相关依赖等等，J2EE 项目开发中所涉及到的大部分功能场景的依赖都定义在这个 pom 文件中，这里就是 Spring Boot 项目依赖的版本管理中心。 版本管理中心已经默认帮我们配置好了大部分依赖的版本信息，这些版本信息随着 Spring Boot 版本的更新也会随之更改，这个设计让我们在今后导入依赖时不需要写版本，直接使用其默认版本即可，当然也可以自行修改版本号，但是没有在 dependencies 里默认管理的依赖仍然需要声明其版本号。 结合前一小节中的“约定优于配置”特性，我们可以这样理解：Spring Boot 默认帮我们设置了默认编码、默认 JDK 版本及 maven 编译的默认设置，同时维护了一套项目依赖的配置，需要使用哪个依赖直接导入即可并不需要声明其版本号。这就是 Spring Boot 其中的一个开发约定，咱们如果认可这个约定就可以减少一些基本配置和很多依赖配置，如果不认可这种方式也可以自行配置，这些配置会将默认配置覆盖掉。 ","date":"2020-10-17 14:55:50","objectID":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:2:0","tags":["SpringBoot"],"title":"SpringBoot核心源码分析","uri":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["Spring"],"content":"SpringBoot 主程序类 package com.ttt.chacha.chacha; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @MapperScan(\"com.ttt.chacha.chacha.dao\") @SpringBootApplication // 标注这是一个springboot应用 public class ChachaApplication { public static void main(String[] args) { SpringApplication.run(ChachaApplication.class, args); } } ","date":"2020-10-17 14:55:50","objectID":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:0","tags":["SpringBoot"],"title":"SpringBoot核心源码分析","uri":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["Spring"],"content":"@SpringBootApplication 源码内容（去注解）： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { @AliasFor(annotation = EnableAutoConfiguration.class) Class\u003c?\u003e[] exclude() default {}; @AliasFor(annotation = EnableAutoConfiguration.class) String[] excludeName() default {}; @AliasFor(annotation = ComponentScan.class, attribute = \"basePackages\") String[] scanBasePackages() default {}; @AliasFor(annotation = ComponentScan.class, attribute = \"basePackageClasses\") Class\u003c?\u003e[] scanBasePackageClasses() default {}; @AliasFor(annotation = ComponentScan.class, attribute = \"nameGenerator\") Class\u003c? extends BeanNameGenerator\u003e nameGenerator() default BeanNameGenerator.class; @AliasFor(annotation = Configuration.class) boolean proxyBeanMethods() default true; } @Target（ElementType.TYPE）：类、接口（包括注解类型）和 enum 声明 @Retention（RetentionPolicy.RUNTIME）：运行时注解 @Documented：注解添加到Java doc中 @Inherited：允许继承 @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) 这三个为Spring Boot框架的自定义注解： @SpringBootConfiguration：SpringBoot 配置注解 @EnableAutoConfiguration：启用自动配置注解 @ComponentScan：组件自动扫描注解 可以简单的将 @SpringBootApplication 注解理解为 @SpringBootConfiguration 、@EnableAutoConfiguration 和 @ComponentScan 这三个注解的组合注解，如果在主程序类中不使用 @SpringBootApplication 注解，在主程序类上直接标注 @SpringBootConfiguration、@EnableAutoConfiguration 和 @ComponentScan 这三个注解的效果也是一样的。 ","date":"2020-10-17 14:55:50","objectID":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:1","tags":["SpringBoot"],"title":"SpringBoot核心源码分析","uri":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["Spring"],"content":"@SpringBootConfiguration @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Configuration public @interface SpringBootConfiguration { @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true; } 主要用于定义配置类，代替XML配置文件。@SpringBootConfiguration 注解仅仅是对 @Configuration 注解进行了包装，本质上依然是 @Configuration 注解，@SpringBootConfiguration 注解是 1.4 版本中新增的注解，标注在某个类上，表示这是一个 Spring Boot 的配置类。 ","date":"2020-10-17 14:55:50","objectID":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:2","tags":["SpringBoot"],"title":"SpringBoot核心源码分析","uri":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["Spring"],"content":"@EnableAutoConfiguration @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ Class\u003c?\u003e[] exclude() default {}; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ String[] excludeName() default {}; } 代表开启自动配置功能。 除 Java 元注解外，这个注解最重要的就是 @AutoConfigurationPackage 注解 和 AutoConfigurationImportSelector 组件。 @AutoConfigurationPackage 注解源码如下： @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Import(AutoConfigurationPackages.Registrar.class) public @interface AutoConfigurationPackage { } 该注解中中包含 Spring 框架的 @Import 注解，其作用就是将标注了该注解的组件注册到 Spring 的 IOC 容器中，而导入哪些内容则由 AutoConfigurationPackages.Registrar.class 指定，即 Spring Boot 会注册自动配置包的名称，默认情况下是当前主程序类所在的包及其子包，这些包中的组件会被加载进容器中，如果是写到其他包中的组件默认是无法被扫描进来的，这也是为什么某些开发者在配置了组件后无法被加载的原因，希望大家注意。 EnableAutoConfigurationImportSelector 是整个自动配置功能的核心实现，负责返回自动配置的相关组件名称以注册至 IOC 容器中，主要实现如下： public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered { ...省略部分代码 @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } //调用 AutoConfigurationMetadataLoader.loadMetadata()方法获取自动配置元数据 AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry( autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } protected AutoConfigurationEntry getAutoConfigurationEntry( AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); // 获取自动装配配置项 List\u003cString\u003e configurations = getCandidateConfigurations(annotationMetadata, attributes); // 去重 configurations = removeDuplicates(configurations); // 获取停用配置项(开发者自行设置的，排除哪些不需要自动配置的组件) Set\u003cString\u003e exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); // 移除停用配置项 configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); // 返回所有的自动装配配置 return new AutoConfigurationEntry(configurations, exclusions); } @Override public Class\u003c? extends Group\u003e getImportGroup() { return AutoConfigurationGroup.class; } //该方法判断是否开启自动配置 protected boolean isEnabled(AnnotationMetadata metadata) { if (getClass() == AutoConfigurationImportSelector.class) { //获取 spring.boot.enableautoconfiguration 的值是 true 还是 false，默认为true return getEnvironment().getProperty( EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY, Boolean.class, true); } return true; } protected List\u003cString\u003e getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { // 从META-INF/spring.factories中获取 EnableAutoConfiguration 的所有配置项 List\u003cString\u003e configurations = SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; } getCandidateConfigurations() 方法会调用 SpringFactoriesLoader 类的 loadFactoryNames() 获取所有的自动配置类类名，源码如下： public final class SpringFactoriesLoader { //配置文件名称 public static final String FACTORIES_RESOURCE_LO","date":"2020-10-17 14:55:50","objectID":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:3","tags":["SpringBoot"],"title":"SpringBoot核心源码分析","uri":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["Spring"],"content":"@ComponentScan 做过 Spring 项目的朋友一定都有用过 @Controller 、 @Service 、 @Repository 注解，查看其源码会发现，他们中有一个共同的注解 @Component，而 @ComponentScan 注解默认就会装配标识了 @Controller 、 @Service 、 @Repository 、 @Component 注解的类到 Spring IOC 容器中。 在普通的 Spring 项目开发中，会在 Spring 配置文件中编写如下配置，将对应包下的所有组件扫描并注册到容器中： \u003c!-- 自动扫描 --\u003e \u003ccontext:component-scan base-package=\"com.ssm.demo.dao\"/\u003e \u003ccontext:component-scan base-package=\"com.ssm.demo.service\"/\u003e \u003ccontext:component-scan base-package=\"com.ssm.demo.controller\"/\u003e 使用注解的方式与这种 xml 配置文件方式实现的效果是相同的，@ComponentScan 注解的作用就是让 Spring 容器知道从哪些包下获取需要注册的 bean ，开发者通过注解来定义哪些包需要被自动扫描并装配，一旦指定了相应的包名， Spring 将会将在被指定的包及其子包中寻找标注了以上注解的 bean 并注册至容器中。 ","date":"2020-10-17 14:55:50","objectID":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:4","tags":["SpringBoot"],"title":"SpringBoot核心源码分析","uri":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["Spring"],"content":"SpringApplication.run() public class SpringApplication { ...省略部分代码 public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); // 代码执行时间监控开启 stopWatch.start(); ConfigurableApplicationContext context = null; Collection\u003cSpringBootExceptionReporter\u003e exceptionReporters = new ArrayList\u003c\u003e(); // 配置 headless 属性，默认为 true configureHeadlessProperty(); // 获取 SpringApplicationRunListener SpringApplicationRunListeners listeners = getRunListeners(args); // 回调所有 SpringApplicationRunListener 对象的 starting()方法 listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 创建 Environment 对象并回调 SpringApplicationRunListener 对象的 environmentPrepared() 方法 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 配置 Environment configureIgnoreBeanInfo(environment); // 获取打印的 spring boot banner Banner printedBanner = printBanner(environment); // 创建ApplicationContext实例 context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); // 配置 ApplicationContext 实例 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 刷新 ApplicationContext 实例 refreshContext(context); // refresh()方法成功回调 afterRefresh(context, applicationArguments); // 代码执行时间监控结束，即启动应用花费了多少时间 stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } // 回调监听处理器 listeners.started(context); // 调用 Runner 回调 callRunners(context, applicationArguments); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); } try { listeners.running(context); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); } return context; } } 执行流程 SpringApplication将一个典型的spring应用启动的流程“模板化”，默认模板化后执行流程就可以满足需求了，如果有特殊需求，SpringApplication在合适的流程节点开放了一系列不同类型的扩展点，我们可以通过这些扩展点对SpringBoot程序的启动和关闭过程进行扩展。 如果我们使用的是SpringApplication的静态run方法，首先需要创建一个SpringApplication对象实例。 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitialize 使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener 设置main方法的定义类 开始执行run方法的逻辑，首先遍历执行所有通过SpringFactoriesLoader加载到的SpringApplicationRunListener，调用它们的started()方法，告诉这些SpringApplicationRunListener，SpringBoot应用要开始执行了。 创建并配置当前SpringBoot应用将要使用的Environment 遍历并调用所有的SpringApplicationRunListener的environmentPrepared()方法，告诉它们，Springboot应用使用的Environment准备好了 确定SpringBoot应用创建什么类型的ApplicationContext，并创建完成，然后根据条件决定是否使用自定义的ShutdownHook，是否使用自定义的BeanNameGenerator，是否使用自定义的ResourceLoader，然后将准备好的Environment设置给创建好的ApplicationContext使用 ApplicationContext创建完成，SpringApplication调用之前加载的ApplicationContextInitialize的initialize方法对创建好的ApplicationContext进行进一步的处理 遍历所有SpringApplicationRunListener的contextPrepared()方法，通知它们，SpringBoot应用使用的ApplicationContext准备好了 将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的Ioc容器配置加载到已经你准备完毕的ApplicationContext 遍历所有的SpringApplicationRunListener的contextLoader()方法，告知ApplicationContext已装载完毕 调用ApplicationContext的refresh()方法，完成Ioc容器可用的最后一道工序 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们 遍历所有的SpringApplicationRunListener的finished()方法，告知，“初始化完成” ","date":"2020-10-17 14:55:50","objectID":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:3:5","tags":["SpringBoot"],"title":"SpringBoot核心源码分析","uri":"/2020/10/springboot%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["Spring"],"content":"Web 功能开发（一） ","date":"2020-10-17 11:03:10","objectID":"/2020/10/web%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%911/:0:0","tags":["web"],"title":"Web功能开发（一）","uri":"/2020/10/web%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%911/"},{"categories":["Spring"],"content":"DispatchServlet 简介 ","date":"2020-10-17 11:03:10","objectID":"/2020/10/web%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%911/:1:0","tags":["web"],"title":"Web功能开发（一）","uri":"/2020/10/web%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%911/"},{"categories":["Spring"],"content":"自动配置 Web开发必不可缺的两个类： DispatcherServletAutoConfiguration（ DispatchServlet 生效） WebMvcAutoConfiguration （视图解析器、静态资源处理等） SpringBoot 为 SpringMVC 提供自动配置： 自动配置在Spring的默认值之上添加了以下功能： 包含ContentNegotiatingViewResolver和BeanNameViewResolver beans。 支持提供静态资源，包括对WebJars的支持。 自动注册Converter，GenericConverter和Formatter beans。 支持HttpMessageConverters。 自动注册MessageCodesResolver。 静态index.html支持。 自定义Favicon支持。 自动使用ConfigurableWebBindingInitializer bean。 ","date":"2020-10-17 11:03:10","objectID":"/2020/10/web%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%911/:2:0","tags":["web"],"title":"Web功能开发（一）","uri":"/2020/10/web%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%911/"},{"categories":["生活"],"content":"IntelliJ-IDEA MAC中的常用快捷键（从win10过渡过来） 从 Windows 过度到 Mac 必备快捷键对照表 ","date":"2020-10-17 10:25:12","objectID":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/:0:0","tags":["杂"],"title":"Intellij-IDEA的MAC快捷键","uri":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["生活"],"content":"Mac 键盘符号 图标 介绍 ⌘ Command ⇧ Shift ⇪ Caps Lock ⌥ Option = Alt ⌃ Control ↩ Enter ⌫ Delete ⌦ Fn + Delete ↑ 上箭头 ↓ 下箭头 ← 左箭头 → 右箭头 ⇞ Fn + ↑ = Page Up ⇟ Fn + ↓ = Page Down Home Fn + ← End Fn + → ⇥ Tab = 右制表符 ⇤ Shift + Tab = 左制表符 ⎋ Esc = Escape ⏏ 电源开关键 ","date":"2020-10-17 10:25:12","objectID":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:0","tags":["杂"],"title":"Intellij-IDEA的MAC快捷键","uri":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["生活"],"content":"Alt Win 快捷键 Mac 快捷键 介绍 Alt + ` Control + V 显示版本控制常用操作菜单弹出层 Alt + F1 Option + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 Alt + F7 Option + F7 查询所选对象/变量被引用 Alt + Enter Option + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 Alt + Insert Command + N 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 Alt + 左方向键 Control + 左方向键 切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 Alt + 右方向键 Control + 右方向键 切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 Alt + 前方向键 Control + 前方向键 当前光标跳转到当前文件的前一个方法名位置 Alt + 后方向键 Control + 后方向键 当前光标跳转到当前文件的后一个方法名位置 Alt + 1,2,3…9 Command + 1,2,3…9 显示对应数值的选项卡，其中 1 是 Project 用得最多 ","date":"2020-10-17 10:25:12","objectID":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/:2:0","tags":["杂"],"title":"Intellij-IDEA的MAC快捷键","uri":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["生活"],"content":"Ctrl Win 快捷键 Mac 快捷键 介绍 Ctrl + F Command + F 在当前文件进行文本查找 Ctrl + R Command + R 在当前文件进行文本替换 Ctrl + Z Command + Z 撤销 Ctrl + G Command + L 跳转到指定行数位置 Ctrl + Y Command + Delete 删除光标所在行 或 删除选中的行 Ctrl + D Command + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 Ctrl + W Option + 方向键上 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 Ctrl + E Command + E 显示最近打开的文件记录列表 Ctrl + N Command + O 根据输入的 类名 查找类文件 Ctrl + J Command + J 插入自定义动态代码模板 Ctrl + P Command + P 方法参数提示显示 Ctrl + Q Control + J 当前位置变量、方法的 Documentation 内容显示 Ctrl + U Command + U 前往当前光标所在的方法的父类的方法 / 接口定义 Ctrl + B Command + B 进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 Ctrl + / Command + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 Ctrl + F1 Command + F1 在光标所在的错误代码处显示错误信息 Ctrl + F11 Option + F3 选中文件 / 文件夹，使用助记符设定 / 取消书签 Ctrl + F12 Command + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Space Control + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 Ctrl + Delete Option + Fn+ Delete 删除光标后面的单词或是中文句 Ctrl + BackSpace Option + Delete 删除光标前面的单词或是中文句 Ctrl + 1,2,3…9 Control + 1,2,3…9 定位到对应数值的书签位置 Ctrl + 加号 Command + 加号 展开代码 Ctrl + 减号 Command + 减号 折叠代码 Ctrl + 左键单击 Control + 左键单击 在打开的文件标题上，弹出该文件路径 Ctrl + 左方向键 Option + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置 Ctrl + 右方向键 Option + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置 Ctrl + 前方向键 预设中没有该快捷键 等效于鼠标滚轮向前效果 Ctrl + 后方向键 预设中没有该快捷键 等效于鼠标滚轮向后效果 ","date":"2020-10-17 10:25:12","objectID":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/:3:0","tags":["杂"],"title":"Intellij-IDEA的MAC快捷键","uri":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["生活"],"content":"Shift Win 快捷键 Mac 快捷键 介绍 Shift + F11 Command + F3 弹出书签显示层 Shift + Tab Shift + Tab 取消缩进 Shift + Enter Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 Shift + 左键单击 Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 ","date":"2020-10-17 10:25:12","objectID":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/:4:0","tags":["杂"],"title":"Intellij-IDEA的MAC快捷键","uri":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["生活"],"content":"Alt + Shift Win 快捷键 Mac 快捷键 介绍 Alt + Shift + N Option + Shift + N 选择 / 添加 task Alt + Shift + 左键双击 Option + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 Alt + Shift + 前方向键 Option + Shift + 前方向键 移动光标所在行向上移动 Alt + Shift + 后方向键 Option + Shift + 后方向键 移动光标所在行向下移动 ","date":"2020-10-17 10:25:12","objectID":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/:5:0","tags":["杂"],"title":"Intellij-IDEA的MAC快捷键","uri":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["生活"],"content":"Ctrl + Alt Win 快捷键 Mac 快捷键 介绍 Ctrl + Alt + L Command + Option + L 格式化代码，可以对当前文件和整个包目录使用 Ctrl + Alt + O Control + Option + O 优化导入的类，可以对当前文件和整个包目录使用 Ctrl + Alt + T Command + Option + T 对选中的代码弹出环绕选项弹出层 Ctrl + Alt + S Command + 逗号 打开 IntelliJ IDEA 系统设置 Ctrl + Alt + Enter Command + Option + Enter 光标所在行上空出一行，光标定位到新行 Ctrl + Alt + 左方向键 Command + Option + 左方向键 退回到上一个操作的地方 Ctrl + Alt + 右方向键 Command + Option + 右方向键 前进到上一个操作的地方 ","date":"2020-10-17 10:25:12","objectID":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/:6:0","tags":["杂"],"title":"Intellij-IDEA的MAC快捷键","uri":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["生活"],"content":"Ctrl + Shift Win 快捷键 Mac 快捷键 介绍 Ctrl + Shift + F Command + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 Ctrl + Shift + R Command + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 Ctrl + Shift + J Control + Shift + J 自动将下一行合并到当前行末尾 Ctrl + Shift + Z Command + Shift + Z 取消撤销 Ctrl + Shift + W Option + 方向键下 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 Ctrl + Shift + N Command + Shift + O 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 Ctrl + Shift + U Command + Shift + U 对选中的代码进行大 / 小写轮流转换 Ctrl + Shift + T Command + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 Ctrl + Shift + C Command + Shift + C 复制当前文件磁盘路径到剪贴板 Ctrl + Shift + B Control + Shift + B 跳转到类型声明处 Ctrl + Shift + / Command + Option + / 代码块注释 Ctrl + Shift + [ Command + Shift + [ 选中从光标所在位置到它的顶部中括号位置 Ctrl + Shift + ] Command + Shift + ] 选中从光标所在位置到它的底部中括号位置 Ctrl + Shift + 加号 Command + Shift + 加号 展开所有代码 Ctrl + Shift + 减号 Command + Shift + 减号 折叠所有代码 Ctrl + Shift + F7 Command + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失 Ctrl + Shift + F12 Command + Shift + F12 编辑器最大化 Ctrl + Shift + Enter Command + Shift + Enter 自动结束代码，行末自动添加分号 Ctrl + Shift + Backspace Ctrl + Shift + Backspace 退回到上次修改的地方 Ctrl + Shift + 1,2,3…9 Control + Shift + 1,2,3…9 快速添加指定数值的书签 Ctrl + Shift + 左键单击 Command + Shift + 左键单击 把光标放在某个类变量上，按此快捷键可以直接定位到该类中 Ctrl + Shift + 左方向键 Option + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 右方向键 Option + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 前方向键 Command + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 Ctrl + Shift + 后方向键 Command + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 ","date":"2020-10-17 10:25:12","objectID":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/:7:0","tags":["杂"],"title":"Intellij-IDEA的MAC快捷键","uri":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["生活"],"content":"Ctrl + Shift + Alt Win 快捷键 Mac 快捷键 介绍 Ctrl + Shift + Alt + V Command + Shift + Option + V 无格式黏贴 Ctrl + Shift + Alt + S Command + ; 打开当前项目设置 ","date":"2020-10-17 10:25:12","objectID":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/:8:0","tags":["杂"],"title":"Intellij-IDEA的MAC快捷键","uri":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["生活"],"content":"Other Win 快捷键 Mac 快捷键 介绍 F2 F2 跳转到下一个高亮错误 或 警告位置 F4 F4 编辑源 F11 F3 添加书签 F12 F12 回到前一个工具窗口 Tab Tab 缩进 ESC ESC 从工具窗口进入代码文件窗口 ","date":"2020-10-17 10:25:12","objectID":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/:9:0","tags":["杂"],"title":"Intellij-IDEA的MAC快捷键","uri":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["生活"],"content":"参考链接 https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-win-mac.md ","date":"2020-10-17 10:25:12","objectID":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/:10:0","tags":["杂"],"title":"Intellij-IDEA的MAC快捷键","uri":"/2020/10/intellij-idea%E7%9A%84mac%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["Java基础"],"content":"Collection-Set ","date":"2020-10-15 19:49:15","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/:0:0","tags":["集合框架"],"title":"集合框架-Set","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/"},{"categories":["Java基础"],"content":"Comparable 和 Compator comparable 接口实际上是出自 java.lang 包 它有一个 compareTo(Object obj)方法用来排序。 comparator 接口实际是出自 java.util 包它有一个 compare(Object obj1, Object obj2)方法用来排序 一般对一个集合使用自定义排序时，就要重写 compareTo() 方法或 compare() 方法。 当需要对某一个集合实现两种排序方法的时候可以重写 compreTo() 或 Comparator() 方法或者两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort(). ","date":"2020-10-15 19:49:15","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/:1:0","tags":["集合框架"],"title":"集合框架-Set","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/"},{"categories":["Java基础"],"content":"Comparator定制排序 // 定制排序的用法 从大到小的排序 Collections.sort(arrayList, new Comparator\u003cInteger\u003e() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); } }); 重写 compareTo 方法实现年龄排序 // person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列 // 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他 // 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了 public class Person implements Comparable\u003cPerson\u003e { private String name; private int age; public Person(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } /** * T重写compareTo方法实现按年龄来排序 */ @Override public int compareTo(Person o) { if (this.age \u003e o.getAge()) { return 1; } if (this.age \u003c o.getAge()) { return -1; } return 0; } } public static void main(String[] args) { TreeMap\u003cPerson, String\u003e pdata = new TreeMap\u003cPerson, String\u003e(); pdata.put(new Person(\"张三\", 30), \"zhangsan\"); pdata.put(new Person(\"李四\", 20), \"lisi\"); pdata.put(new Person(\"王五\", 10), \"wangwu\"); pdata.put(new Person(\"小红\", 5), \"xiaohong\"); // 得到key的值的同时得到key所对应的值 Set\u003cPerson\u003e keys = pdata.keySet(); for (Person key : keys) { System.out.println(key.getAge() + \"-\" + key.getName()); } } 5-小红 10-王五 20-李四 30-张三 ","date":"2020-10-15 19:49:15","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/:1:1","tags":["集合框架"],"title":"集合框架-Set","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/"},{"categories":["Java基础"],"content":"无序性和不可重复性 无序性指的不是顺序的无序，而是指存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。 不可重复性，指添加的元素按照equals()判断时，返回false，需要同时重写equals（）方法和 HashCode（）方法。 ","date":"2020-10-15 19:49:15","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/:2:0","tags":["集合框架"],"title":"集合框架-Set","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/"},{"categories":["Java基础"],"content":"HashSet、LinkedHashSet 和 TreeSet HashSet 是 Set 接口的主要实现类，HashSet 的底层是 HashMap，线程不安全，可以存储null值。 LinkedHashSet 是 HashSet 子类，可按照添加的顺序遍历。 TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。 ","date":"2020-10-15 19:49:15","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/:3:0","tags":["集合框架"],"title":"集合框架-Set","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/"},{"categories":["Java基础"],"content":"HashSet 如何检查重复 当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。（摘自我的 Java 启蒙书《Head fist java》第二版） hashCode()与 equals()的相关规定： 如果两个对象相等，则 hashcode 一定也是相同的 两个对象相等,对两个 equals 方法返回 true 两个对象有相同的 hashcode 值，它们也不一定是相等的 综上，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。 ==与 equals 的区别 对于基本类型来说，== 比较的是值是否相等； 对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）； 对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。 ","date":"2020-10-15 19:49:15","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/:4:0","tags":["集合框架"],"title":"集合框架-Set","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-set/"},{"categories":["算法"],"content":"BFS ","date":"2020-10-14 23:27:32","objectID":"/2020/10/bfs/:0:0","tags":["BFS"],"title":"BFS","uri":"/2020/10/bfs/"},{"categories":["算法"],"content":"例题 // 计算从起点 start 到终点 target 的最近距离 int BFS(Node start, Node target) { Queue\u003cNode\u003e q; // 核心数据结构 Set\u003cNode\u003e visited; // 避免走回头路 q.offer(start); // 将起点加入队列 visited.add(start); int step = 0; // 记录扩散的步数 while (q not empty) { int sz = q.size(); /* 将当前队列中的所有节点向四周扩散 */ for (int i = 0; i \u003c sz; i++) { Node cur = q.poll(); /* 划重点：这里判断是否到达终点 */ if (cur is target) return step; /* 将 cur 的相邻节点加入队列 */ for (Node x : cur.adj()) if (x not in visited) { q.offer(x); visited.add(x); } } /* 划重点：更新步数在这里 */ step++; } } 例题：二叉树的最小深度（类似层序遍历） /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int minDepth(TreeNode root) { if(root == null) { return 0; } Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); queue.offer(root); int depth = 1; while (!queue.isEmpty()) { int len = queue.size(); for(int i=0; i\u003clen; i++) { TreeNode node = queue.poll(); if(node.left == null \u0026\u0026 node.right == null) { return depth; } if(node.left != null) { queue.offer(node.left); } if(node.right != null) { queue.offer(node.right); } } depth++; } return depth; } } 再来看看DFS的解法 class Solution { public int minDepth(TreeNode root) { if (root == null) return 0; if (root.left == null) return 1 + minDepth(root.right); if (root.right == null) { return 1 + minDepth(root.left); } return 1 + Math.min(minDepth(root.left), minDepth(root.right)); } } 使用BFS容易寻找最短距离，但DFS是考递归的堆栈记录走过的路径。 DFS是线，BFS是面 例如：单词接龙 class Solution { public int ladderLength(String beginWord, String endWord, List\u003cString\u003e wordList) { // base case if(!wordList.contains(endWord)) { return 0; } // 核心数据结构 Queue\u003cString\u003e queue = new LinkedList\u003c\u003e(); // 避免回头路 Set\u003cString\u003e visited = new HashSet\u003c\u003e(); queue.offer(beginWord); visited.add(beginWord); // 记录答案 int count = 0; while(!queue.isEmpty()) { int len = queue.size(); count ++; for(int i=0; i\u003clen; i++) { String start = queue.poll(); // 从单词集中寻找是否可以转换的 for(String s : wordList) { // 若已经遍历过 if(visited.contains(s)) { continue; } // 若不可以转换 if(!isConvert(start, s)) { continue; } // 判断是否到达终点 if(s.equals(endWord)) { return count + 1; } visited.add(s); queue.offer(s); } } } return 0; } public boolean isConvert(String start, String s) { if(s.length() != start.length()) { return false; } int count = 0; for(int i=0; i\u003cs.length(); i++) { if(start.charAt(i) != s.charAt(i)) { count ++; if(count \u003e 1) { return false; } } } return true; } } 例：leetcode752 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，‘0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。 遍历 “0000” 的相邻节点，拨动数字只能向上或向下因此“1000”和“9000”；“0100”和“0900“…及还是一个求最短距离的问题。 class Solution { public String rollUp(String s, int j) { char[] ch = s.toCharArray(); if (ch[j] == '9') ch[j] = '0'; else ch[j] += 1; return new String(ch); } public String rollDown(String s, int j) { char[] ch = s.toCharArray(); if(ch[j] == '0') { ch[j] = '9'; } else { ch[j] -= 1; } return new String(ch); } public int openLock(String[] deadends, String target) { Queue\u003cString\u003e queue = new LinkedList\u003c\u003e(); Set\u003cString\u003e dead = new HashSet\u003c\u003e(); Set\u003cString\u003e visited = new HashSet\u003c\u003e(); for(String s : deadends) { dead.add(s); } queue.add(\"0000\"); visited.add(\"0000\"); int count = 0; while(!queue.isEmpty()) { int len = queue.size(); for(int i=0; i\u003clen; i++) { String str = queue.poll(); if(dead.contains(str)) { continue; } // 终点 if(target.equals(str)) { return count; } // 向该节点的四周扩散 for(int j=0; j\u003c4; j++) { String up = rollUp(str, j); if(!visited.contains(up)) { queue.offer(up); visited.add(up); } String down = rollDown(str, j); if(!visited.contains(down)) { queue.offer(down); visited.add(down); } } } count ++; } return -1; } } ","date":"2020-10-14 23:27:32","objectID":"/2020/10/bfs/:1:0","tags":["BFS"],"title":"BFS","uri":"/2020/10/bfs/"},{"categories":["算法"],"content":"双向BFS优化 传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。 不过，双向 BFS 也有局限，因为你必须知道终点在哪里。比如二叉树最小高度的问题，你一开始根本就不知道终点在哪里，也就无法使用双向 BFS；但是第二个密码锁的问题，是可以使用双向 BFS 算法来提高效率的。 class Solution { public String rollUp(String s, int j) { char[] ch = s.toCharArray(); if (ch[j] == '9') ch[j] = '0'; else ch[j] += 1; return new String(ch); } public String rollDown(String s, int j) { char[] ch = s.toCharArray(); if(ch[j] == '0') { ch[j] = '9'; } else { ch[j] -= 1; } return new String(ch); } public int openLock(String[] deadends, String target) { // 用集合不用队列，可快速进行判断 Set\u003cString\u003e q1 = new HashSet\u003c\u003e(); Set\u003cString\u003e q2 = new HashSet\u003c\u003e(); Set\u003cString\u003e dead = new HashSet\u003c\u003e(); Set\u003cString\u003e visited = new HashSet\u003c\u003e(); for(String s : deadends) { dead.add(s); } q1.add(\"0000\"); // q2 从终点开始 q2.add(target); visited.add(\"0000\"); int count = 0; while(!q1.isEmpty() \u0026\u0026 !q2.isEmpty()) { // 用temp存储扩散结果，因为哈希集合在遍历时不可修改 Set\u003cString\u003e temp = new HashSet\u003c\u003e(); // 扩散q1集合 for(String cur : q1) { if(dead.contains(cur)) { continue; } // 相遇 if(q2.contains(cur)) { return count; } visited.add(cur); // 将一个节点未遍历的相邻节点加入集合 for(int j=0; j\u003c4; j++) { String up = rollUp(cur, j); if(!visited.contains(up)) { temp.add(up); } String down = rollDown(cur, j); if(!visited.contains(down)) { temp.add(down); } } } // 交换遍历 q1 = q2; q2 = temp; count ++; } return -1; } } ","date":"2020-10-14 23:27:32","objectID":"/2020/10/bfs/:2:0","tags":["BFS"],"title":"BFS","uri":"/2020/10/bfs/"},{"categories":["Spring"],"content":"SpringSecurity ","date":"2020-10-14 20:38:55","objectID":"/2020/10/springsecurity/:0:0","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/2020/10/springsecurity/"},{"categories":["Spring"],"content":"简介 SpringSecurity是一个强大的可高度定制的认证和授权框架，对于Spring应用来说它是一套Web安全标准。SpringSecurity注重于为Java应用提供认证和授权功能，像所有的Spring项目一样，它对自定义需求具有强大的扩展性。 ","date":"2020-10-14 20:38:55","objectID":"/2020/10/springsecurity/:1:0","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/2020/10/springsecurity/"},{"categories":["Spring"],"content":"Shiro、SpringSecurity 不同：功能很像 相同：认证、授权 功能权限 访问权限 菜单权限 …拦截器，过滤器：大量原生代码，荣誉 几个重要的类： WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式，@EnableXXX开启某个功能 其主要的两个目标 “认证” （Authentication） 身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。 身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。 “授权” （Authorization） 授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。 这个概念是通用的，而不是只在Spring Security 中存在。 ","date":"2020-10-14 20:38:55","objectID":"/2020/10/springsecurity/:1:1","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/2020/10/springsecurity/"},{"categories":["Spring"],"content":"使用 @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { // 授权 @Override protected void configure(HttpSecurity http) throws Exception { // @formatter:off http.cors() // 关闭 CSRF .and().csrf().disable() // 登录行为由自己实现，参考 AuthController#login .formLogin().disable() .httpBasic().disable() // 认证请求 .authorizeRequests() // 所有请求都需要登录访问 .anyRequest() .authenticated() // RBAC 动态 url 认证 .anyRequest() .access(\"@rbacAuthorityService.hasPermission(request,authentication)\") // 登出行为由自己实现，参考 AuthController#logout .and().logout().disable() // Session 管理 .sessionManagement() // 因为使用了JWT，所以这里不管理Session .sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 异常处理 .and().exceptionHandling().accessDeniedHandler(accessDeniedHandler); // @formatter:on // 添加自定义 JWT 过滤器 http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class); } // 认证 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(adminUserServiceImpl).passwordEncoder(new BCryptPasswordEncoder()); } @Override public void configure(WebSecurity web) throws Exception { // 静态资源放行 web.ignoring().antMatchers(\"/static/**\"); } } AOP：拦截器 // 首页是所有人可以访问，功能页只有对应权限的人才能进入 // 请求授权的规则 http.authorizeRequests() .antMatchers(\"/\").permitAll()//\"/\"所有角色都可以通過 .antMatchers(\"/teacher/**\").hasAnyRole(\"teacher\")//\"/teacher/**\"只有角色為teacher才可以通過 .antMatchers(\"/student/**\").hasAnyRole(\"student\") .antMatchers(\"/admin/**\").hasAnyRole(\"admin\") .antMatchers(\"/user/**\").hasAnyRole(\"user\"); // 非授权访问时跳转的方法 http.formLogin(); // 安全 //关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求 http.csrf().disable(); // 用户注销后返回的界面 http.logout().logoutSuccessUrl(\"/\"); // 记住我 信息会保存到cookie //定制请求的授权规则 @Override protected void configure(HttpSecurity http) throws Exception { //。。。。。。。。。。。 //记住我 http.rememberMe(); } 如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 http.csrf().disable(); ","date":"2020-10-14 20:38:55","objectID":"/2020/10/springsecurity/:2:0","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/2020/10/springsecurity/"},{"categories":["Spring"],"content":"补充 CSRF（Cross-site request forgery）跨站请求伪造。在spring security中的跨域保护。是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 ","date":"2020-10-14 20:38:55","objectID":"/2020/10/springsecurity/:3:0","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/2020/10/springsecurity/"},{"categories":["Spring"],"content":"Swagger ","date":"2020-10-14 15:44:55","objectID":"/2020/10/swagger/:0:0","tags":["Swagger"],"title":"Swagger","uri":"/2020/10/swagger/"},{"categories":["Spring"],"content":"介绍 （html/javascript/css的一个集合，可以根据注解生成在线API文档） Swagger UI:提供了一个可视化的UI页面展示描述文件。接口的调用方、测试、项目经理等都可以在该页面中对相关接口进行查阅和做一些简单的接口请求。该项目支持在线导入描述文件和本地部署UI项目。 ","date":"2020-10-14 15:44:55","objectID":"/2020/10/swagger/:1:0","tags":["Swagger"],"title":"Swagger","uri":"/2020/10/swagger/"},{"categories":["Spring"],"content":"使用 在pom.xml中新添Swagger-UI相关依赖 \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cproject.reporting.outputEncoding\u003eUTF-8\u003c/project.reporting.outputEncoding\u003e \u003cjava.version\u003e1.8\u003c/java.version\u003e \u003cswagger.version\u003e2.9.2\u003c/swagger.version\u003e \u003c/properties\u003e \u003c!--Swagger-UI API文档生产工具--\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger2\u003c/artifactId\u003e \u003cversion\u003e${swagger.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.springfox\u003c/groupId\u003e \u003cartifactId\u003espringfox-swagger-ui\u003c/artifactId\u003e \u003cversion\u003e${swagger.version}\u003c/version\u003e \u003c/dependency\u003e ","date":"2020-10-14 15:44:55","objectID":"/2020/10/swagger/:2:0","tags":["Swagger"],"title":"Swagger","uri":"/2020/10/swagger/"},{"categories":["Spring"],"content":"常用注解 @Api：用于修饰Controller类，生成Controller相关文档信息 @ApiOperation：用于修饰Controller类中的方法，生成接口方法相关文档信息 @ApiParam：用于修饰接口中的参数，生成接口参数相关文档信息 @ApiModelProperty：用于修饰实体类的属性，当实体类是请求参数或返回结果时，直接生成相关文档信息 Swagger对生成API文档的范围有三种不同的选择 生成指定包下面的类的API文档 生成有指定注解的类的API文档 生成有指定注解的方法的API文档 @Configuration @EnableSwagger2 public class Swagger2Config { @Bean public Docket createRestApi(){ return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //为当前包下controller生成API文档 .apis(RequestHandlerSelectors.basePackage(\"com.ttt.chacha.chacha.controller\")) //为有@Api注解的Controller生成API文档 // .apis(RequestHandlerSelectors.withClassAnnotation(Api.class)) //为有@ApiOperation注解的方法生成API文档 // .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"SwaggerUI演示\") .description(\"chacha\") .version(\"1.0\") .build(); } } ","date":"2020-10-14 15:44:55","objectID":"/2020/10/swagger/:2:1","tags":["Swagger"],"title":"Swagger","uri":"/2020/10/swagger/"},{"categories":["Spring"],"content":"访问接口位置 接口地址：http://localhost:8080/swagger-ui.html ","date":"2020-10-14 15:44:55","objectID":"/2020/10/swagger/:2:2","tags":["Swagger"],"title":"Swagger","uri":"/2020/10/swagger/"},{"categories":["数据库"],"content":"Redis学习 ","date":"2020-10-14 12:31:40","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0/:0:0","tags":["Redis"],"title":"Redis学习","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"介绍 Redis 就是一个使用 C 语言开发的数据库，Redis 的数据就是存在内存中，所以读写速度非常快，因此多被用于缓存。 另外，Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。 Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。 Redis常用的5种数据类型（String，Hash，List，Set，sorted set） ","date":"2020-10-14 12:31:40","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0/:1:0","tags":["Redis"],"title":"Redis学习","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"流程 如果用户请求的数据在缓存中就直接返回。 缓存中不存在的话就看数据库中是否存在。 数据库中存在的话就更新缓存中的数据。 数据库中不存在的话就返回空数据。 ","date":"2020-10-14 12:31:40","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0/:2:0","tags":["Redis"],"title":"Redis学习","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"为什么用Redis作为缓存 直接来说就是速度性能的提升，且直接操作缓存能大大提高请求数量，毕竟常用的数据就那些，如果每次查询都要经过数据库的话，会极大的影响整个系统的性能，而使用缓存，将部分数据从数据库移动到缓存中去，这样一部分用户请求不会经过数据库，而先经过缓存，提高了系统整体的并发性。 ","date":"2020-10-14 12:31:40","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0/:3:0","tags":["Redis"],"title":"Redis学习","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"Redis常见数据结构以及应用 ","date":"2020-10-14 12:31:40","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0/:4:0","tags":["Redis"],"title":"Redis学习","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"开始使用 // 启动redis服务 redis-server // 使用redis客户端 redis-cli 在远程服务上执行命令 redis-cli -h host -p port -a password string（SDS） 介绍 ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串（simple dynamic string，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。 常用命令: set,get,strlen,exists,dect,incr,setex 等等。 应用场景 ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。 127.0.0.1:6379\u003e set key djj OK 127.0.0.1:6379\u003e get key \"djj\" 127.0.0.1:6379\u003e strlen key # 获取长度 (integer) 3 127.0.0.1:6379\u003e exists key # 判断某个 key 是否存在 (integer) 1 127.0.0.1:6379\u003e del key # 删除某个key对应的值 (integer) 1 127.0.0.1:6379\u003e get key # 删除后返回 nil (nil) 批量设置 127.0.0.1:6379\u003e mset k1 213 k2 432 # 批量设置 OK 127.0.0.1:6379\u003e mget k1 k2 # 获取多个键值对 1) \"213\" 2) \"432\" 计数器（字符串内容为整数的时候可以使用） 127.0.0.1:6379\u003e set number1 1 OK 127.0.0.1:6379\u003e incr number1 # 将存储的数字+1 (integer) 2 127.0.0.1:6379\u003e get number1 \"2\" 127.0.0.1:6379\u003e decr number1 # 将存储的数字-1 (integer) 1 127.0.0.1:6379\u003e get number1 \"1\" 过期 127.0.0.1:6379\u003e expire key 60 # 数据在60秒后过期 (integer) 0 127.0.0.1:6379\u003e setex key 60 432 # 数据在60秒后过期 值为432 OK 127.0.0.1:6379\u003e get key \"432\" 127.0.0.1:6379\u003e ttl key # 查看数据还有多久过期 (integer) 54 127.0.0.1:6379\u003e ttl key # 过期了 (integer) -2 127.0.0.1:6379\u003e get key # 数据无效了 (nil) list 介绍 ：list 即是 链表。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 LinkedList，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。 常用命令: rpush,lpop,lpush,rpop,lrange、llen 等。 应用场景: 发布与订阅或者说消息队列、慢查询。 通过 rpush/lpop 实现队列 127.0.0.1:6379\u003e rpush mylist 123 (integer) 1 127.0.0.1:6379\u003e rpush mylist 32 43 (integer) 3 127.0.0.1:6379\u003e lpop mylist # 从最头部取出 \"123\" 127.0.0.1:6379\u003e lrange mylist 0 1 1) \"32\" 2) \"43\" 127.0.0.1:6379\u003e lrange mylist 0 -1 # -1表示倒数第一个元素 1) \"32\" 2) \"43\" 通过 rpush/rpop 实现栈 127.0.0.1:6379\u003e rpush mylist 123 (integer) 3 127.0.0.1:6379\u003e lrange mylist 0 2 1) \"32\" 2) \"43\" 3) \"123\" 127.0.0.1:6379\u003e rpop mylist # 弹出顶部元素 \"123\" 127.0.0.1:6379\u003e lrange mylist 0 1 1) \"32\" 2) \"43\" 总结： lpush/lpop 为对链表的左侧进行操作，rpush/rpop 为对链表的右侧进行操作。 查看列表范围 lrange/llen 127.0.0.1:6379\u003e lrange mylist 0 1 # 可以通过lrange来进行分页查询 1) \"32\" 2) \"43\" 127.0.0.1:6379\u003e llen mylist # 查看链表长度 (integer) 2 hash 介绍 ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。 常用命令： hset,hmset,hexists,hget,hgetall,hkeys,hvals 等。 应用场景: 系统中对象数据的存储。 127.0.0.1:6379\u003e hset user name \"djj\" age 20 (integer) 2 127.0.0.1:6379\u003e hexists user name # 查看hash表中的字段是否存在 (integer) 1 127.0.0.1:6379\u003e hexists user age (integer) 1 127.0.0.1:6379\u003e hget user name # 获取hash表中的字段 \"djj\" 127.0.0.1:6379\u003e hget user age \"20\" 127.0.0.1:6379\u003e hset user age 21 # 修改hash表中的字段值 (integer) 0 127.0.0.1:6379\u003e hget user age \"21\" ","date":"2020-10-14 12:31:40","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0/:4:1","tags":["Redis"],"title":"Redis学习","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"set 介绍 ： set 类似于 Java 中的 HashSet 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。 常用命令： sadd,spop,smembers,sismember,scard,sinterstore,sunion 等。 应用场景: 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景 127.0.0.1:6379\u003e sadd mySet 123 432 32 (integer) 3 127.0.0.1:6379\u003e sadd mySet 123 # 插入失败，set集合中不允许有重复的元素 (integer) 0 127.0.0.1:6379\u003e smembers mySet # 查询set集合中的所有元素 1) \"32\" 2) \"123\" 3) \"432\" 127.0.0.1:6379\u003e scard mySet # 查看set集合的长度 (integer) 3 127.0.0.1:6379\u003e sismember mySet 123 # 查看set集合中的某个元素是否存在 只接受单个元素 (integer) 1 127.0.0.1:6379\u003e sadd myset1 1 2 3 4 (integer) 4 127.0.0.1:6379\u003e sadd myset2 2 3 4 5 (integer) 4 127.0.0.1:6379\u003e sinterstore myset myset1 myset2 # 将myset1 和 myset2 中的交集存放到myset中 (integer) 3 127.0.0.1:6379\u003e smembers myset 1) \"2\" 2) \"3\" 3) \"4\" 127.0.0.1:6379\u003e sunionstore myset3 myset1 myset2 # 获取myset1 和 myset2 的并集并存放到myset3中 (integer) 5 127.0.0.1:6379\u003e smembers myset3 1) \"1\" 2) \"2\" 3) \"3\" 4) \"4\" 5) \"5\" ","date":"2020-10-14 12:31:40","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0/:4:2","tags":["Redis"],"title":"Redis学习","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"sorted sort 介绍： 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。 常用命令： zadd,zcard,zscore,zrange,zrevrange,zrem 等。 应用场景： 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。 127.0.0.1:6379\u003e zadd myzet 2.0 v1 # 添加一个权重为2.0的值v1 (integer) 1 127.0.0.1:6379\u003e zadd myzet 3.0 v2 (integer) 1 127.0.0.1:6379\u003e zadd myzet 1.0 v3 (integer) 1 127.0.0.1:6379\u003e zcard myzet # 显示sorted set中的数量 (integer) 3 127.0.0.1:6379\u003e zscore myzet v2 # 查询key中某个值的权值 \"3\" 127.0.0.1:6379\u003e zrange myzet 0 3 # 顺序输出sorted set中的值 （按照权值从小到大） 1) \"v3\" 2) \"v1\" 3) \"v2\" ","date":"2020-10-14 12:31:40","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0/:4:3","tags":["Redis"],"title":"Redis学习","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"总结 Xcommand，X没有的时候为string类型，X为l的时候为list类型，X为s的时候为set类型，X为h的时候为hash类型，X为z的时候为sorted set类型。 Xcard：一般用于查询集合中的数量 Xrange：输出某一数据结构某一范围中的值 Xset：设置或更改 Xget：获取 ","date":"2020-10-14 12:31:40","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0/:4:4","tags":["Redis"],"title":"Redis学习","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0/"},{"categories":["数据库"],"content":"Redis（前置） ","date":"2020-10-13 22:21:36","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/:0:0","tags":["Redis"],"title":"Redis学习（前置）","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"缓存 ","date":"2020-10-13 22:21:36","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/:1:0","tags":["Redis"],"title":"Redis学习（前置）","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"基本思想 缓存就是用空间换时间，提高系统的性能以及减少请求相应时间。 像CPU与内存之间的速度不匹配的问题，用缓存进行平衡这种速度不匹配。在操作系统中，在页表的方案基础之上引入快表来加速虚拟地址到物理地址的映射转换。可以将快表理解为一种特殊的高速缓存存储器（CaChe）。 而在业务系统中，为了避免用户在请求数据时获取速度过慢，在数据库上添加了这一层缓存来弥补。 ","date":"2020-10-13 22:21:36","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/:1:1","tags":["Redis"],"title":"Redis学习（前置）","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"使用缓存带来的问题 引入本地缓存来做一些简单业务场景的话，实际带来的代价几乎可以忽略，下面主要是针对分布式缓存来说的。 1、系统复杂性增加：引入缓存后，需要维护缓存和数据库的数据一致性、维护热点缓存等等。 2、系统开发成本增加：引入缓存意味着系统需要一个单独的缓存服务，这是需要花费相应的成本的，并且这个成本还是很贵的，毕竟耗费的是宝贵的内存。但是，如果你只是简单的使用一下本地缓存存储一下简单的数据，并且数据量不大的话，那么就不需要单独去弄一个缓存服务。 ","date":"2020-10-13 22:21:36","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/:1:2","tags":["Redis"],"title":"Redis学习（前置）","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"本地缓存解决方案 一、JDK自带的HashMap和ConcurrentHashMap ConcurrentHashMap可以看作是线程安全版本的HashMap，两者都是以存放 Key/Value 键值对。 二、Ehache、Guava Cache、Spring Cache 本地缓存框架 Ehache 比另外两者更加重量，但 Ehcache支持可以嵌入到 hibernate 和 mybatis 中作为多级缓存，并可以将缓存的数据持久化到本地磁盘中，同时提供集群方案（鸡肋）。 Guava Cache 和 Spring Cache 两者的话比较像。 Guava 相比于 Spring Cache 的话使用的更多一点，它提供了 API 非常方便我们使用，同时也提供了设置缓存有效时间等功能。它的内部实现也比较干净，很多地方都和 ConcurrentHashMap 的思想有异曲同工之妙。 使用 Spring Cache 的注解实现缓存的话，代码会看着很干净和优雅，但是很容易出现问题比如缓存穿透、内存溢出。 三： 后起之秀 Caffeine。 相比于 Guava 来说 Caffeine 在各个方面比如性能要更加优秀，一般建议使用其来替代 Guava 。并且， Guava 和 Caffeine 的使用方式很像！ 本地缓存固然好，但是缺陷也很明显，比如多个相同服务之间的本地缓存的数据无法共享。 ","date":"2020-10-13 22:21:36","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/:1:3","tags":["Redis"],"title":"Redis学习（前置）","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"为什么要有分布式缓存 我们可以把分布式缓存（Distributed Cache） 看作是一种内存数据库的服务，它的最终作用就是提供缓存数据的服务。 本地的缓存的优势是低依赖，比较轻量并且通常相比于使用分布式缓存要更加简单。 再来分析一下本地缓存的局限性： 本地缓存对分布式架构支持不友好，比如同一个相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的，因为本地缓存只在当前机器上有。 本地缓存容量受服务部署所在的机器限制明显。 如果当前系统服务所耗费的内存多，那么本地缓存可用的容量就很少。 使用分布式缓存之后，缓存部署在一台单独的服务器上，即使同一个相同的服务部署在再多机器上，也是使用的同一份缓存。 并且，单独的分布式缓存服务的性能、容量和提供的功能都要更加强大。 使用分布式缓存的缺点呢，也很显而易见，那就是你需要为分布式缓存引入额外的服务比如 Redis 或 Memcached，你需要单独保证 Redis 或 Memcached 服务的高可用。 ","date":"2020-10-13 22:21:36","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/:1:4","tags":["Redis"],"title":"Redis学习（前置）","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/"},{"categories":["数据库"],"content":"缓存读写模式/更新策略 Cache Aside Pattern （旁路缓存模式） 1、写：更新 DB，然后直接删除 cache 2、读：从 cache 中读取数据，读取到就直接返回，读取不到的话，就从 DB 中取数据返回，然后再把数据放到 cache 中。 Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。另外，Cache Aside Pattern 有首次请求数据一定不在 cache 的问题，对于热点数据可以提前放入缓存中。 适合读请求比较多的场景 Read/Write Through Pattern （读写穿透） Read/Write Through 套路是：服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。 写（Write Through）：先查 cache，cache 中不存在，直接更新 DB。 cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（同步更新 cache 和 DB）。 读(Read Through)： 从 cache 中读取数据，读取到就直接返回 。读取不到的话，先从 DB 加载，写入到 cache 后返回响应。 Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。 和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。 Write Behind Pattern （异步缓存写入） Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。 但是，两个又有很大的不同：Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。 Write Behind Pattern 下 DB 的写性能非常高，尤其适合一些数据经常变化的业务场景比如说一篇文章的点赞数量、阅读数量。 往常一篇文章被点赞 500 次的话，需要重复修改 500 次 DB，但是在 Write Behind Pattern 下可能只需要修改一次 DB 就可以了。 但是，这种模式同样也给 DB 和 Cache 一致性带来了新的考验，很多时候如果数据还没异步更新到 DB 的话，Cache 服务宕机就 gg 了。 ","date":"2020-10-13 22:21:36","objectID":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/:1:5","tags":["Redis"],"title":"Redis学习（前置）","uri":"/2020/10/redis%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%BD%AE/"},{"categories":["Java基础"],"content":"Collection-List ","date":"2020-10-12 14:38:57","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/:0:0","tags":["集合框架"],"title":"集合框架","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/"},{"categories":["Java基础"],"content":"概述 除了Map结尾的类以外，其他的都继承了Collection接口。 List(对付顺序)： List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象 Set(注重独一无二的性质): 不允许重复的集合。不会有多个元素引用相同的对象。 Map(用Key搜索): 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。 Map接口没有继承自Collection接口，因为Map表示的是关联式容器而不是集合。但Java为我们提供了从Map转换到Collection的方法，可以方便的将Map切换到集合视图。 上图中提供了Queue接口，却没有Stack，这是因为Stack的功能已被JDK 1.6引入的Deque取代。 ","date":"2020-10-12 14:38:57","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/:1:0","tags":["集合框架"],"title":"集合框架","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/"},{"categories":["Java基础"],"content":"泛型（Generics） JDK1.5引入泛型，所有集合接口和实现都大量地使用，使得Java容器可以接受任何类型的对象。即是编译提供的一个语法糖。 泛型本身并不需要Java虚拟机的支持，只需要在编译阶段做一下简单的字符串替换即可。实质上Java的单继承机制才是保证这一特性的根本，因为所有的对象都是Object的子类，容器里只要能够存放Object对象就行了。 事实上，所有容器的内部存放的都是Object对象，泛型机制只是简化了编程，由编译器自动帮我们完成了强制类型转换而已。而在此之前，类型转换需要显式完成。 ","date":"2020-10-12 14:38:57","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/:1:1","tags":["集合框架"],"title":"集合框架","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/"},{"categories":["Java基础"],"content":"内存管理 跟C++复杂的内存管理机制不同，Java GC自动包揽了一切，Java程序并不需要处理令人头疼的内存问题，因此JCF并不像C++ STL那样需要专门的空间适配器（alloctor）。 另外，由于Java里对象都在堆上，且对象只能通过引用（reference，跟C++中的引用不是同一个概念，可以理解成经过包装后的指针）访问，容器里放的其实是对象的引用而不是对象本身，也就不存在C++容器的复制拷贝问题。 ","date":"2020-10-12 14:38:57","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/:1:2","tags":["集合框架"],"title":"集合框架","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/"},{"categories":["Java基础"],"content":"Collections 和 Collection 的区别？ Collection是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。而Collections是一个包装类，包含有关集合操作的静态多态方法，仅用于服务Java的Collection框架。 ","date":"2020-10-12 14:38:57","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/:1:3","tags":["集合框架"],"title":"集合框架","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/"},{"categories":["Java基础"],"content":"Collection Collection集合下的所有集合都共有以下基本方法： add() addAll(Collection) remove() removeAll(Collection) removeIf() size() contains(Object) clear() isEmpty() toArray() retainAll(Collection) 从此集合中删除指定集合中不包含的所有元素 ","date":"2020-10-12 14:38:57","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/:1:4","tags":["集合框架"],"title":"集合框架","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/"},{"categories":["Java基础"],"content":"List、Set、Map List：存储的元素有序，可重复 Set：存储的元素无序，不可重复 Map：使用键值对（key-value）存储，key是无序不可重复的，value是无序可重复的 List ArrayList：Object[]数组 Vector：Object[]数组 LinkedList：双向链表（JDK1.6为循环链表，JDK1.7取消了） Set HashSet（无序，唯一）：基于HashMap实现的，底层采用HashMap来保存元素 LinkedHashSet：是HashSet的子类 TreeSet（有序，唯一）：红黑树（自平衡的排序二叉树） Map HashMap：JDK8之前HashMap由数组+链表组成的，数组是HashMap的主题，链表则是主要为了解决哈希冲突而存在的（“拉链法”） ListedHashMap：LinkedHashMap继承自HashMap，在其结构的基础上，增加了一条双向链表，是上面结构可以保持键值对的插入顺序。 TreeMap：红黑树（自平衡的排序二叉树） ","date":"2020-10-12 14:38:57","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/:1:5","tags":["集合框架"],"title":"集合框架","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/"},{"categories":["Java基础"],"content":"ArrayList、LinkedList和Vector的区别 ArrayList是一个可改变大小的数组。当更多元素加入到ArrayList中时，其大小将会动态地增大，但每一次扩大都是进行数组的copyOf()，因此若要进行大量增删操作时不适合使用，但若进行查找操作时效率比LinkedList快的多。 LinkedList是一个双链表，在添加和删除元素时具有比ArrayList更好的性能。但在get与set方面远弱于ArrayList。 Vector 和ArrayList类似,但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用ArrayList是更好的选择。 而 LinkedList 还实现了 Queue 接口,该接口比List提供了更多的方法,包括 offer(),peek(),poll()等。 注意: 默认情况下ArrayList的初始容量非常小,所以如果可以预估数据量的话,分配一个较大的初始值属于最佳实践,这样可以减少调整大小的开销。 同步处理：Vector同步，ArrayList非同步 Vector缺省情况下增长原来一倍的数组长度，ArrayList是0.5倍. ArrayList: int newCapacity = oldCapacity + (oldCapacity » 1); ArrayList自动扩大容量为原来的1.5倍（实现的时候，方法会传入一个期望的最小容量，若扩容后容量仍然小于最小容量，那么容量就为传入的最小容量。扩容的时候使用的Arrays.copyOf方法最终调用native方法进行新数组创建和数据拷贝） Vector: int newCapacity = oldCapacity + ((capacityIncrement \u003e 0) ? capacityIncrement : oldCapacity); Vector指定了initialCapacity，capacityIncrement来初始化的时候，每次增长capacityIncrement ArrayList 和 LinkedList 区别？ 线程安全：都不同步，即不保证线程安全 底层数据结构： ArrayList 底层使用的是 Object 数组 LinkedList 底层使用的是双向链表 插入与删除： ArrayList：插入指定位置的时候，第i个元素和第i个元素之后的（n-i）元素都要执行向后移一位的操作。只在执行插入末尾的时候复杂度为O（1） LinkedList：插入和删除不受位置影响，而指定位置的时候需要移动到指定位置在插入。 访问查询： ArrayList支持随机访问RandomAccess接口的实现 LinkedList不支持高效的随机访问，在访问元素为中间的时候效率最低，由于为双向链表，所以在判断访问元素的下标时，会考虑从后往前还是从前往后。 空间占用： ArrayList的空间浪费主要在list列表的结尾会预留一定的容量空间，而LinkedList的主要浪费在前后指针上和数据节点。 RandomAccess接口 public interface RandomAccess { } 所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。 ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！ ","date":"2020-10-12 14:38:57","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/:1:6","tags":["集合框架"],"title":"集合框架","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/"},{"categories":["Java基础"],"content":"ArrayList的扩容机制 ArrayList有三种方式来初始化，构造方法源码如下： /** * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** *默认构造函数，使用初始容量10构造一个空列表(无参数构造) */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /** * 带初始容量参数的构造函数。（用户自己指定容量） */ public ArrayList(int initialCapacity) { if (initialCapacity \u003e 0) {//初始容量大于0 //创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) {//初始容量等于0 //创建空数组 this.elementData = EMPTY_ELEMENTDATA; } else {//初始容量小于0，抛出异常 throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } /** *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回 *如果指定的集合为null，throws NullPointerException。 */ public ArrayList(Collection\u003c? extends E\u003e c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 即以无参构造方法创建ArrayList的时候，实际上是赋值一个空数组。但在添加元素的时候才真正分配容量。 add方法 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return \u003ctt\u003etrue\u003c/tt\u003e (as specified by {@link Collection#add}) */ public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } 在执行add方法时，会先执行ensureExplicitCapacity()方法 private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length \u003e 0) grow(minCapacity); } 注意 ：JDK11 移除了 ensureCapacityInternal() 和 ensureExplicitCapacity() 方法 private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } DEFAULT_CAPACITY=10 当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。 当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为10。此时，minCapacity - elementData.length \u003e 0 成立，所以会进入 grow(minCapacity) 方法。 当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length \u003e 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。 添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。 直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。 grow（）方法 /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; // newCpaacity相当与oldCapacity的1.5倍 int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1); if (newCapacity - minCapacity \u003c 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u003e 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } int newCapacity = oldCapacity + (oldCapacity » 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity为偶数就是1.5倍，否则是1.5倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数. “»\"（移位运算符）：»1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 我们再来通过例子探究一下grow() 方法 ： 当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 hugeCapacity 方法。数组容量为10，add方法中 return true,size增为1。 当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。 以此类推······ 这里补充一点比较重要，但是容易被忽视掉的知识点： java 中的","date":"2020-10-12 14:38:57","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/:1:7","tags":["集合框架"],"title":"集合框架","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/"},{"categories":["Java基础"],"content":"System.arraycopy()和Arrays.copyOf()方法 System.arraycopy() 方法 /** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()方法实现数组自己复制自己 //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量； System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } Arrays.copyOf()方法 /** 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 */ public Object[] toArray() { //elementData：要复制的数组；size：要复制的长度 return Arrays.copyOf(elementData, size); } Arrays.copyOf()主要是为了给原有数组进行扩容 ","date":"2020-10-12 14:38:57","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/:1:8","tags":["集合框架"],"title":"集合框架","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/"},{"categories":["Java基础"],"content":"Iterator迭代器 Iterator对象称为迭代器（设计模式的一种），迭代器可以对集合进行遍历，但每个集合内部的数据结构都是不尽相同的，所以每一个集合的存或取都很可能是不一样的，但如果每一个类中都定义一个hasNext（）和next（）方法，会过于臃肿。 迭代器是将这样的方法抽取出接口，然后在每个类的内部，定义自己迭代方式，这样做就规定了整个集合体系的遍历方式都是 hasNext()和next()方法，使用者不用管怎么实现的，会用即可。迭代器的定义为：提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。 使用 iterator() 方法要求集合返回一个 Iterator。 Iterator 将准备好返回序列中的第一个元素。 使用 next() 方法获得序列中的下一个元素。 使用 hasNext() 方法检查序列中是否还有元素。 使用 remove() 方法将迭代器最近返回的那个元素删除。 ","date":"2020-10-12 14:38:57","objectID":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/:1:9","tags":["集合框架"],"title":"集合框架","uri":"/2020/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list/"},{"categories":["生活"],"content":"Filco圣手二代87建 MAC端适配 电脑：2019款 MacBookPro16寸 ","date":"2020-10-09 15:50:27","objectID":"/2020/10/filco-%E5%9C%A3%E6%89%8B%E4%BA%8C%E4%BB%A3mac%E7%AB%AF%E9%80%82%E9%85%8D/:0:0","tags":["杂"],"title":"Filco 圣手二代Mac端适配","uri":"/2020/10/filco-%E5%9C%A3%E6%89%8B%E4%BA%8C%E4%BB%A3mac%E7%AB%AF%E9%80%82%E9%85%8D/"},{"categories":["生活"],"content":"操作 由于键盘大多都是默认适配Windows的，所以有些地方需要进行改善。 先按装置清除键 按Alt+Fn+Ctrl+数字键（1～4）进行蓝牙连接 个人设置： 按键重复最快，重复前后延迟最短。 由于码代码会需要用到方向键之类的，有时打错了回退不能太慢，影响速度。 系统偏好设置-\u003e键盘-\u003e修饰键 将Option键-\u003eCommand键 将Command键-\u003eOption键 Alt键对应command键 Win键对应Option键 Ctrl键对应Control键 一些快捷键设置： F1 音量+ F2 音量- F3 静音 F5 左播放 F6 右播放 F7 暂停 F8 快进 F12 睡眠键 1～4 蓝牙装置切换键 5/% 键为有线切换键 ","date":"2020-10-09 15:50:27","objectID":"/2020/10/filco-%E5%9C%A3%E6%89%8B%E4%BA%8C%E4%BB%A3mac%E7%AB%AF%E9%80%82%E9%85%8D/:0:1","tags":["杂"],"title":"Filco 圣手二代Mac端适配","uri":"/2020/10/filco-%E5%9C%A3%E6%89%8B%E4%BA%8C%E4%BB%A3mac%E7%AB%AF%E9%80%82%E9%85%8D/"},{"categories":["生活"],"content":"注意 在过久不使用的时候，按command键或option键时，打字出现乱码，不知道啥问题。只能按装置清除键，重新进行配对。 ","date":"2020-10-09 15:50:27","objectID":"/2020/10/filco-%E5%9C%A3%E6%89%8B%E4%BA%8C%E4%BB%A3mac%E7%AB%AF%E9%80%82%E9%85%8D/:0:2","tags":["杂"],"title":"Filco 圣手二代Mac端适配","uri":"/2020/10/filco-%E5%9C%A3%E6%89%8B%E4%BA%8C%E4%BB%A3mac%E7%AB%AF%E9%80%82%E9%85%8D/"},{"categories":["生活"],"content":"问题 关于打字的时候会出现疯狂跳某个字母或者数字，例如wwwwwwwwwww这样的，猜测是蓝牙、wifi亦或是无线鼠标都处于2.4频段产生的冲突，亦或者是蓝牙鼠标与键盘之间的频段冲突。 可以切换到有线尝试下，如果有线的情况下除了问题，可能是电路板出了问题，建议返厂维修。如果不是建议关掉其它蓝牙进行打字测试。 ","date":"2020-10-09 15:50:27","objectID":"/2020/10/filco-%E5%9C%A3%E6%89%8B%E4%BA%8C%E4%BB%A3mac%E7%AB%AF%E9%80%82%E9%85%8D/:0:3","tags":["杂"],"title":"Filco 圣手二代Mac端适配","uri":"/2020/10/filco-%E5%9C%A3%E6%89%8B%E4%BA%8C%E4%BB%A3mac%E7%AB%AF%E9%80%82%E9%85%8D/"},{"categories":["Spring"],"content":"SpringBoot开端 ","date":"2020-10-04 13:54:38","objectID":"/2020/10/springboot%E5%BC%80%E7%AB%AF/:0:0","tags":["SpringBoot"],"title":"SpringBoot开端","uri":"/2020/10/springboot%E5%BC%80%E7%AB%AF/"},{"categories":["Spring"],"content":"SpringBoot项目搭建和启动 New Project中的各字段的含义： “ GroupID ” 是项目组织唯一的标识符，实际对应 Java 的包结构，是 main 目录里 Java 的目录结构，本项目就将其设置为 ltd.newbee.mall。 “ ArtifactID ” 是项目的唯一的标识符，实际对应项目的名称，也就是项目根目录的名称，名为 newbee-mall。 “ Type ” 可以简单理解为项目管理工具，可以选择 Maven 构建或者 Gradle 构建，本项目选用的是常用的 Maven 方式。 “ Language ” 表示编程语言的选择，现在支持 Java 、Kotlin 和 Groovy。 “ Packaging ” 表示项目的打包方式，有两种选择：Jar 和 War，在 Spring Boot 生成后，如果选用的方式不同，那么导入的打包插件也有区别。 “ Java Version ” 表示 JDK 版本的选择。 “ Version ” 是项目版本号，IDEA 默认为 0.0.1-SNAPSHOT，也可以自行修改。 Spring Boot项目的调试和启动的三种方式： IDEA直接启动 Maven插件启动 命令行启动 ","date":"2020-10-04 13:54:38","objectID":"/2020/10/springboot%E5%BC%80%E7%AB%AF/:1:0","tags":["SpringBoot"],"title":"SpringBoot开端","uri":"/2020/10/springboot%E5%BC%80%E7%AB%AF/"},{"categories":["Spring"],"content":"SpringBoot项目结构 根目录com.example 数据类实体类domain jpa项目：com.example.domain mybatis项目：com.example.entity 数据额接口访问层service com.example.service 数据服务接口实现层 com.example.service.impl 前端控制层controller com.example.controller 工具类库utils com.example.utils 配置类config com.example.config 数据传输对象dto（Data Transfer Object）用于封装多个实体类和domain之间的关系，不会破坏原有的实体类结构 com.example.dto 视图包装对象vo（View Object）用与封装客户端请求的数据，防止部分数据泄露：如管理员ID，保证数据安全，不会破坏原有实体类结构 com.example.vo 常量类constant com.example.constant 根目录resources 项目配置文件：resources.application.yml 静态资源目录：resources.static 用于存放html、css、js、图片等资源 视图模版目录：resources.templates 用于存放jsp、thymeleaf等模版文件 mybatis映射文件：resources.mappers mybatis配置文件：resources.spring-mybatis.xml ","date":"2020-10-04 13:54:38","objectID":"/2020/10/springboot%E5%BC%80%E7%AB%AF/:2:0","tags":["SpringBoot"],"title":"SpringBoot开端","uri":"/2020/10/springboot%E5%BC%80%E7%AB%AF/"},{"categories":["Spring"],"content":"Spring Spring是重量级企业开发框架Enterprise JavaBean（EJB）的替代品，Spring通过依赖注入和面向切面编程，用简单的**Java对象（Plain Old Java Object，POJO）**实现了EJB的功能。 ","date":"2020-10-04 13:54:38","objectID":"/2020/10/springboot%E5%BC%80%E7%AB%AF/:3:0","tags":["SpringBoot"],"title":"SpringBoot开端","uri":"/2020/10/springboot%E5%BC%80%E7%AB%AF/"},{"categories":["Spring"],"content":"什么是Spring？ Spring一般指代Spring Framework，是一个企业级Java应用程序开发框架，提供了一种简易的开发方式，它避免了那些使得开发变得繁琐混乱的大量业务/工具对象，由框架去对Bean进行管理。即从自己买菜做饭变成了（容器）送菜到你面前去使用。 三层架构 表现层 web层 MVC是表层的一个设计模型 业务层 service层 持久层 dao层 在被管理对象与业务逻辑之间，Spring通过IOC Inversion of Control（控制反转）架起使用的桥梁，一个具体的例子就是DI Dependency Injection（依赖注入），有效的实现了松耦合。而Spring的核心功能远不止这些，如： Spring AOP Spring JDBC 提供了JDBC抽象层，消除了冗长的JDBC代码。 Spring MVC Spring JMS 包含生产（produce）和消费（consume）消息的功能。 等等….. 其中Spring AOP，提供了面向切面编程的实现，而AOP****面向切面编程，一种编程思想并不是Spring的专有。可参考Spring-AOP。纵览Spring的整个结构，其实Spring本身并未提供太多具体的功能，它主要专注于让项目代码更加优雅整洁，使其具有灵活性和拓展性。 ","date":"2020-10-04 13:54:38","objectID":"/2020/10/springboot%E5%BC%80%E7%AB%AF/:3:1","tags":["SpringBoot"],"title":"SpringBoot开端","uri":"/2020/10/springboot%E5%BC%80%E7%AB%AF/"},{"categories":["Spring"],"content":"SpringMVC和SpringBoot ","date":"2020-10-04 13:54:38","objectID":"/2020/10/springboot%E5%BC%80%E7%AB%AF/:4:0","tags":["SpringBoot"],"title":"SpringBoot开端","uri":"/2020/10/springboot%E5%BC%80%E7%AB%AF/"},{"categories":["Spring"],"content":"什么是SpringMVC？ Spring MVC是Spring的一部分，Spring 出来以后，大家觉得很好用，于是按照这种模式设计了一个 MVC框架（一些用Spring 解耦的组件）。SpringMVC是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。主要用于开发WEB应用和网络接口，它是Spring的一个模块，通过Dispatcher Servlet, ModelAndView 和 View Resolver，让应用开发变得很容易。 ","date":"2020-10-04 13:54:38","objectID":"/2020/10/springboot%E5%BC%80%E7%AB%AF/:4:1","tags":["SpringBoot"],"title":"SpringBoot开端","uri":"/2020/10/springboot%E5%BC%80%E7%AB%AF/"},{"categories":["Spring"],"content":"什么是SpringBoot？ 虽然Spring的组件代码是轻量级的，但它的配置却是重量级的（需要大量XML配置） 。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。 尽管如此，我们依旧没能逃脱配置的魔爪。开启某些Spring特性时，比如事务管理和Spring MVC，还是需要用XML或Java进行显式配置。启用第三方库时也需要显式配置，比如基于Thymeleaf的Web视图。配置Servlet和过滤器（比如Spring的DispatcherServlet）同样需要在web.xml或Servlet初始化代码里进行显式配置。组件扫描减少了配置量，Java配置让它看上去简洁不少，但Spring还是需要不少配置。 光配置这些XML文件都够我们头疼的了，占用了我们大部分时间和精力。除此之外，相关库的依赖非常让人头疼，不同库之间的版本冲突也非常常见。 不过，好消息是：Spring Boot让这一切成为了过去。 ","date":"2020-10-04 13:54:38","objectID":"/2020/10/springboot%E5%BC%80%E7%AB%AF/:4:2","tags":["SpringBoot"],"title":"SpringBoot开端","uri":"/2020/10/springboot%E5%BC%80%E7%AB%AF/"},{"categories":["Spring"],"content":"SpringBoot相较于SSM 一个SSM（Spring SpringMVC Mybatis整合）项目的步骤： 建立maven web项目，并在pom.xml中添加依赖 配置web.xml，引入spring-*.xml配置文件。 配置若干个spring-*.xml文件，例如自动扫描、静态资源映射、默认视图解析、数据库连接池等等。 写业务逻辑代码（dao、service、controller） 而Spring Boot实现了自动配置，减去了繁琐的项目搭建。 com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java | | +- config | +- swagerConfig.java | Application.java是项目的启动类 domain目录主要用于实体（Entity）与数据访问层（Repository） service 层主要是业务类代码 controller 负责页面访问控制 config 目录主要放一些配置类 ","date":"2020-10-04 13:54:38","objectID":"/2020/10/springboot%E5%BC%80%E7%AB%AF/:4:3","tags":["SpringBoot"],"title":"SpringBoot开端","uri":"/2020/10/springboot%E5%BC%80%E7%AB%AF/"},{"categories":["Java基础"],"content":"流式编程 集合优化了对象的存储，而流和对象的处理有关 流是一系列与特定存储机制无关的元素——实际上，流并没有“存储”之说。 使用流，无需迭代集合中的元素，就可以从管道提取和操作元素。这些管道通常被组合在一起，形成一系列对流进行操作的管道。 在大多数情况下，将对象存储在集合中是为了处理他们，因此你将会发现你将把编程的主要焦点从集合转移到了流上。流的一个核心好处是，它使得程序更加短小并且更易理解。当 Lambda 表达式和方法引用（method references）和流一起使用的时候会让人感觉自成一体。流使得 Java 8 更具吸引力。 例子： public class StreamExample { public static void main(String[] args) { new Random() .ints(1, 100) .limit(7) .distinct() .sorted() .forEach(System.out::println); } } 流可以在不使用赋值或可变数据的情况下对有状态的系统建模 ints（）方法产生一个流并且ints（）方法多种方式重载——两个参数限定了产生的数值的边界，这将随机生成一个1～100的随机整数流。用中间流操作（intermediate stream operation）distinct（）使流中的整数不重复，然后使用limit（）方法获取前7个元素，用sorted（）方法排序，最后使用forEach（）方法遍历输出，在这传递一个可以在控制台显示每个元素的方法引用：System.out::println 注意 Randoms.java 中没有声明任何变量。流可以在不使用赋值或可变数据的情况下对有状态的系统建模，这非常有用。 内部迭代产生的代码可读性更强，而且能更简单的使用多核处理器。通过放弃对迭代过程的控制，可以把控制权交给并行化机制。 流是懒加载的。这代表着它只在绝对必要时才计算。你可以将流看作“延迟列表”。由于计算延迟，流使我们能够表示非常大（甚至无限）的序列，而不需要考虑内存问题。 ","date":"2020-10-03 18:57:06","objectID":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/:0:0","tags":["Java基础"],"title":"流式编程","uri":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"流支持 Java 设计者面临着这样一个难题：现存的大量类库不仅为 Java 所用，同时也被应用在整个 Java 生态圈数百万行的代码中。如何将一个全新的流的概念融入到现有类库中呢？ 比如在 Random 中添加更多的方法。只要不改变原有的方法，现有代码就不会受到干扰。 一个大的挑战来自于使用接口的库。集合类是其中关键的一部分，因为你想把集合转为流。但是如果你将一个新方法添加到接口，那就破坏了每一个实现接口的类，因为这些类都没有实现你添加的新方法。 Java 8 采用的解决方案是：在接口中添加被 default（默认）修饰的方法。通过这种方案，设计者们可以将流式（stream）方法平滑地嵌入到现有类中。流方法预置的操作几乎已满足了我们平常所有的需求。流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是到集合中）。 ","date":"2020-10-03 18:57:06","objectID":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/:0:1","tags":["Java基础"],"title":"流式编程","uri":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"流创建 可以通过Stream.of()将一组元素转化为流 public static void showStreamOf() { Stream.of(\"this is \", \" a \", \"word\").forEach(System.out::print); System.out.println(); Stream.of(1, 32,\" \", 32, \" \",34, 43).forEach(System.out::print); } 输出结果： this is a word 132 32 3443 除此之外，每个集合都可以通过调用stream（）方法来产生一个流 public static void showStream() { Map\u003cString, Integer\u003e m = new HashMap\u003c\u003e(); m.put(\"a\", 1); m.put(\"b\", 2); m.put(\"c\", 3); m.entrySet().stream().map(e -\u003e e.getKey() + \":\" + e.getValue()).forEach(System.out::println); } 输出结果 a:1 b:2 c:3 为了从 Map 集合中产生流数据，我们首先调用 entrySet() 产生一个对象流，每个对象都包含一个 key 键以及与其相关联的 value 值。然后分别调用 getKey() 和 getValue() 获取值。 ","date":"2020-10-03 18:57:06","objectID":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/:0:2","tags":["Java基础"],"title":"流式编程","uri":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"随机数流 Random 类被一组生成流的方法增强了。代码示例： // streams/RandomGenerators.java import java.util.*; import java.util.stream.*; public class RandomGenerators { public static \u003cT\u003e void show(Stream\u003cT\u003e stream) { stream .limit(4) .forEach(System.out::println); System.out.println(\"++++++++\"); } public static void main(String[] args) { Random rand = new Random(47); show(rand.ints().boxed()); show(rand.longs().boxed()); show(rand.doubles().boxed()); // 控制上限和下限： show(rand.ints(10, 20).boxed()); show(rand.longs(50, 100).boxed()); show(rand.doubles(20, 30).boxed()); // 控制流大小： show(rand.ints(2).boxed()); show(rand.longs(2).boxed()); show(rand.doubles(2).boxed()); // 控制流的大小和界限 show(rand.ints(3, 3, 9).boxed()); show(rand.longs(3, 12, 22).boxed()); show(rand.doubles(3, 11.5, 12.3).boxed()); } }复制ErrorOK! 输出结果： -1172028779 1717241110 -2014573909 229403722 ++++++++ 2955289354441303771 3476817843704654257 -8917117694134521474 4941259272818818752 ++++++++ 0.2613610344283964 0.0508673570556899 0.8037155449603999 0.7620665811558285 ++++++++ 16 10 11 12 ++++++++ 65 99 54 58 ++++++++ 29.86777681078574 24.83968447804611 20.09247112332014 24.046793846338723 ++++++++ 1169976606 1947946283 ++++++++ 2970202997824602425 -2325326920272830366 ++++++++ 0.7024254510631527 0.6648552384607359 ++++++++ 6 7 7 ++++++++ 17 12 20 ++++++++ 12.27872414236691 11.732085449736195 12.196509449817267 ++++++++ 为了消除冗余代码，我创建了一个泛型方法 show(Stream\u003cT\u003e stream) （在讲解泛型之前就使用这个特性，确实有点作弊，但是回报是值得的）。类型参数 T 可以是任何类型，所以这个方法对 Integer、Long 和 Double 类型都生效。但是 Random 类只能生成基本类型 int， long， double 的流。幸运的是， boxed() 流操作将会自动地把基本类型包装成为对应的装箱类型，从而使得 show() 能够接受流。 ","date":"2020-10-03 18:57:06","objectID":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/:0:3","tags":["Java基础"],"title":"流式编程","uri":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"IntStream.range() public class RangeOfInt { public static void main(String[] args) { // 传统方法 int res = 0; for (int i = 1; i \u003c= 100; i++) { res += i; } System.out.println(res); // for-in循环 res = 0; for (int i : range(1, 101).toArray()) { res += i; } System.out.println(res); // 流 System.out.println(range(1, 101).sum()); } } ","date":"2020-10-03 18:57:06","objectID":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/:0:4","tags":["Java基础"],"title":"流式编程","uri":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"流的建造者模式 在建造者模式（Builder design pattern）中，首先创建一个 builder 对象，然后将创建流所需的多个信息传递给它，最后builder 对象执行”创建“流的操作。Stream 库提供了这样的 Builder。 ","date":"2020-10-03 18:57:06","objectID":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/:0:5","tags":["Java基础"],"title":"流式编程","uri":"/2020/10/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"函数式编程 函数式编程语言操纵代码片段就像操作数据一样容易。 虽然 Java 不是函数式语言，但 Java 8 Lambda 表达式和方法引用 (Method References) 允许你以函数式编程。 函数编程（FP）：通过合并现有代码来生成新功能而不是从头开始编写所有内容，我们可以更快地获得更可靠的代码。至少在某些情况下，这套理论似乎很有用。在这一过程中，函数式语言已经产生了优雅的语法，这些语法对于非函数式语言也适用。 OO（Object Oriented，面向对象）是抽象数据 FP（Functional Programming，函数式编程）是抽象方法 纯粹的函数式语言在安全性方面更进一步。它强加了额外的约束，即所有数据必须是不可变的：设置一次，永不改变。将值传递给函数，该函数然后生成新值但从不修改自身外部的任何东西（包括其参数或该函数范围之外的元素）。当强制执行此操作时，你知道任何错误都不是由所谓的副作用引起的，因为该函数仅创建并返回结果，而不是其他任何错误。 ","date":"2020-10-03 18:56:54","objectID":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:0:0","tags":["Java基础"],"title":"函数式编程","uri":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"Lambda表达式 Java 8 的 Lambda 表达式，其参数和函数体被箭头 -\u003e 分隔开。箭头右侧是从 Lambda 返回的表达式。它与单独定义类和采用匿名内部类是等价的，但代码少得多。 Java 8 的方法引用，它以 :: 为特征。 :: 的左边是类或对象的名称， :: 的右边是方法的名称，但是没有参数列表。 Lambda 表达式是使用最小可能语法编写的函数定义： Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。 Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。 任何 Lambda 表达式的基本语法是： 参数。 接着 -\u003e，可视为“产出”。 -\u003e 之后的内容都是方法体。 [1] 当只用一个参数，可以不需要括号 ()。 然而，这是一个特例。 [2] 正常情况使用括号 () 包裹参数。 为了保持一致性，也可以使用括号 () 包裹单个参数，虽然这种情况并不常见。 [3] 如果没有参数，则必须使用括号 () 表示空参数列表。 [4] 对于多个参数，将参数列表放在括号 () 中。 到目前为止，所有 Lambda 表达式方法体都是单行。 该表达式的结果自动成为 Lambda 表达式的返回值，在此处使用 return 关键字是非法的。 这是 Lambda 表达式简化相应语法的另一种方式。 [5] 如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 return。 Lambda表达式并不能取代所有的匿名内部类，只能用来取代**函数接口（Functional Interface）**的简写 例子1：无参函数的简写 如果需要新建一个线程，一种常见的写法是这样： // JDK7 匿名内部类写法 new Thread(new Runnable(){// 接口名 @Override public void run(){// 方法名 System.out.println(\"Thread run()\"); } }).start(); 上述代码给Tread类传递了一个匿名的Runnable对象，重载Runnable接口的run()方法来实现相应逻辑。这是JDK7以及之前的常见写法。匿名内部类省去了为类起名字的烦恼，但还是不够简化，在Java 8中可以简化为如下形式： // JDK8 Lambda表达式写法 new Thread( () -\u003e System.out.println(\"Thread run()\")// 省略接口名和方法名 ).start(); 上述代码跟匿名内部类的作用是一样的，但比匿名内部类更进一步。这里连接口名和函数名都一同省掉了，写起来更加神清气爽。如果函数体有多行，可以用大括号括起来，就像这样： // JDK8 Lambda表达式代码块写法 new Thread( () -\u003e { System.out.print(\"Hello\"); System.out.println(\" Hoolee\"); } ).start(); 例子2：带参函数的简写 如果要给一个字符串列表通过自定义比较器，按照字符串长度进行排序，Java 7的书写形式如下： // JDK7 匿名内部类写法 List\u003cString\u003e list = Arrays.asList(\"I\", \"love\", \"you\", \"too\"); Collections.sort(list, new Comparator\u003cString\u003e(){// 接口名 @Override public int compare(String s1, String s2){// 方法名 if(s1 == null) return -1; if(s2 == null) return 1; return s1.length()-s2.length(); } }); 上述代码通过内部类重载了Comparator接口的compare()方法，实现比较逻辑。采用Lambda表达式可简写如下： // JDK8 Lambda表达式写法 List\u003cString\u003e list = Arrays.asList(\"I\", \"love\", \"you\", \"too\"); Collections.sort(list, (s1, s2) -\u003e{// 省略参数表的类型 if(s1 == null) return -1; if(s2 == null) return 1; return s1.length()-s2.length(); }); 上述代码跟匿名内部类的作用是一样的。除了省略了接口名和方法名，代码中把参数表的类型也省略了。这得益于javac的类型推断机制，编译器能够根据上下文信息推断出参数的类型，当然也有推断失败的时候，这时就需要手动指明参数类型了。注意，Java是强类型语言，每个变量和对象都必需有明确的类型。 匿名内部类会产生额外的class文件，而使用Lambda表达式则不会 ","date":"2020-10-03 18:56:54","objectID":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:1:0","tags":["Java基础"],"title":"函数式编程","uri":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"比较器 确定两个对象之间的大小关系及排列顺序称为比较，能实现这个比较功能的类或方法称之为比较器 内部比较器是comparable接口 外部比较器是comparator接口 一位数组的降序排序： forEach() // 使用曾强for循环迭代 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(Arrays.asList(\"I\", \"love\", \"you\", \"too\")); for(String str : list){ if(str.length()\u003e3) System.out.println(str); } // 使用forEach()结合Lambda表达式迭代 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(Arrays.asList(\"I\", \"love\", \"you\", \"too\")); list.forEach( str -\u003e { if(str.length()\u003e3) System.out.println(str); }); removeIf() 该方法签名为boolean removeIf(Predicate\u003c? super E\u003e filter)，作用是删除容器中所有满足filter指定条件的元素，其中Predicate是一个函数接口，里面只有一个待实现方法boolean test(T t)，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。 需求：假设有一个字符串列表，需要删除其中所有长度大于3的字符串。 我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出ConcurrentModificationException，所以上述任务传统的写法是： // 使用迭代器删除列表元素 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(Arrays.asList(\"I\", \"love\", \"you\", \"too\")); Iterator\u003cString\u003e it = list.iterator(); while(it.hasNext()){ if(it.next().length()\u003e3) // 删除长度大于3的元素 it.remove(); } 现在使用removeIf()方法结合匿名内部类，我们可是这样实现： // 使用removeIf()结合匿名名内部类实现 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(Arrays.asList(\"I\", \"love\", \"you\", \"too\")); list.removeIf(new Predicate\u003cString\u003e(){ // 删除长度大于3的元素 @Override public boolean test(String str){ return str.length()\u003e3; } }); 上述代码使用removeIf()方法，并使用匿名内部类实现Precicate接口。相信你已经想到用Lambda表达式该怎么写了： // 使用removeIf()结合Lambda表达式实现 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(Arrays.asList(\"I\", \"love\", \"you\", \"too\")); list.removeIf(str -\u003e str.length()\u003e3); // 删除长度大于3的元素 使用Lambda表达式不需要记忆Predicate接口名，也不需要记忆test()方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了 replaceAll() // 使用Lambda表达式实现 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(Arrays.asList(\"I\", \"love\", \"you\", \"too\")); list.replaceAll(str -\u003e { if(str.length()\u003e3) return str.toUpperCase(); return str; }); sort // List.sort()方法结合Lambda表达式 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(Arrays.asList(\"I\", \"love\", \"you\", \"too\")); list.sort((str1, str2) -\u003e str1.length()-str2.length()); … ","date":"2020-10-03 18:56:54","objectID":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:1:1","tags":["Java基础"],"title":"函数式编程","uri":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"Streams API() 函数接口是指内部只有一个抽象方法的接口 forEach() 我们对forEach()方法并不陌生，在Collection中我们已经见过。方法签名为void forEach(Consumer\u003c? super E\u003e action)，作用是对容器中的每个元素执行action指定的动作，也就是对元素进行遍历。 // 使用Stream.forEach()迭代 Stream\u003cString\u003e stream = Stream.of(\"I\", \"love\", \"you\", \"too\"); stream.forEach(str -\u003e System.out.println(str)); 由于forEach()是结束方法，上述代码会立即执行，输出所有字符串。 Filter() 数原型为Stream\u003cT\u003e filter(Predicate\u003c? super T\u003e predicate)，作用是返回一个只包含满足predicate条件元素的Stream。 // 保留长度等于3的字符串 Stream\u003cString\u003e stream= Stream.of(\"I\", \"love\", \"you\", \"too\"); stream.filter(str -\u003e str.length()==3) .forEach(str -\u003e System.out.println(str)); 上述代码将输出为长度等于3的字符串you和too。注意，由于filter()是个中间操作，如果只调用filter()不会有实际计算，因此也不会输出任何信息。 ","date":"2020-10-03 18:56:54","objectID":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:2:0","tags":["Java基础"],"title":"函数式编程","uri":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"递归 整数n的阶乘： interface IntCall { int call(int n); } public class RecursionExample { static IntCall intCall; public static void main(String[] args) { intCall = n -\u003e n == 0 ? 1 : n * intCall.call(n-1); Stream.of(intCall.call(10)).forEach(System.out::println); } } 输出结果： 3628800 实现Fibonacci数列： public class RecursiveFibonacci { IntCall fib; RecursiveFibonacci() { fib = n -\u003e { if (n == 0 || n == 1) { return n; } else { return fib.call(n - 1) + fib.call(n - 2); } }; } public int calFib(int n) { return fib.call(n); } public static void main(String[] args) { RecursiveFibonacci rec = new RecursiveFibonacci(); for (int i = 0; i \u003c 10; i++) { System.out.print(rec.calFib(i) + \" \"); } } } 输出结果： 0 1 1 2 3 5 8 13 21 34 ","date":"2020-10-03 18:56:54","objectID":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:2:1","tags":["Java基础"],"title":"函数式编程","uri":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"方法引用 Java8方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟：：然后跟方法名称。 ","date":"2020-10-03 18:56:54","objectID":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:2:2","tags":["Java基础"],"title":"函数式编程","uri":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"Runnable接口 Runnable 接口自 1.0 版以来一直在 Java 中，因此不需要导入。它也符合特殊的单方法接口格式：它的方法 run() 不带参数，也没有返回值。因此，我们可以使用 Lambda 表达式和方法引用作为 Runnable： // functional/RunnableMethodReference.java // 方法引用与 Runnable 接口的结合使用 class Go { static void go() { System.out.println(\"Go::go()\"); } } public class RunnableMethodReference { public static void main(String[] args) { new Thread(new Runnable() { public void run() { System.out.println(\"Anonymous\"); } }).start(); new Thread( () -\u003e System.out.println(\"lambda\") ).start(); new Thread(Go::go).start(); } }复制ErrorOK! 输出结果： Anonymous lambda Go::go() Thread 对象将 Runnable 作为其构造函数参数，并具有会调用 run() 的方法 start()。 注意，只有匿名内部类才需要具有名为 run() 的方法。 ","date":"2020-10-03 18:56:54","objectID":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:2:3","tags":["Java基础"],"title":"函数式编程","uri":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"函数式接口 方法引用和Lambda表达式都必须被赋值，同时复制需要类型信息才能使编译器保证类型的正确性尤其是Lambda 表达式，它引入了新的要求。 代码示例： x -\u003e x.toString()复制ErrorOK! 我们清楚这里返回类型必须是 String，但 x 是什么类型呢？ Lambda 表达式包含类型推导（编译器会自动推导出类型信息，避免了程序员显式地声明）。编译器必须能够以某种方式推导出 x 的类型。 下面是第二个代码示例： (x, y) -\u003e x + y 复制ErrorOK! 现在 x 和 y 可以是任何支持 + 运算符连接的数据类型，可以是两个不同的数值类型或者是 一个 String 加任意一种可自动转换为 String 的数据类型（这包括了大多数类型）。 但是，当 Lambda 表达式被赋值时，编译器必须确定 x 和 y 的确切类型以生成正确的代码。 (x, y) -\u003e x + y 复制ErrorOK! 现在 x 和 y 可以是任何支持 + 运算符连接的数据类型，可以是两个不同的数值类型或者是 一个 String 加任意一种可自动转换为 String 的数据类型（这包括了大多数类型）。 但是，当 Lambda 表达式被赋值时，编译器必须确定 x 和 y 的确切类型以生成正确的代码。 该问题也适用于方法引用。 假设你要传递 System.out :: println 到你正在编写的方法 ，你怎么知道传递给方法的参数的类型？ 为了解决这个问题，Java 8 引入了 java.util.function 包。它包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为函数式方法。 在编写接口时，可以使用 @FunctionalInterface 注解强制执行此“函数式方法”模式： // functional/FunctionalAnnotation.java @FunctionalInterface interface Functional { String goodbye(String arg); } interface FunctionalNoAnn { String goodbye(String arg); } /* @FunctionalInterface interface NotFunctional { String goodbye(String arg); String hello(String arg); } 产生错误信息: NotFunctional is not a functional interface multiple non-overriding abstract methods found in interface NotFunctional */ public class FunctionalAnnotation { public String goodbye(String arg) { return \"Goodbye, \" + arg; } public static void main(String[] args) { FunctionalAnnotation fa = new FunctionalAnnotation(); Functional f = fa::goodbye; FunctionalNoAnn fna = fa::goodbye; // Functional fac = fa; // Incompatible Functional fl = a -\u003e \"Goodbye, \" + a; FunctionalNoAnn fnal = a -\u003e \"Goodbye, \" + a; } } @FunctionalInterface 注解是可选的; Java 在 main() 中把 Functional 和 FunctionalNoAnn 都当作函数式接口。 在 NotFunctional 的定义中可看到@FunctionalInterface 的作用：接口中如果有多个抽象方法则会产生编译期错误。 仔细观察在定义 f 和 fna 时发生了什么。 Functional 和 FunctionalNoAnn 定义接口，然而被赋值的只是方法 goodbye()。首先，这只是一个方法而不是类；其次，它甚至都不是实现了该接口的类中的方法。这是添加到Java 8中的一点小魔法：如果将方法引用或 Lambda 表达式赋值给函数式接口（类型需要匹配），Java 会适配你的赋值到目标接口。 编译器会在后台把方法引用或 Lambda 表达式包装进实现目标接口的类的实例中。 尽管 FunctionalAnnotation 确实适合 Functional 模型，但 Java不允许我们像fac定义中的那样，将 FunctionalAnnotation 直接赋值给 Functional，因为 FunctionalAnnotation 并没有显式地去实现 Functional 接口。唯一的惊喜是，Java 8 允许我们将函数赋值给接口，这样的语法更加简单漂亮。 java.util.function 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。主要因为基本类型的存在，导致预定义的接口数量有少许增加。 如果你了解命名模式，顾名思义就能知道特定接口的作用。 以下是基本命名准则： 如果只处理对象而非基本类型，名称则为 Function，Consumer，Predicate 等。参数类型通过泛型添加。 如果接收的参数是基本类型，则由名称的第一部分表示，如 LongConsumer，DoubleFunction，IntPredicate 等，但返回基本类型的 Supplier 接口例外。 如果返回值为基本类型，则用 To 表示，如 ToLongFunction \u003cT\u003e 和 IntToLongFunction。 如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 UnaryOperator，两个参数使用 BinaryOperator。 如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。 如果接收的两个参数类型不同，则名称中有一个 Bi。 ","date":"2020-10-03 18:56:54","objectID":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/:2:4","tags":["Java基础"],"title":"函数式编程","uri":"/2020/10/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"categories":["Java基础"],"content":"基本语法 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:0","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"基本数据类型 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:0","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"8大基本类型 基本类型 大小 包装器类型 默认值 boolean Boolean false char 2字节 Character ‘u0000’ byte 1字节 Byte 0 short 2字节 Short 0 int 4字节 Integer 0 long 8字节 Long 0L float 4字节 Float 0f double 8字节 Double 0d tip 整数计算时，数据溢出，预防例子： avg = a + ((b - a) \u003e\u003e 1) ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:1","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"自动拆装箱 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:0","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"基本数类型有什么好处 new 一个对象时存储在堆里的，我们通过栈中的引用来使用这些对象，因此对象本身来说比较消耗资源。基本数据类型在栈内存中存储，因此会更加高效。 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:1","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"为什么包装类 Java是一种面向对象语言，很多地方需要使用对象而不是基本数据类型。为了让基本数据类型也有对象的特征，就出现包装类型。 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:2","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"自动拆箱与自动装箱 从JavaSE5中，Java开始提供了自动拆箱与装箱功能。 自动装箱：Integer.valueOf() 自动拆箱：xxxValue（） ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:3","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"String ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:0","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"字符串的不可变性 定义一个字符串 String s = “abcd” 使用变量赋值变量 String s2 = s s2 保存了相同的引用值，因为他们代表同意对象 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:1","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"字符串拼接的几种方式和区别 字符串不变性与字符串拼接 s = s.concat(“ef”) 使用+拼接字符串 使用+拼接字符串不能理解为运算符重载，其实并不是，Java是不支持运算符重载的。其实只是Java提供的一个语法糖。 StringBuffer 字符串常量的String类以外，还提供了可以用来定义字符串变量的StringBuffer类，它的对象是可以扩充和修改的。 其与StringBuilder的区别是synchronize线程安全。 StringBuilder 和StringBuffer作用是一样的，但不是线程安全的，但效率比StringBuffer高，因此在不考虑线程安全的情况下，建议使用StringBuilder。 StringUtils.join 除了JDK中内置的字符串拼接方法，还可以使用一些开源类库apache.commons中提供的StringUtils类，其中join方法可以拼接字符串 String a = “dasd”; StringUtils.join(a, “dafd”); 运行时间： StringBuilder\u003cStringBuffer\u003cconcat\u003c+\u003cStringUtils.join ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:2","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"String总结 常用的字符串拼接方式有五种，分别是使用+、使用concat、使用StringBuilder、使用StringBuffer以及使用StringUtils.join。 直接使用StringBuilder的方式是效率最高的。因为StringBuilder天生就是设计来定义可变字符串和字符串的变化操作的 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:3","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"Java各种关键字 访问控制 private protected public 类，方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile 程序控制 break continue return do while if else for instanceof switch case default 错误处理 try catch throw throws finally 包相关 import package 基本类型 boolean byte char double float int long short null true false 变量引用 super this void 保留字 const ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:0","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"transient Java语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。这里的对象存储是指，Java的serialization提供的一种持久化对象实例的机制。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。使用情况是：当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。 简单点说，就是被transient修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， transient 变量的值被设为初始值， 如 int 型的是 0，对象型的是 null。 instanceof instanceof是Java的保留关键字，用于测试左边和右边的实例是否相等，返回一个boolean的数据类型。 volatile 与synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用voilatile修饰就可以了。 1 . 保证了不同线程对该变量操作的内存可见性; 2 . 禁止指令重排序 synchronized synchronized是Java提供的一个并发控制的关键字。主要有两种用法，分别是同步方法和同步代码块。也就是说，synchronized既可以修饰方法也可以修饰代码块。 final 表示“这部分是无法修改的”。使用final定义：变量、方法、类。 final变量：则不能更改final变量的值 final方法：则无法对该方法进行覆盖重写 final类：则无法对该类进行进程 static 用来修饰成员变量和成员方法。 静态变量：不属于类的对象或者实例。因为静态变量与所有的对象实例共享，因此不具有线程安全性。 静态方法：静态方法是属于类而不是实例。 静态代码块：静态块是一组指令在类装载的时候在内存中由ClassLoader执行。常用语初始化类的静态变量。大多时候还用于在类装载时候创建静态资源。Java不允许在静态块中使用非静态变量。一个类中可以有多个静态块，尽管这似乎没有什么用。静态块只在类装载入内存时，执行一次。 const const是Java预留关键词，用于后期拓展用，用法跟final相似不常用。 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:1","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"Object类 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:0","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"Object常见方法 Object是一个特殊的类，它是所有类的父类。 public final native Class\u003c?\u003e getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。 public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。 public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。 protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。 public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。 public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。 public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。 public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。 public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念 protected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:1","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"hashcode（）介绍 hashcode（）的作用就是获取hashcode（散列码），实际上是一个int整数，作用是确定该对象在hash表中的索引位置。hashcode（）定义在Object类中，因此，Java的任意一个对象都拥有一个hashCode（）函数，且hashcode（）方法为native方法，是由c++和c实现的，该方法通常用来将对象的内存地址转换为整数之后返回。 hash表中存储的是键值对（key-value），用来快速查找对象。 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:2","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"为什么要有hashcode 例如HashSet，HashSet会先计算对象的hashcode值，然后通过该hashcode判断对象加入的位置，同时对其它已经加入的对象的hashcode进行比较，如果没有相符的hashcode，HashSet会假设对象没有重复。如果发现有相同的hashcode值的对象会调用equals（）方法来检查hashcode相等的对象是否真的相等，如果相等HashSet就不会让其加入操作。 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:3","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"hashcode（）与equals（）的相关规定 如果两个对象相等，则hashcode一定是相同的 两个对象相等，对两个对象分别调用equals方法返回true 两个对象有着相同的hashcode值，它们也不一定相等 因此，equals方法被覆盖过，则hashCode（）也必须被覆盖 hashCode（）的默认行为对heap上的对象产生独特值。如果没有重写hashCode（），则该class的两个对象无论如何都不会相等（即使两个对象指向相同的数据） ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:4","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"为什么两个对象有相同的hashcode值，它们也不一定相等 因为在散列表中，hashcode（）相等，及两个键值对的hash值相等。然而，hash值相等，并不能一定得出键值对相等。 “两个不同的键值对，hash值相等”。这就hash冲突。 此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。 举个例子：我们改写下hashCode()的算法为：num%3 ; 当num=1时，余数为1； 当num=4时，余数也为1； 这时他们的hashCode()是相同的，但equals()却是不同的。 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:5","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["Java基础"],"content":"==与equals ==：判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象。（基本数据类型==比较的是值，引用数据类型==比较的是内存地址） equals（）：判断的也是两个对象是否相等，一般有两种使用情况： 类没有覆盖equals（）方法，则通过equals（）比较该类的两个对象时，等价于“==”比较这两个对象 类覆盖率equals（）方法。 public class test1 { public static void main(String[] args) { String a = new String(\"ab\"); // a 为一个引用 String b = new String(\"ab\"); // b为另一个引用,对象的内容一样 String aa = \"ab\"; // 放在常量池中 String bb = \"ab\"; // 从常量池中查找 if (aa == bb) // true System.out.println(\"aa==bb\"); if (a == b) // false，非同一对象 System.out.println(\"a==b\"); if (a.equals(b)) // true System.out.println(\"aEQb\"); if (42 == 42.0) { // true System.out.println(\"true\"); } } } String 中的 equals()方法是被重写过的，因为 Object 的 equals()方法是比较的对象的内存地址，而 String 的 equals()方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 ","date":"2020-09-30 09:08:40","objectID":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:6","tags":["Java"],"title":"基本语法","uri":"/2020/09/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["网络"],"content":"Cookie\u0026Session Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。 Cookie一般用来保存用户信息 Cookie中一般保存当前网站你的信息，在下次访问的时候会自动帮你把登陆的一些基本信息给填了 Cookie还能使得你在下一次访问的时候不用重新登陆，下次登陆的时候只需要根据Token值来查找用户即可（为了安全考虑，重新登录一般要将Token重写） 登陆一次后访问其他的页面不需要再进行登陆 Session的主要作用就是通过服务端记录用户的状态 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。 ","date":"2020-09-29 19:20:15","objectID":"/2020/09/cookie-session/:0:0","tags":["网络"],"title":"Cookie\u0026Session","uri":"/2020/09/cookie-session/"},{"categories":["网络"],"content":"区别 Cookie数据保存客户端 Session数据保存在服务端 ","date":"2020-09-29 19:20:15","objectID":"/2020/09/cookie-session/:0:1","tags":["网络"],"title":"Cookie\u0026Session","uri":"/2020/09/cookie-session/"},{"categories":["网络"],"content":"Tips Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。 ","date":"2020-09-29 19:20:15","objectID":"/2020/09/cookie-session/:0:2","tags":["网络"],"title":"Cookie\u0026Session","uri":"/2020/09/cookie-session/"},{"categories":["网络"],"content":"HTTP/HTTPS ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:0:0","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"HTTP是什么？ HTTP（Hyper Text Transfer Protocol），是Web服务器传输超文本标记语言（HTML）到本地浏览器的传送协议。HTTP的诞生主要是为了能够让文档之间相互关联，形成超文本可以相互传阅。 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:1:0","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"HTTP基本概念 为什么要在计算机中分层次？ 因为两台计算机能够相互通信的话，实际实现起来是非常困难操作的，我们分层的目的就是为了将困难的问题简单化，并且如果我们分层了，我们在使用的时候就可以仅仅关注我们需要关注的层次，而不用理会其它层。 如果我们需要改动设计的时候，我们需要变动的层替换即可，并不用涉及到其它的层次。这是我们程序设计中的低耦合是一个概念。 **而我们的HTTP协议是最上层，也就是应用。**这就最贴近我们程序员的层次。 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:2:0","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"HTTP原理 HTTP是基于TCP/IP通信协议来传递数据的协议，客户端发起TCP请求，三次握手建立连接后，客户端发起HTTP请求，服务端进行HTTP响应。 用户请求 -\u003e 浏览器 浏览器 -\u003e 发起TCP连接请求 -\u003e 服务器(Tomcat) 服务器接收请求并建立连接 生成HTTP数据包(浏览器) 浏览器 发送数据包 -\u003e 服务器 解析HTTP格式的数据包(服务器) 执行请求 生成HTTP格式的数据包 服务器 发送响应数据包 -\u003e 浏览器 浏览器 解析HTTP格式数据包 浏览器程序html响应给用户 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:2:1","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"HTTP特点 http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。 灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。 无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。 无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:2:2","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"常见请求方法 GET： ⽤于请求访问已经被URI（统⼀资源标识符）识别的资源，可以通过URL传参给服务器 POST：⽤于传输信息给服务器，主要功能与GET⽅法类似，但⼀般推荐使⽤POST⽅式。 PUT： 传输⽂件，报⽂主体中包含⽂件内容，保存到对应URI位置。 HEAD： 获得报⽂⾸部，与GET⽅法类似，只是不返回报⽂主体，⼀般⽤于验证URI是否有效。 DELETE：删除⽂件，与PUT⽅法相反，删除对应URI位置的⽂件。 OPTIONS：查询相应URI⽀持的HTTP⽅法。 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:2:3","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"响应状态码 状态码分类： 1XX- 信息型，服务器收到请求，需要请求者继续操作。 2XX- 成功型，请求成功收到，理解并处理。 3XX - 重定向，需要进一步的操作以完成请求。 4XX - 客户端错误，请求包含语法错误或无法完成请求。 5XX - 服务器错误，服务器在处理请求的过程中发生了错误。 常见状态码： 200 OK - 客户端请求成功 204 成功处理，但服务器没有新数据返回，显示页面不更新 206 对服务器进行范围请求，服务器只返回部分资源 301 - 资源（网页等）被永久转移到其它URL 302 - 临时跳转 303 和 302 相同的功能，但明确刻画单应该采用GET方式来获取资源 304 发送了附带请求，但不符合条件（返回未过期的缓存数据） 400 Bad Request - 客户端请求有语法错误，不能被服务器所理解（请求报文语法有错误） 401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用（需要认证身份） 403 - 没有权限访问（没有权限） 404 - 请求资源不存在，可能是输入了错误的URL（服务器没有该资源） 500 - 服务器内部发生了不可预期的错误（内部资源出错） 503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。（服务器繁忙） ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:2:4","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"服务器与客户端之间的应用程序 一个HTTP服务器可以拥有多个站点，HTTP下可以配置多个节点的主机，当客户端访问的时候，可能访问的资源处于不同的主机，但实际上访问的是同一台HTTP服务器。 客户端和服务端之间还有一些用于通信数据转发的应用程序 代理 可以用来缓存，当代理缓存后，客户端就可直接从代理获取数据 可以用来对网站进行访问控制，获取访问日志记录 网关 能够提供非HTTP请求操作，访问数据库之类 隧道 建立一条安全的通信路径，可以使用SSL等加密手段加密 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:3:0","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"HTTP首部简述 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:4:0","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"HTTP报文组成 请求报文： 请求行：请求方法、URL（Uniform Resource Location）、协议/版本 请求头（Request Header） 请求正文 响应报文： 状态行 响应头 响应正文 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:4:1","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"请求报文 ⾸部字段例⼦： Accept: text/html,image/* 【浏览器告诉服务器，它⽀持的数据类型】 Accept-Charset: ISO-8859-1 【浏览器告诉服务器，它⽀持哪种字符集】 Accept-Encoding: gzip,compress 【浏览器告诉服务器，它⽀持的压缩格式】 Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语⾔环境】 Host: www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】 If-Modiﬁed-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】 Referer: http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个⻚⾯来的—反盗 链】 8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览 器的内核是什么】 Cookie【浏览器告诉服务器，带来的Cookie是什么】 Connection: close/Keep-Alive 【浏览器告诉服务器，请求完后是断开链接还是保持链接】 Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:4:2","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"HTTPS ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:5:0","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"HTTPS出现的原因 http传输的信息，是明文传输，不安全，容易被窃听截取。 通信使用明文 不验证通信方身份，无论是客户端和服务器，都是随意通信的 无法验证报文的完整性（别人监听后，可以篡改） 一般http中存在如下问题： 请求信息明文传输，容易被窃听截取。 数据的完整性未校验，容易被篡改 没有验证对方身份，存在冒充危险 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:5:1","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"什么是HTTPS？ HTTPS协议（HyperText Transfer Protocol over Secure Socket Layer）：一般为HTTP+SSL/TLS，通过SSL证书来验证服务器身份，并为浏览器和服务器之间的通信进行加密。 加密 对称加密 加密和解密都是用同一个密钥 非对称加密RSA 加密用公开的密钥，解密用私钥 私钥只有自己知道，公开的密钥大家都知道 数字签名 验证传输的内容是对方发送的数据 发送的数据没有被篡改过 数据证书（Certificate Authority）简称CA 认证机构证明是真实服务器发送的数据 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:5:2","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"HTTPS的缺点 HTTPS协议多次握手，导致页面的加载时间延长近50%； HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗； 申请SSL证书需要钱，功能越强大的证书费用越高。 SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:5:3","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"HTTPS工作原理 一、首先HTTP请求服务端生成证书，客户端对证书的有效性、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验。 二、客户端如果校验通过后，就根据证书的公钥的有效，生成随机数，随机数使用公钥进行加密（RSA加密） 三、消息体产生的后，对它的摘要进行MD5算法加密，此时就得到了RSA签名 四、发送给服务端，此时只有服务端（RSA私钥）能解密 五、解密得到的随机数，再要AES加密，作为密钥（此时的密钥只有客户端和服务端知道） ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:5:4","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"HTTP常见面试题 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:6:0","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"Https 与 Http 的区别： HTTP的标准端口是80，而HTTPS的标准端口是443 在OSI网络模型中，HTTP工作处于应用层，而HTTPS的安全传输机制工作在传输层 HTT无需证书，而HTTPS需要CA机制颁发的SSL证书 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:6:1","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"一次完整的HTTP请求步骤 一次完整的HTTP请求所经历的7个步骤 建立TCP连接 在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。 Web浏览器向Web服务器发送请求命令 一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。 Web浏览器发送请求头信息 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 Web服务器应答 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。 Web服务器发送应答头信息 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 Web服务器向浏览器发送数据 Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。\\ Web服务器关闭TCP连接 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:6:2","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["网络"],"content":"参考链接 https://zhuanlan.zhihu.com/p/72616216 https://snailclimb.gitee.io/javaguide/#/ https://blog.csdn.net/freekiteyu/article/details/72236734 ","date":"2020-09-29 19:19:56","objectID":"/2020/09/httphttps/:6:3","tags":["网络"],"title":"HttpHttps","uri":"/2020/09/httphttps/"},{"categories":["数据库"],"content":"MySQL57 ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"概念 SQL：Structure Query Language (结构化查询语言) 数据（Data） 数据库中存储的基本对象[图、文、声、像] 数据库（DataBase） 人们收集并取出一个应用所需要的大量数据之后，应将其保存起来，以供进一步加工处理，进一步抽取有用信息。 数据库就是[长期]存储在计算机内有[组织]的，可[共享]的[大量]数据集合。 数据库管理系统（DataBase Management System） 主要功能： 数据定义 DDL 数据描述语言 数据操作 DML：查询，更新 数据操作语言 数据库的运行，管理：保证数据的安全性，完整性 数据系统（Database System） DBMS的产生和发展： 什么是数据库管理 分类、组织、编码、存储、检索、维护 数据库管理技术的发展过程 人工管理 数据不保存 应用程序管理数据 数据不共享 数据不具有独立性 文件系统 数据可以长期保存 由文件系统管理数据 数据共享性差，冗余度大 数据独立性差[数据的逻辑结构改变，就必须修改应用程序] 数据库系统 数据结构化 数据的共享性高，冗余度低，易扩充 数据的独立性高 数据又DBMS统一管理和控制 DBMS的数据控制功能： 数据的安全性保护 数据的完整性检查 并发控制 数据库恢复 数据模型(通常由数据结构、数据操作和完整性约束三部分组成) 作用：抽象、表示、处理现实世界的信息 概念模型（信息模型） 按用户的观点来对数据和信息建模，主要用于数据库设计 逻辑和物理模型 逻辑模型： - 层次模型 - 网状模型 - 关系模型 - 面向对象模型 - 对象关系模型 组成要素： 数据结构[对系统的静态特性的描述] 数据结构描述数据库的组成对象以及对象之间的联系。 描述的内容： 与对象的类型、用户、性质有关的 与数据之间联系有关的对象 数据操作[对系统的动态特性的描述] 将对数据库中各种对象（型）的实力（值）允许执行的操作的集合，包括操作及有关的操作规则。 数据的完整性约束条件[一组完整性规则] 完整性规则用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。 ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"分类 SQL DQL: 数据查询语言 SELECT DML: 数据操作语言 INSERT UPDATE DELETE DDL: 数据定义语言 CREATE DROP ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"MySQL指令学习 (环境变量的配置名为 MySQL57) 客户端启动与关闭 net start MySQL57 net stop MySQL57 登录和注销 登录 mysql -u[数据库用户名] -p[对应的密码] – 用于登录自己本机的MySQL数据库 mysql -u[数据库用户名] -p[对应的密码] -p[数据库服务端口号] -h[数据库服务器的IP地址] –用于登录云服务器 退出 \\q; exit; quit; mysql -uroot -p[密码] //连接云服务器 mysql -uroot -p[密码] -h[ip地址] -- 例: 云服务器 IP:212.64.91.102 PORT:3306 USERNAME:root PASSWORD:gaozhu mysql -uroot -pgaozhu -h212.64.91.102 ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"SQL命令 ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"DQL 显示哪些线程正在运行 SHOW PROCESSLIST 显示系统变量信息 SHOW VARIABLES 查看当前数据库服务器上所有的数据库 SHOW DATABASES; SHOW SECHEMAS; SELECT 用于展示信息，展示select之后的内容，并且展示为结果集（格式）。 FROM 用于指定数据源 SELECT [LIST] FROM [TABLE_NAME] 查询语句 SELECT：指定数据源 FROM：筛选内容 WHERE：定制并且展示 GROUP BY: 分组内容 HAVING: 分组条件 ORDER: 数据筛选 LIMIT: 子句，限制结果数量子句 FROM \u003e WHERE \u003e GROUP BY \u003e (HAVING) \u003e SELECT \u003e ORDER BY \u003e LIMIT FROM table1 left join table2 on 将table1和table2中的数据产生笛卡尔积，生成Temp1 JOIN table2 所以先是确定表，再确定关联条件 ON table1.column = table2.columu 确定表的绑定条件 由Temp1产生中间表Temp2 WHERE 对中间表Temp2产生的结果进行过滤 产生中间表Temp3 GROUP BY 对中间表Temp3进行分组，产生中间表Temp4 HAVING 对分组后的记录进行聚合 产生中间表Temp5 SELECT 对中间表Temp5进行列筛选，产生中间表 Temp6 DISTINCT 对中间表 Temp6进行去重，产生中间表 Temp7 ORDER BY 对Temp7中的数据进行排序，产生中间表Temp8 LIMIT 对中间表Temp8进行分页，产生中间表Temp9 排序：ASC【缺省值】（从小到大），DESC（从大到小） 函数 数值函数 abs(x) – 绝对值 abs(-10.9) = 10 format(x, d) – 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46 ceil(x) – 向上取整 ceil(10.1) = 11 floor(x) – 向下取整 floor (10.1) = 10 round(x) – 四舍五入去整 mod(m, n) – m%n m mod n 求余 10%3=1 pi() – 获得圆周率 pow(m, n) – m^n sqrt(x) – 算术平方根 rand() – 随机数 truncate(x, d) – 截取d位小数 时间日期函数 now(), current_timestamp(); – 当前日期时间 current_date(); – 当前日期 current_time(); – 当前时间 date(‘yyyy-mm-dd hh:ii:ss’); – 获取日期部分 time(‘yyyy-mm-dd hh:ii:ss’); – 获取时间部分 date_format(‘yyyy-mm-dd hh:ii:ss’, ‘%d %y %a %d %m %b %j’); – 格式化时间 unix_timestamp(); – 获得unix时间戳 from_unixtime(); – 从时间戳获得时间 字符串函数 length(string) – string长度，字节展示的长度字节数 char_length(string) – string的字符个数 substring(str, position [,length]) – 从str的position开始,取length个字符 replace(str ,search_str ,replace_str) – 在str中用replace_str替换search_str instr(string ,substring) – 返回substring首次在string中出现的位置 concat(string [,…]) – 连接字串 charset(str) – 返回字串字符集 lcase(string) – 转换成小写 left(string, length) – 从string2中的左边起取length个字符 load_file(file_name) – 从文件读取内容 locate(substring, string [,start_position]) – 同instr,但可指定开始位置 lpad(string, length, pad) – 重复用pad加在string开头,直到字串长度为length ltrim(string) – 去除前端空格 repeat(string, count) – 重复count次 rpad(string, length, pad) –在str后用pad补充,直到长度为length rtrim(string) – 去除后端空格 strcmp(string1 ,string2) – 逐字符比较两字串大小 流程函数 case when [condition] then result [when [condition] then result …] [else result] end 多分支 if(expr1,expr2,expr3) 双分支。 聚合函数 count() sum(); max(); min(); avg(); group_concat() 其他常用函数 md5(); default(); 以定义划分 预定义函数（MySQL已经定义好的函数） 自定义函数（由我们自己根据实际的开发所需要定义的函数） 以功能进行划分 单行函数 多行函数（聚合函数，分组函数） 单行函数 length（）展示的长度是字节数 concat（）字符拼接 upper（）将字符转换为大写 lower（）将字符转化位小写 substr（）字符的截取 \u0026nbsp;substr([某一字符串]， [索引], [截取长度]) //若没有填写截取长度，从某一Number到最后的内容 instr（）查找某一字符第一次出现的位置 trim（）去除字符的内容 字符相关的函数 – 获取字符的长度 length() 展示的长度是字节数 SELECT length('nizhdsasa'),length('及你太美'); -- 查询所有员工的名字，按照员工的名字长短正序排序 SELECT e_first_name,e_last_name FROM t_employees ORDER BY length(e_first_name) DESC; -- concat() 字符拼接 SELECT concat('你好','我好','大家好'); -- 展示所有员工表中人的名字 SELECT concat(e_first_name,' ',e_last_name) FROM t_employees; -- 讲字符中的内容转换为大写 SELECT concat(('dsadfadsjfhdskljafASFdsfdsafsdaASFdsa'),lower('DSFSADFDSAdfasf')); -- 截取第10个字母到最后的内容 SELECT substr('abcdefghijklmnopqrst', 10); SELECT substr('abcdefghijklmnopqrst', 10, 5); SELECT instr('abcdefghoijklmn', 'a'); -- 去除 你好啊 两端的空格 SELECT trim(' dasfsa '); SELECT trim('a' FROM 'AAAAAaaaa'); -- 在'abc'左边补齐一堆0值得整个字符德内容长度达到10 SELECT lpad('abc', 10, '0'); -- 在右边 SELECT rpad('abc', 10, '0'); SELECT rpad('abcdefghijklmnopqrst', 10, '0'); -- 轻轻的我走了，正如我轻轻地来了，我挥一挥衣袖不带走一片云彩。把这段内容中的’轻轻’ 替换为 ‘骚骚’ SELECT replace('轻轻的我走了，正如我轻轻地来了，我挥一挥衣袖不带走一片云彩。','轻轻','骚骚'); 数值相关的函数 – 绝对值 SELECT abs(-100); -- 四舍五入 SELECT round(3.1415926); -- 向上取整向下取整 SELECT ceil(0.81111111); SELECT floor(32131.4324324354655456); -- 取模 SELECT mod(10, 3), 10%3; -- 截断小数 SELECT truncate(3.1415926,3); 日期相关的函数 序号 格式符 功能 1 %Y 四位数组成的年份 2 %y 两位数组成的年份 3 %m 月份（01,02,03,04…,11,12） 4 %c 月份（1,2,3,4,5…11,12） 5 %d 日（01,02….） 6 %H 小时（24小时制） 7 %h 小时（12小时制） 8 %i 分钟（00,01…59） 9 %s 秒钟（00,01…59） -- 获取当前时间(获取的是数据库的时间） SELECT now(); -- 获取当前的日期 [日期：年月日][时间：时分秒] SELECT curdate(),curtime(); -- yyyy-MM-dd HH:mm:ss 分离时间字段 SELECT year('2023-6-12 12:12:32'), month('2023-6-12 12:12:","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"DML INSERT select语句获得的数据可以用insert插入。 可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。或者使用set语法。 INSERT INTO tbl_name SET field=value,...； 可以一次性使用多个值，采用(), (), ();的形式。 INSERT INTO tbl_name VALUES (), (), (); 可以在列值指定时，使用表达式。 INSERT INTO tbl_name VALUES (field_value, 10+10, now()); 可以使用一个特殊值 DEFAULT，表示该列使用默认值。 INSERT INTO tbl_name VALUES (field_value, DEFAULT); 可以通过一个查询的结果，作为需要插入的值。 INSERT INTO tbl_name SELECT ...; UPDATE UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件] 多表连接更改 UPDATE t_employees te LEFT JOIN t_jobs tj on te.e_job_id=tj.j_id LEFT JOIN t_department td on te.e_department_id=td.d_id SET te.e_first_name='高柱',tj.j_title='sapo',td.d_name='sh' WHere te.e_id='102'; DELETE DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部 多表连接删除 DELETE tg,tb FROM t_girls tg LEFT JOIN t_boys tb on tg.g_boyfriend_id=tb.b_id WHERE g_name='周芷若'; ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"DDL 库的创建 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name 创建数据库并指定字符集(加上``解决关键字冲突问题) CREATE DATABASE INT CHARACTER SET utf8; 删除库 删除 DROP FUNCTION [IF EXISTS] function_name; 更改库 只能更库选项，不可更改名字（以前可以） ALTER DATABASE djj CHARACTER SET GBK; 数据类型 数值类型 a. 整型 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 默认存在符号位，unsigned 属性修改 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改(则变为无符号形式) 例：int(5) 插入一个数'123'，补填后为'00123' 在满足要求的情况下，越小越好。 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。 b. 浮点型 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) M表示总位数，D表示小数位数。 M和D的大小会决定浮点数的范围。不同于整型的固定范围。 插入的数据小数位大于D，四舍五入，大于5则不可插入报错，小于5的则会被忽略。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。 c. 定点数 decimal – 可变长度 decimal(M, D) M也表示总位数，D表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。 字符串类型 a. char, varchar char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 varchar(M) M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3 b. blob, text ———- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值 c. binary, varbinary ———- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob. 日期时间类型 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 类型 字节数 意义 时间范围 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155 表的创建 CREATE TABLE IF NOT EXISTS `t_person`( `p_id` INT COMMENT '人员编号', `p_name` VARCHAR(20) COMMENT '人员姓名', `p_sex` ENUM('male','female') COMMENT '人员性别', -- 存储的值要么是男，要么是女，如果是其他的值则无法保存。 `p_height` FLOAT(5,2) COMMENT '身高', `p_weight` FLOAT(5,2) COMMENT '体重', `p_birthday` DATETIME COMMENT '出生日期' )CHARACTER SET UTF8 COMMENT '人员信息表'; 非空约束 NOT NULL和NULL – 非空约束：约束在插入新的数据的时候，被约束的字段必须给出值 NOT NULL该项不能为空 默认约束 DEFAULT – 默认约束：如果在插入数据的过程中，如果没有给t_person2t_person2这个字段值，那么其会采用默认值(null)。 重复约束 UNIQUE 某个字段的值，不可重复出现。 检查约束 CHECK（MySQL不支持） 指的是给字段设定规则，要求其插入的值的过程中必须满足这个要 求。 主键约束 PRIMARY KEY 能唯一标识记录的字段，可以作为主键。 一个表只能有一个主键。 主键具有唯一性。 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); 主键字段的值不能为null。 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age)); 外键约束 FOREIGN KEY 被外键约束的列，其数据来源需要来源于主表。用于限制主表与从表数据完整性。 只支持列约束写法。 语法： FOREIGN KEY (外键字段） REFERENCES 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 每个外键都有一个名字可以通过CONSTRAINT指定。 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 外键约束：外键表插入数据的时候，引用的值必须首先在主表中存在。不然无法插入。 删除表的时候，必须先删除外键表，不然主键表无法被删除 逐渐表中，已经被外键表引用了的数据，除非先删除外键表中引用的数据，不然逐渐表中被引用的数据无法被直接删除。且外键字段与关联字段数据类型和字段长度必须相同。 列约束写法：将约束的内容直接的写在列的定义上。 列约束的写法，支持六种约束，除了、 检查约束（MySQL不支持） 将字段的约束定义在列的定义上 列级约束支持所有的约束（六种） 外键约束本身不支持列约束的语法（MySQL）只能在表约束的语法中写入。 表约束写法： 可添加复合主键 表约束可以支持外键约束 默认 非空 写在表级约束上无效 表的更改 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） – RENAME可以交换两个表名 修改表的字段结构 ALTER TABLE 表名 操作名 操作名 操作 作用 ADD[ COLUMN] 字段定义 – 增加字段 ADD PRIMARY KEY(字段名) – 创建主键 ADD UNIQUE [索引名] (字段名) – 创建唯一索引 ADD INDEX [索引名] (字段名) – 创建普通索引 DROP[ COLUMN] 字段名 – 删除字段 MODIFY[ COLUMN] 字段名 字段属性 – 支持对字段属性和约束进行修改，不能修改字段名(所","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"视图 什么是视图： \u003e视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。 视图作用: 简化业务逻辑 对客户端隐藏真实的表结构 视图与表的区别？ 表会占用实际空间，视图并没有占用物理空间（视图中的数据）。 视图可以增删改，但看情况。 视图操作 创建视图 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement 视图名必须唯一，同时不能与表重名。 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 可以指定视图执行的算法，通过ALGORITHM指定。 column_list如果存在，则数目必须等于SELECT语句检索的列数 视图算法(ALGORITHM) ALGORITHM 作用 其他 MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认) 指的是MySQL自主去选择相应的算法。 查看结构 SHOW CREATE VIEW view_name 删除视图 删除视图后，数据依然存在。 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name … 修改视图结构 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"事务（transaction） 什么是事务？ 事务是逻辑上的一组操作，要么都执行，要么都不执行。 自动事务 只要你对数据库执行了任何一条DQL或DML语句，那么每一行语句，都会被打包为一个事务并且提交。 声明式事务 由用户自行定义的事务，里面可能包含一行或者多行事务。 事务提交与回滚 事务的创建 隐式事务 隐式事务是指一个事务并没有明显的开启和结束的标记。 例如INSERT,UPDATE,DELETE等。 显示事务 我们自行定义的事务内容，包含多条语句。 事务开启 START TRANSACTION; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。 事务提交 事务提交 COMMIT; 事务回滚 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。 保存点 SAVEPOINT 保存点名称 – 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 – 回滚到保存点 RELEASE SAVEPOINT 保存点名称 – 删除保存点 事务的特性（ACID） 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务前后数据的完整性必须保持一致。 事务开始和结束时，外部数据一致 在整个事务过程中，操作是连续的 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 持久性（Durablity） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。 事务的实现 事务的实现  1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。 事务的原理 注意 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 事务不能被嵌套 ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"存储引擎 SHOW ENGINES; -InnoDB是MYSQL在Window中默认的存储引擎。 InnoDB自动提交特性 InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:6","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"事物隔离级别 MySQL的隔离级别为可重复读级别。 READ-UNCOMMITTED（读取未提交） 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED（读取已提交） 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ（可重复读） 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE（串行化） 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:7","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"并发事务带来的问题 脏读（Dirty read） 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 丢失修改（Lost to modify） 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 不可重复读（Unrepeatable read） 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 幻读（Phantom read） 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 不可重复读与幻读的区别 不可重复读的重点是修改，幻读的重点在于新增或者删除。 例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。 例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。 ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:8","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"杂项 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 每个库目录存在一个保存当前数据库的选项文件db.opt。 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 – 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 ' CMD命令行内的语句结束符可以为 “;”, “\\G”, “\\g”，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 SQL对大小写不敏感 清除已有语句：\\c ","date":"2020-09-29 08:14:05","objectID":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:9","tags":["数据库"],"title":"MySQL57学习笔记","uri":"/2020/09/mysql57%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"本人太懒了 ","date":"0001-01-01 00:00:00","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"友链 ","date":"0001-01-01 00:00:00","objectID":"/friends/:0:0","tags":null,"title":"友链","uri":"/friends/"}]